//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 612 // Disable "CS0612 '...' is obsolete"
#pragma warning disable 649 // Disable "CS0649 Field is never assigned to, and will always have its default value null"
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."
#pragma warning disable 8073 // Disable "CS8073 The result of the expression is always 'false' since a value of type 'T' is never equal to 'null' of type 'T?'"
#pragma warning disable 3016 // Disable "CS3016 Arrays as attribute arguments is not CLS-compliant"
#pragma warning disable 8603 // Disable "CS8603 Possible null reference return"
#pragma warning disable 8604 // Disable "CS8604 Possible null reference argument for parameter"
#pragma warning disable 8625 // Disable "CS8625 Cannot convert null literal to non-nullable reference type"
#pragma warning disable 8765 // Disable "CS8765 Nullability of type of parameter doesn't match overridden member (possibly because of nullability attributes)."

namespace DockerEngine
{
    using System = global::System;

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class DockerClient 
    {
        #pragma warning disable 8618
        private string _baseUrl;
        #pragma warning restore 8618

        private System.Net.Http.HttpClient _httpClient;
        private static System.Lazy<System.Text.Json.JsonSerializerOptions> _settings = new System.Lazy<System.Text.Json.JsonSerializerOptions>(CreateSerializerSettings, true);
        private System.Text.Json.JsonSerializerOptions _instanceSettings;

    #pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        public DockerClient(string baseUrl, System.Net.Http.HttpClient httpClient)
    #pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        {
            BaseUrl = baseUrl;
            _httpClient = httpClient;
            Initialize();
        }

        private static System.Text.Json.JsonSerializerOptions CreateSerializerSettings()
        {
            var settings = new System.Text.Json.JsonSerializerOptions();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        public string BaseUrl
        {
            get { return _baseUrl; }
            set
            {
                _baseUrl = value;
                if (!string.IsNullOrEmpty(_baseUrl) && !_baseUrl.EndsWith("/"))
                    _baseUrl += '/';
            }
        }

        protected System.Text.Json.JsonSerializerOptions JsonSerializerSettings { get { return _instanceSettings ?? _settings.Value; } }

        static partial void UpdateJsonSerializerSettings(System.Text.Json.JsonSerializerOptions settings);

        partial void Initialize();

        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);

        /// <summary>
        /// List containers
        /// </summary>
        /// <remarks>
        /// Returns a list of containers. For details on the format, see the
        /// <br/>[inspect endpoint](#operation/ContainerInspect).
        /// <br/>
        /// <br/>Note that it uses a different, smaller representation of a container
        /// <br/>than inspecting a single container. For example, the list of linked
        /// <br/>containers is not propagated .
        /// </remarks>
        /// <param name="all">Return all containers. By default, only running containers are shown.</param>
        /// <param name="limit">Return this number of most recently created containers, including
        /// <br/>non-running ones.</param>
        /// <param name="size">Return the size of container as fields `SizeRw` and `SizeRootFs`.</param>
        /// <param name="filters">Filters to process on the container list, encoded as JSON (a
        /// <br/>`map[string][]string`). For example, `{"status": ["paused"]}` will
        /// <br/>only return paused containers.
        /// <br/>
        /// <br/>Available filters:
        /// <br/>
        /// <br/>- `ancestor`=(`&lt;image-name&gt;[:&lt;tag&gt;]`, `&lt;image id&gt;`, or `&lt;image@digest&gt;`)
        /// <br/>- `before`=(`&lt;container id&gt;` or `&lt;container name&gt;`)
        /// <br/>- `expose`=(`&lt;port&gt;[/&lt;proto&gt;]`|`&lt;startport-endport&gt;/[&lt;proto&gt;]`)
        /// <br/>- `exited=&lt;int&gt;` containers with exit code of `&lt;int&gt;`
        /// <br/>- `health`=(`starting`|`healthy`|`unhealthy`|`none`)
        /// <br/>- `id=&lt;ID&gt;` a container's ID
        /// <br/>- `isolation=`(`default`|`process`|`hyperv`) (Windows daemon only)
        /// <br/>- `is-task=`(`true`|`false`)
        /// <br/>- `label=key` or `label="key=value"` of a container label
        /// <br/>- `name=&lt;name&gt;` a container's name
        /// <br/>- `network`=(`&lt;network id&gt;` or `&lt;network name&gt;`)
        /// <br/>- `publish`=(`&lt;port&gt;[/&lt;proto&gt;]`|`&lt;startport-endport&gt;/[&lt;proto&gt;]`)
        /// <br/>- `since`=(`&lt;container id&gt;` or `&lt;container name&gt;`)
        /// <br/>- `status=`(`created`|`restarting`|`running`|`removing`|`paused`|`exited`|`dead`)
        /// <br/>- `volume`=(`&lt;volume name&gt;` or `&lt;mount point destination&gt;`)</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ContainerSummary>> ContainerListAsync(bool? all, int? limit, bool? size, string filters)
        {
            return ContainerListAsync(all, limit, size, filters, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// List containers
        /// </summary>
        /// <remarks>
        /// Returns a list of containers. For details on the format, see the
        /// <br/>[inspect endpoint](#operation/ContainerInspect).
        /// <br/>
        /// <br/>Note that it uses a different, smaller representation of a container
        /// <br/>than inspecting a single container. For example, the list of linked
        /// <br/>containers is not propagated .
        /// </remarks>
        /// <param name="all">Return all containers. By default, only running containers are shown.</param>
        /// <param name="limit">Return this number of most recently created containers, including
        /// <br/>non-running ones.</param>
        /// <param name="size">Return the size of container as fields `SizeRw` and `SizeRootFs`.</param>
        /// <param name="filters">Filters to process on the container list, encoded as JSON (a
        /// <br/>`map[string][]string`). For example, `{"status": ["paused"]}` will
        /// <br/>only return paused containers.
        /// <br/>
        /// <br/>Available filters:
        /// <br/>
        /// <br/>- `ancestor`=(`&lt;image-name&gt;[:&lt;tag&gt;]`, `&lt;image id&gt;`, or `&lt;image@digest&gt;`)
        /// <br/>- `before`=(`&lt;container id&gt;` or `&lt;container name&gt;`)
        /// <br/>- `expose`=(`&lt;port&gt;[/&lt;proto&gt;]`|`&lt;startport-endport&gt;/[&lt;proto&gt;]`)
        /// <br/>- `exited=&lt;int&gt;` containers with exit code of `&lt;int&gt;`
        /// <br/>- `health`=(`starting`|`healthy`|`unhealthy`|`none`)
        /// <br/>- `id=&lt;ID&gt;` a container's ID
        /// <br/>- `isolation=`(`default`|`process`|`hyperv`) (Windows daemon only)
        /// <br/>- `is-task=`(`true`|`false`)
        /// <br/>- `label=key` or `label="key=value"` of a container label
        /// <br/>- `name=&lt;name&gt;` a container's name
        /// <br/>- `network`=(`&lt;network id&gt;` or `&lt;network name&gt;`)
        /// <br/>- `publish`=(`&lt;port&gt;[/&lt;proto&gt;]`|`&lt;startport-endport&gt;/[&lt;proto&gt;]`)
        /// <br/>- `since`=(`&lt;container id&gt;` or `&lt;container name&gt;`)
        /// <br/>- `status=`(`created`|`restarting`|`running`|`removing`|`paused`|`exited`|`dead`)
        /// <br/>- `volume`=(`&lt;volume name&gt;` or `&lt;mount point destination&gt;`)</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ContainerSummary>> ContainerListAsync(bool? all, int? limit, bool? size, string filters, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "containers/json"
                    urlBuilder_.Append("containers/json");
                    urlBuilder_.Append('?');
                    if (all != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("all")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(all, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (size != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("size")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(size, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (filters != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("filters")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(filters, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<ContainerSummary>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("bad parameter", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Create a container
        /// </summary>
        /// <param name="name">Assign the specified name to the container. Must match
        /// <br/>`/?[a-zA-Z0-9][a-zA-Z0-9_.-]+`.</param>
        /// <param name="platform">Platform in the format `os[/arch[/variant]]` used for image lookup.
        /// <br/>
        /// <br/>When specified, the daemon checks if the requested image is present
        /// <br/>in the local image cache with the given OS and Architecture, and
        /// <br/>otherwise returns a `404` status.
        /// <br/>
        /// <br/>If the option is not set, the host's native OS and Architecture are
        /// <br/>used to look up the image in the image cache. However, if no platform
        /// <br/>is passed and the given image does exist in the local image cache,
        /// <br/>but its OS or architecture does not match, the container is created
        /// <br/>with the available image, and a warning is added to the `Warnings`
        /// <br/>field in the response, for example;
        /// <br/>
        /// <br/>    WARNING: The requested image's platform (linux/arm64/v8) does not
        /// <br/>             match the detected host platform (linux/amd64) and no
        /// <br/>             specific platform was requested</param>
        /// <param name="body">Container to create</param>
        /// <returns>Container created successfully</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ContainerCreateResponse> ContainerCreateAsync(string name, string platform, Body body)
        {
            return ContainerCreateAsync(name, platform, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create a container
        /// </summary>
        /// <param name="name">Assign the specified name to the container. Must match
        /// <br/>`/?[a-zA-Z0-9][a-zA-Z0-9_.-]+`.</param>
        /// <param name="platform">Platform in the format `os[/arch[/variant]]` used for image lookup.
        /// <br/>
        /// <br/>When specified, the daemon checks if the requested image is present
        /// <br/>in the local image cache with the given OS and Architecture, and
        /// <br/>otherwise returns a `404` status.
        /// <br/>
        /// <br/>If the option is not set, the host's native OS and Architecture are
        /// <br/>used to look up the image in the image cache. However, if no platform
        /// <br/>is passed and the given image does exist in the local image cache,
        /// <br/>but its OS or architecture does not match, the container is created
        /// <br/>with the available image, and a warning is added to the `Warnings`
        /// <br/>field in the response, for example;
        /// <br/>
        /// <br/>    WARNING: The requested image's platform (linux/arm64/v8) does not
        /// <br/>             match the detected host platform (linux/amd64) and no
        /// <br/>             specific platform was requested</param>
        /// <param name="body">Container to create</param>
        /// <returns>Container created successfully</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ContainerCreateResponse> ContainerCreateAsync(string name, string platform, Body body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "containers/create"
                    urlBuilder_.Append("containers/create");
                    urlBuilder_.Append('?');
                    if (name != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("name")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (platform != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("platform")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(platform, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 201)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ContainerCreateResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("bad parameter", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("no such image", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("conflict", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Inspect a container
        /// </summary>
        /// <remarks>
        /// Return low-level information about a container.
        /// </remarks>
        /// <param name="id">ID or name of the container</param>
        /// <param name="size">Return the size of container as fields `SizeRw` and `SizeRootFs`</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ContainerInspectResponse> ContainerInspectAsync(string id, bool? size)
        {
            return ContainerInspectAsync(id, size, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Inspect a container
        /// </summary>
        /// <remarks>
        /// Return low-level information about a container.
        /// </remarks>
        /// <param name="id">ID or name of the container</param>
        /// <param name="size">Return the size of container as fields `SizeRw` and `SizeRootFs`</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ContainerInspectResponse> ContainerInspectAsync(string id, bool? size, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "containers/{id}/json"
                    urlBuilder_.Append("containers/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/json");
                    urlBuilder_.Append('?');
                    if (size != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("size")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(size, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ContainerInspectResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("no such container", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// List processes running inside a container
        /// </summary>
        /// <remarks>
        /// On Unix systems, this is done by running the `ps` command. This endpoint
        /// <br/>is not supported on Windows.
        /// </remarks>
        /// <param name="id">ID or name of the container</param>
        /// <param name="ps_args">The arguments to pass to `ps`. For example, `aux`</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ContainerTopResponse> ContainerTopAsync(string id, string ps_args)
        {
            return ContainerTopAsync(id, ps_args, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// List processes running inside a container
        /// </summary>
        /// <remarks>
        /// On Unix systems, this is done by running the `ps` command. This endpoint
        /// <br/>is not supported on Windows.
        /// </remarks>
        /// <param name="id">ID or name of the container</param>
        /// <param name="ps_args">The arguments to pass to `ps`. For example, `aux`</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ContainerTopResponse> ContainerTopAsync(string id, string ps_args, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "containers/{id}/top"
                    urlBuilder_.Append("containers/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/top");
                    urlBuilder_.Append('?');
                    if (ps_args != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("ps_args")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(ps_args, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ContainerTopResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("no such container", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get container logs
        /// </summary>
        /// <remarks>
        /// Get `stdout` and `stderr` logs from a container.
        /// <br/>
        /// <br/>Note: This endpoint works only for containers with the `json-file` or
        /// <br/>`journald` logging driver.
        /// </remarks>
        /// <param name="id">ID or name of the container</param>
        /// <param name="follow">Keep connection after returning logs.</param>
        /// <param name="stdout">Return logs from `stdout`</param>
        /// <param name="stderr">Return logs from `stderr`</param>
        /// <param name="since">Only return logs since this time, as a UNIX timestamp</param>
        /// <param name="until">Only return logs before this time, as a UNIX timestamp</param>
        /// <param name="timestamps">Add timestamps to every log line</param>
        /// <param name="tail">Only return this number of log lines from the end of the logs.
        /// <br/>Specify as an integer or `all` to output all log lines.</param>
        /// <returns>logs returned as a stream in response body.
        /// <br/>For the stream format, [see the documentation for the attach endpoint](#operation/ContainerAttach).
        /// <br/>Note that unlike the attach endpoint, the logs endpoint does not
        /// <br/>upgrade the connection and does not set Content-Type.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<FileResponse> ContainerLogsAsync(string id, bool? follow, bool? stdout, bool? stderr, int? since, int? until, bool? timestamps, string tail)
        {
            return ContainerLogsAsync(id, follow, stdout, stderr, since, until, timestamps, tail, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get container logs
        /// </summary>
        /// <remarks>
        /// Get `stdout` and `stderr` logs from a container.
        /// <br/>
        /// <br/>Note: This endpoint works only for containers with the `json-file` or
        /// <br/>`journald` logging driver.
        /// </remarks>
        /// <param name="id">ID or name of the container</param>
        /// <param name="follow">Keep connection after returning logs.</param>
        /// <param name="stdout">Return logs from `stdout`</param>
        /// <param name="stderr">Return logs from `stderr`</param>
        /// <param name="since">Only return logs since this time, as a UNIX timestamp</param>
        /// <param name="until">Only return logs before this time, as a UNIX timestamp</param>
        /// <param name="timestamps">Add timestamps to every log line</param>
        /// <param name="tail">Only return this number of log lines from the end of the logs.
        /// <br/>Specify as an integer or `all` to output all log lines.</param>
        /// <returns>logs returned as a stream in response body.
        /// <br/>For the stream format, [see the documentation for the attach endpoint](#operation/ContainerAttach).
        /// <br/>Note that unlike the attach endpoint, the logs endpoint does not
        /// <br/>upgrade the connection and does not set Content-Type.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<FileResponse> ContainerLogsAsync(string id, bool? follow, bool? stdout, bool? stderr, int? since, int? until, bool? timestamps, string tail, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/vnd.docker.raw-stream"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "containers/{id}/logs"
                    urlBuilder_.Append("containers/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/logs");
                    urlBuilder_.Append('?');
                    if (follow != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("follow")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(follow, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (stdout != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("stdout")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(stdout, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (stderr != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("stderr")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(stderr, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (since != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("since")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(since, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (until != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("until")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(until, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (timestamps != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("timestamps")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(timestamps, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (tail != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("tail")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(tail, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200 || status_ == 206)
                        {
                            var responseStream_ = response_.Content == null ? System.IO.Stream.Null : await response_.Content.ReadAsStreamAsync().ConfigureAwait(false);
                            var fileResponse_ = new FileResponse(status_, headers_, responseStream_, null, response_);
                            disposeClient_ = false; disposeResponse_ = false; // response and client are disposed by FileResponse
                            return fileResponse_;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("no such container", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get changes on a container’s filesystem
        /// </summary>
        /// <remarks>
        /// Returns which files in a container's filesystem have been added, deleted,
        /// <br/>or modified. The `Kind` of modification can be one of:
        /// <br/>
        /// <br/>- `0`: Modified ("C")
        /// <br/>- `1`: Added ("A")
        /// <br/>- `2`: Deleted ("D")
        /// </remarks>
        /// <param name="id">ID or name of the container</param>
        /// <returns>The list of changes</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<FilesystemChange>> ContainerChangesAsync(string id)
        {
            return ContainerChangesAsync(id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get changes on a container’s filesystem
        /// </summary>
        /// <remarks>
        /// Returns which files in a container's filesystem have been added, deleted,
        /// <br/>or modified. The `Kind` of modification can be one of:
        /// <br/>
        /// <br/>- `0`: Modified ("C")
        /// <br/>- `1`: Added ("A")
        /// <br/>- `2`: Deleted ("D")
        /// </remarks>
        /// <param name="id">ID or name of the container</param>
        /// <returns>The list of changes</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<FilesystemChange>> ContainerChangesAsync(string id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "containers/{id}/changes"
                    urlBuilder_.Append("containers/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/changes");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<FilesystemChange>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("no such container", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Export a container
        /// </summary>
        /// <remarks>
        /// Export the contents of a container as a tarball.
        /// </remarks>
        /// <param name="id">ID or name of the container</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<FileResponse> ContainerExportAsync(string id)
        {
            return ContainerExportAsync(id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Export a container
        /// </summary>
        /// <remarks>
        /// Export the contents of a container as a tarball.
        /// </remarks>
        /// <param name="id">ID or name of the container</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<FileResponse> ContainerExportAsync(string id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/octet-stream"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "containers/{id}/export"
                    urlBuilder_.Append("containers/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/export");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200 || status_ == 206)
                        {
                            return default(FileResponse);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("no such container", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get container stats based on resource usage
        /// </summary>
        /// <remarks>
        /// This endpoint returns a live stream of a container’s resource usage
        /// <br/>statistics.
        /// <br/>
        /// <br/>The `precpu_stats` is the CPU statistic of the *previous* read, and is
        /// <br/>used to calculate the CPU usage percentage. It is not an exact copy
        /// <br/>of the `cpu_stats` field.
        /// <br/>
        /// <br/>If either `precpu_stats.online_cpus` or `cpu_stats.online_cpus` is
        /// <br/>nil then for compatibility with older daemons the length of the
        /// <br/>corresponding `cpu_usage.percpu_usage` array should be used.
        /// <br/>
        /// <br/>On a cgroup v2 host, the following fields are not set
        /// <br/>* `blkio_stats`: all fields other than `io_service_bytes_recursive`
        /// <br/>* `cpu_stats`: `cpu_usage.percpu_usage`
        /// <br/>* `memory_stats`: `max_usage` and `failcnt`
        /// <br/>Also, `memory_stats.stats` fields are incompatible with cgroup v1.
        /// <br/>
        /// <br/>To calculate the values shown by the `stats` command of the docker cli tool
        /// <br/>the following formulas can be used:
        /// <br/>* used_memory = `memory_stats.usage - memory_stats.stats.cache`
        /// <br/>* available_memory = `memory_stats.limit`
        /// <br/>* Memory usage % = `(used_memory / available_memory) * 100.0`
        /// <br/>* cpu_delta = `cpu_stats.cpu_usage.total_usage - precpu_stats.cpu_usage.total_usage`
        /// <br/>* system_cpu_delta = `cpu_stats.system_cpu_usage - precpu_stats.system_cpu_usage`
        /// <br/>* number_cpus = `lenght(cpu_stats.cpu_usage.percpu_usage)` or `cpu_stats.online_cpus`
        /// <br/>* CPU usage % = `(cpu_delta / system_cpu_delta) * number_cpus * 100.0`
        /// </remarks>
        /// <param name="id">ID or name of the container</param>
        /// <param name="stream">Stream the output. If false, the stats will be output once and then
        /// <br/>it will disconnect.</param>
        /// <param name="one_shot">Only get a single stat instead of waiting for 2 cycles. Must be used
        /// <br/>with `stream=false`.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<object> ContainerStatsAsync(string id, bool? stream, bool? one_shot)
        {
            return ContainerStatsAsync(id, stream, one_shot, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get container stats based on resource usage
        /// </summary>
        /// <remarks>
        /// This endpoint returns a live stream of a container’s resource usage
        /// <br/>statistics.
        /// <br/>
        /// <br/>The `precpu_stats` is the CPU statistic of the *previous* read, and is
        /// <br/>used to calculate the CPU usage percentage. It is not an exact copy
        /// <br/>of the `cpu_stats` field.
        /// <br/>
        /// <br/>If either `precpu_stats.online_cpus` or `cpu_stats.online_cpus` is
        /// <br/>nil then for compatibility with older daemons the length of the
        /// <br/>corresponding `cpu_usage.percpu_usage` array should be used.
        /// <br/>
        /// <br/>On a cgroup v2 host, the following fields are not set
        /// <br/>* `blkio_stats`: all fields other than `io_service_bytes_recursive`
        /// <br/>* `cpu_stats`: `cpu_usage.percpu_usage`
        /// <br/>* `memory_stats`: `max_usage` and `failcnt`
        /// <br/>Also, `memory_stats.stats` fields are incompatible with cgroup v1.
        /// <br/>
        /// <br/>To calculate the values shown by the `stats` command of the docker cli tool
        /// <br/>the following formulas can be used:
        /// <br/>* used_memory = `memory_stats.usage - memory_stats.stats.cache`
        /// <br/>* available_memory = `memory_stats.limit`
        /// <br/>* Memory usage % = `(used_memory / available_memory) * 100.0`
        /// <br/>* cpu_delta = `cpu_stats.cpu_usage.total_usage - precpu_stats.cpu_usage.total_usage`
        /// <br/>* system_cpu_delta = `cpu_stats.system_cpu_usage - precpu_stats.system_cpu_usage`
        /// <br/>* number_cpus = `lenght(cpu_stats.cpu_usage.percpu_usage)` or `cpu_stats.online_cpus`
        /// <br/>* CPU usage % = `(cpu_delta / system_cpu_delta) * number_cpus * 100.0`
        /// </remarks>
        /// <param name="id">ID or name of the container</param>
        /// <param name="stream">Stream the output. If false, the stats will be output once and then
        /// <br/>it will disconnect.</param>
        /// <param name="one_shot">Only get a single stat instead of waiting for 2 cycles. Must be used
        /// <br/>with `stream=false`.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<object> ContainerStatsAsync(string id, bool? stream, bool? one_shot, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "containers/{id}/stats"
                    urlBuilder_.Append("containers/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/stats");
                    urlBuilder_.Append('?');
                    if (stream != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("stream")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(stream, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (one_shot != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("one-shot")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(one_shot, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<object>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("no such container", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Resize a container TTY
        /// </summary>
        /// <remarks>
        /// Resize the TTY for a container.
        /// </remarks>
        /// <param name="id">ID or name of the container</param>
        /// <param name="h">Height of the TTY session in characters</param>
        /// <param name="w">Width of the TTY session in characters</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ContainerResizeAsync(string id, int? h, int? w)
        {
            return ContainerResizeAsync(id, h, w, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Resize a container TTY
        /// </summary>
        /// <remarks>
        /// Resize the TTY for a container.
        /// </remarks>
        /// <param name="id">ID or name of the container</param>
        /// <param name="h">Height of the TTY session in characters</param>
        /// <param name="w">Width of the TTY session in characters</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ContainerResizeAsync(string id, int? h, int? w, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "text/plain");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "containers/{id}/resize"
                    urlBuilder_.Append("containers/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/resize");
                    urlBuilder_.Append('?');
                    if (h != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("h")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(h, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (w != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("w")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(w, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("no such container", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("cannot resize container", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Start a container
        /// </summary>
        /// <param name="id">ID or name of the container</param>
        /// <param name="detachKeys">Override the key sequence for detaching a container. Format is a
        /// <br/>single character `[a-Z]` or `ctrl-&lt;value&gt;` where `&lt;value&gt;` is one
        /// <br/>of: `a-z`, `@`, `^`, `[`, `,` or `_`.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ContainerStartAsync(string id, string detachKeys)
        {
            return ContainerStartAsync(id, detachKeys, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Start a container
        /// </summary>
        /// <param name="id">ID or name of the container</param>
        /// <param name="detachKeys">Override the key sequence for detaching a container. Format is a
        /// <br/>single character `[a-Z]` or `ctrl-&lt;value&gt;` where `&lt;value&gt;` is one
        /// <br/>of: `a-z`, `@`, `^`, `[`, `,` or `_`.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ContainerStartAsync(string id, string detachKeys, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "containers/{id}/start"
                    urlBuilder_.Append("containers/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/start");
                    urlBuilder_.Append('?');
                    if (detachKeys != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("detachKeys")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(detachKeys, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 304)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("container already started", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("no such container", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Stop a container
        /// </summary>
        /// <param name="id">ID or name of the container</param>
        /// <param name="signal">Signal to send to the container as an integer or string (e.g. `SIGINT`).</param>
        /// <param name="t">Number of seconds to wait before killing the container</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ContainerStopAsync(string id, string signal, int? t)
        {
            return ContainerStopAsync(id, signal, t, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Stop a container
        /// </summary>
        /// <param name="id">ID or name of the container</param>
        /// <param name="signal">Signal to send to the container as an integer or string (e.g. `SIGINT`).</param>
        /// <param name="t">Number of seconds to wait before killing the container</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ContainerStopAsync(string id, string signal, int? t, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "containers/{id}/stop"
                    urlBuilder_.Append("containers/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/stop");
                    urlBuilder_.Append('?');
                    if (signal != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("signal")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(signal, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (t != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("t")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(t, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 304)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("container already stopped", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("no such container", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Restart a container
        /// </summary>
        /// <param name="id">ID or name of the container</param>
        /// <param name="signal">Signal to send to the container as an integer or string (e.g. `SIGINT`).</param>
        /// <param name="t">Number of seconds to wait before killing the container</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ContainerRestartAsync(string id, string signal, int? t)
        {
            return ContainerRestartAsync(id, signal, t, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Restart a container
        /// </summary>
        /// <param name="id">ID or name of the container</param>
        /// <param name="signal">Signal to send to the container as an integer or string (e.g. `SIGINT`).</param>
        /// <param name="t">Number of seconds to wait before killing the container</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ContainerRestartAsync(string id, string signal, int? t, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "containers/{id}/restart"
                    urlBuilder_.Append("containers/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/restart");
                    urlBuilder_.Append('?');
                    if (signal != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("signal")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(signal, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (t != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("t")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(t, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("no such container", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Kill a container
        /// </summary>
        /// <remarks>
        /// Send a POSIX signal to a container, defaulting to killing to the
        /// <br/>container.
        /// </remarks>
        /// <param name="id">ID or name of the container</param>
        /// <param name="signal">Signal to send to the container as an integer or string (e.g. `SIGINT`).</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ContainerKillAsync(string id, string signal)
        {
            return ContainerKillAsync(id, signal, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Kill a container
        /// </summary>
        /// <remarks>
        /// Send a POSIX signal to a container, defaulting to killing to the
        /// <br/>container.
        /// </remarks>
        /// <param name="id">ID or name of the container</param>
        /// <param name="signal">Signal to send to the container as an integer or string (e.g. `SIGINT`).</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ContainerKillAsync(string id, string signal, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "containers/{id}/kill"
                    urlBuilder_.Append("containers/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/kill");
                    urlBuilder_.Append('?');
                    if (signal != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("signal")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(signal, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("no such container", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("container is not running", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Update a container
        /// </summary>
        /// <remarks>
        /// Change various configuration options of a container without having to
        /// <br/>recreate it.
        /// </remarks>
        /// <param name="id">ID or name of the container</param>
        /// <returns>The container has been updated.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ContainerUpdateResponse> ContainerUpdateAsync(string id, Update update)
        {
            return ContainerUpdateAsync(id, update, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update a container
        /// </summary>
        /// <remarks>
        /// Change various configuration options of a container without having to
        /// <br/>recreate it.
        /// </remarks>
        /// <param name="id">ID or name of the container</param>
        /// <returns>The container has been updated.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ContainerUpdateResponse> ContainerUpdateAsync(string id, Update update, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            if (update == null)
                throw new System.ArgumentNullException("update");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(update, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "containers/{id}/update"
                    urlBuilder_.Append("containers/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/update");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ContainerUpdateResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("no such container", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Rename a container
        /// </summary>
        /// <param name="id">ID or name of the container</param>
        /// <param name="name">New name for the container</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ContainerRenameAsync(string id, string name)
        {
            return ContainerRenameAsync(id, name, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Rename a container
        /// </summary>
        /// <param name="id">ID or name of the container</param>
        /// <param name="name">New name for the container</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ContainerRenameAsync(string id, string name, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            if (name == null)
                throw new System.ArgumentNullException("name");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "containers/{id}/rename"
                    urlBuilder_.Append("containers/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/rename");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("name")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("no such container", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("name already in use", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Pause a container
        /// </summary>
        /// <remarks>
        /// Use the freezer cgroup to suspend all processes in a container.
        /// <br/>
        /// <br/>Traditionally, when suspending a process the `SIGSTOP` signal is used,
        /// <br/>which is observable by the process being suspended. With the freezer
        /// <br/>cgroup the process is unaware, and unable to capture, that it is being
        /// <br/>suspended, and subsequently resumed.
        /// </remarks>
        /// <param name="id">ID or name of the container</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ContainerPauseAsync(string id)
        {
            return ContainerPauseAsync(id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pause a container
        /// </summary>
        /// <remarks>
        /// Use the freezer cgroup to suspend all processes in a container.
        /// <br/>
        /// <br/>Traditionally, when suspending a process the `SIGSTOP` signal is used,
        /// <br/>which is observable by the process being suspended. With the freezer
        /// <br/>cgroup the process is unaware, and unable to capture, that it is being
        /// <br/>suspended, and subsequently resumed.
        /// </remarks>
        /// <param name="id">ID or name of the container</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ContainerPauseAsync(string id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "containers/{id}/pause"
                    urlBuilder_.Append("containers/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/pause");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("no such container", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Unpause a container
        /// </summary>
        /// <remarks>
        /// Resume a container which has been paused.
        /// </remarks>
        /// <param name="id">ID or name of the container</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ContainerUnpauseAsync(string id)
        {
            return ContainerUnpauseAsync(id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Unpause a container
        /// </summary>
        /// <remarks>
        /// Resume a container which has been paused.
        /// </remarks>
        /// <param name="id">ID or name of the container</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ContainerUnpauseAsync(string id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "containers/{id}/unpause"
                    urlBuilder_.Append("containers/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/unpause");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("no such container", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Attach to a container
        /// </summary>
        /// <remarks>
        /// Attach to a container to read its output or send it input. You can attach
        /// <br/>to the same container multiple times and you can reattach to containers
        /// <br/>that have been detached.
        /// <br/>
        /// <br/>Either the `stream` or `logs` parameter must be `true` for this endpoint
        /// <br/>to do anything.
        /// <br/>
        /// <br/>See the [documentation for the `docker attach` command](https://docs.docker.com/engine/reference/commandline/attach/)
        /// <br/>for more details.
        /// <br/>
        /// <br/>### Hijacking
        /// <br/>
        /// <br/>This endpoint hijacks the HTTP connection to transport `stdin`, `stdout`,
        /// <br/>and `stderr` on the same socket.
        /// <br/>
        /// <br/>This is the response from the daemon for an attach request:
        /// <br/>
        /// <br/>```
        /// <br/>HTTP/1.1 200 OK
        /// <br/>Content-Type: application/vnd.docker.raw-stream
        /// <br/>
        /// <br/>[STREAM]
        /// <br/>```
        /// <br/>
        /// <br/>After the headers and two new lines, the TCP connection can now be used
        /// <br/>for raw, bidirectional communication between the client and server.
        /// <br/>
        /// <br/>To hint potential proxies about connection hijacking, the Docker client
        /// <br/>can also optionally send connection upgrade headers.
        /// <br/>
        /// <br/>For example, the client sends this request to upgrade the connection:
        /// <br/>
        /// <br/>```
        /// <br/>POST /containers/16253994b7c4/attach?stream=1&amp;stdout=1 HTTP/1.1
        /// <br/>Upgrade: tcp
        /// <br/>Connection: Upgrade
        /// <br/>```
        /// <br/>
        /// <br/>The Docker daemon will respond with a `101 UPGRADED` response, and will
        /// <br/>similarly follow with the raw stream:
        /// <br/>
        /// <br/>```
        /// <br/>HTTP/1.1 101 UPGRADED
        /// <br/>Content-Type: application/vnd.docker.raw-stream
        /// <br/>Connection: Upgrade
        /// <br/>Upgrade: tcp
        /// <br/>
        /// <br/>[STREAM]
        /// <br/>```
        /// <br/>
        /// <br/>### Stream format
        /// <br/>
        /// <br/>When the TTY setting is disabled in [`POST /containers/create`](#operation/ContainerCreate),
        /// <br/>the HTTP Content-Type header is set to application/vnd.docker.multiplexed-stream
        /// <br/>and the stream over the hijacked connected is multiplexed to separate out
        /// <br/>`stdout` and `stderr`. The stream consists of a series of frames, each
        /// <br/>containing a header and a payload.
        /// <br/>
        /// <br/>The header contains the information which the stream writes (`stdout` or
        /// <br/>`stderr`). It also contains the size of the associated frame encoded in
        /// <br/>the last four bytes (`uint32`).
        /// <br/>
        /// <br/>It is encoded on the first eight bytes like this:
        /// <br/>
        /// <br/>```go
        /// <br/>header := [8]byte{STREAM_TYPE, 0, 0, 0, SIZE1, SIZE2, SIZE3, SIZE4}
        /// <br/>```
        /// <br/>
        /// <br/>`STREAM_TYPE` can be:
        /// <br/>
        /// <br/>- 0: `stdin` (is written on `stdout`)
        /// <br/>- 1: `stdout`
        /// <br/>- 2: `stderr`
        /// <br/>
        /// <br/>`SIZE1, SIZE2, SIZE3, SIZE4` are the four bytes of the `uint32` size
        /// <br/>encoded as big endian.
        /// <br/>
        /// <br/>Following the header is the payload, which is the specified number of
        /// <br/>bytes of `STREAM_TYPE`.
        /// <br/>
        /// <br/>The simplest way to implement this protocol is the following:
        /// <br/>
        /// <br/>1. Read 8 bytes.
        /// <br/>2. Choose `stdout` or `stderr` depending on the first byte.
        /// <br/>3. Extract the frame size from the last four bytes.
        /// <br/>4. Read the extracted size and output it on the correct output.
        /// <br/>5. Goto 1.
        /// <br/>
        /// <br/>### Stream format when using a TTY
        /// <br/>
        /// <br/>When the TTY setting is enabled in [`POST /containers/create`](#operation/ContainerCreate),
        /// <br/>the stream is not multiplexed. The data exchanged over the hijacked
        /// <br/>connection is simply the raw data from the process PTY and client's
        /// <br/>`stdin`.
        /// </remarks>
        /// <param name="id">ID or name of the container</param>
        /// <param name="detachKeys">Override the key sequence for detaching a container.Format is a single
        /// <br/>character `[a-Z]` or `ctrl-&lt;value&gt;` where `&lt;value&gt;` is one of: `a-z`,
        /// <br/>`@`, `^`, `[`, `,` or `_`.</param>
        /// <param name="logs">Replay previous logs from the container.
        /// <br/>
        /// <br/>This is useful for attaching to a container that has started and you
        /// <br/>want to output everything since the container started.
        /// <br/>
        /// <br/>If `stream` is also enabled, once all the previous output has been
        /// <br/>returned, it will seamlessly transition into streaming current
        /// <br/>output.</param>
        /// <param name="stream">Stream attached streams from the time the request was made onwards.</param>
        /// <param name="stdin">Attach to `stdin`</param>
        /// <param name="stdout">Attach to `stdout`</param>
        /// <param name="stderr">Attach to `stderr`</param>
        /// <returns>no error, no upgrade header found</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<FileResponse> ContainerAttachAsync(string id, string detachKeys, bool? logs, bool? stream, bool? stdin, bool? stdout, bool? stderr)
        {
            return ContainerAttachAsync(id, detachKeys, logs, stream, stdin, stdout, stderr, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Attach to a container
        /// </summary>
        /// <remarks>
        /// Attach to a container to read its output or send it input. You can attach
        /// <br/>to the same container multiple times and you can reattach to containers
        /// <br/>that have been detached.
        /// <br/>
        /// <br/>Either the `stream` or `logs` parameter must be `true` for this endpoint
        /// <br/>to do anything.
        /// <br/>
        /// <br/>See the [documentation for the `docker attach` command](https://docs.docker.com/engine/reference/commandline/attach/)
        /// <br/>for more details.
        /// <br/>
        /// <br/>### Hijacking
        /// <br/>
        /// <br/>This endpoint hijacks the HTTP connection to transport `stdin`, `stdout`,
        /// <br/>and `stderr` on the same socket.
        /// <br/>
        /// <br/>This is the response from the daemon for an attach request:
        /// <br/>
        /// <br/>```
        /// <br/>HTTP/1.1 200 OK
        /// <br/>Content-Type: application/vnd.docker.raw-stream
        /// <br/>
        /// <br/>[STREAM]
        /// <br/>```
        /// <br/>
        /// <br/>After the headers and two new lines, the TCP connection can now be used
        /// <br/>for raw, bidirectional communication between the client and server.
        /// <br/>
        /// <br/>To hint potential proxies about connection hijacking, the Docker client
        /// <br/>can also optionally send connection upgrade headers.
        /// <br/>
        /// <br/>For example, the client sends this request to upgrade the connection:
        /// <br/>
        /// <br/>```
        /// <br/>POST /containers/16253994b7c4/attach?stream=1&amp;stdout=1 HTTP/1.1
        /// <br/>Upgrade: tcp
        /// <br/>Connection: Upgrade
        /// <br/>```
        /// <br/>
        /// <br/>The Docker daemon will respond with a `101 UPGRADED` response, and will
        /// <br/>similarly follow with the raw stream:
        /// <br/>
        /// <br/>```
        /// <br/>HTTP/1.1 101 UPGRADED
        /// <br/>Content-Type: application/vnd.docker.raw-stream
        /// <br/>Connection: Upgrade
        /// <br/>Upgrade: tcp
        /// <br/>
        /// <br/>[STREAM]
        /// <br/>```
        /// <br/>
        /// <br/>### Stream format
        /// <br/>
        /// <br/>When the TTY setting is disabled in [`POST /containers/create`](#operation/ContainerCreate),
        /// <br/>the HTTP Content-Type header is set to application/vnd.docker.multiplexed-stream
        /// <br/>and the stream over the hijacked connected is multiplexed to separate out
        /// <br/>`stdout` and `stderr`. The stream consists of a series of frames, each
        /// <br/>containing a header and a payload.
        /// <br/>
        /// <br/>The header contains the information which the stream writes (`stdout` or
        /// <br/>`stderr`). It also contains the size of the associated frame encoded in
        /// <br/>the last four bytes (`uint32`).
        /// <br/>
        /// <br/>It is encoded on the first eight bytes like this:
        /// <br/>
        /// <br/>```go
        /// <br/>header := [8]byte{STREAM_TYPE, 0, 0, 0, SIZE1, SIZE2, SIZE3, SIZE4}
        /// <br/>```
        /// <br/>
        /// <br/>`STREAM_TYPE` can be:
        /// <br/>
        /// <br/>- 0: `stdin` (is written on `stdout`)
        /// <br/>- 1: `stdout`
        /// <br/>- 2: `stderr`
        /// <br/>
        /// <br/>`SIZE1, SIZE2, SIZE3, SIZE4` are the four bytes of the `uint32` size
        /// <br/>encoded as big endian.
        /// <br/>
        /// <br/>Following the header is the payload, which is the specified number of
        /// <br/>bytes of `STREAM_TYPE`.
        /// <br/>
        /// <br/>The simplest way to implement this protocol is the following:
        /// <br/>
        /// <br/>1. Read 8 bytes.
        /// <br/>2. Choose `stdout` or `stderr` depending on the first byte.
        /// <br/>3. Extract the frame size from the last four bytes.
        /// <br/>4. Read the extracted size and output it on the correct output.
        /// <br/>5. Goto 1.
        /// <br/>
        /// <br/>### Stream format when using a TTY
        /// <br/>
        /// <br/>When the TTY setting is enabled in [`POST /containers/create`](#operation/ContainerCreate),
        /// <br/>the stream is not multiplexed. The data exchanged over the hijacked
        /// <br/>connection is simply the raw data from the process PTY and client's
        /// <br/>`stdin`.
        /// </remarks>
        /// <param name="id">ID or name of the container</param>
        /// <param name="detachKeys">Override the key sequence for detaching a container.Format is a single
        /// <br/>character `[a-Z]` or `ctrl-&lt;value&gt;` where `&lt;value&gt;` is one of: `a-z`,
        /// <br/>`@`, `^`, `[`, `,` or `_`.</param>
        /// <param name="logs">Replay previous logs from the container.
        /// <br/>
        /// <br/>This is useful for attaching to a container that has started and you
        /// <br/>want to output everything since the container started.
        /// <br/>
        /// <br/>If `stream` is also enabled, once all the previous output has been
        /// <br/>returned, it will seamlessly transition into streaming current
        /// <br/>output.</param>
        /// <param name="stream">Stream attached streams from the time the request was made onwards.</param>
        /// <param name="stdin">Attach to `stdin`</param>
        /// <param name="stdout">Attach to `stdout`</param>
        /// <param name="stderr">Attach to `stderr`</param>
        /// <returns>no error, no upgrade header found</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<FileResponse> ContainerAttachAsync(string id, string detachKeys, bool? logs, bool? stream, bool? stdin, bool? stdout, bool? stderr, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/vnd.docker.raw-stream");
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/vnd.docker.raw-stream"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "containers/{id}/attach"
                    urlBuilder_.Append("containers/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/attach");
                    urlBuilder_.Append('?');
                    if (detachKeys != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("detachKeys")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(detachKeys, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (logs != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("logs")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(logs, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (stream != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("stream")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(stream, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (stdin != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("stdin")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(stdin, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (stdout != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("stdout")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(stdout, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (stderr != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("stderr")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(stderr, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 101)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("no error, hints proxy about hijacking", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 200 || status_ == 206)
                        {
                            return default(FileResponse);
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("bad parameter", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("no such container", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Attach to a container via a websocket
        /// </summary>
        /// <param name="id">ID or name of the container</param>
        /// <param name="detachKeys">Override the key sequence for detaching a container.Format is a single
        /// <br/>character `[a-Z]` or `ctrl-&lt;value&gt;` where `&lt;value&gt;` is one of: `a-z`,
        /// <br/>`@`, `^`, `[`, `,`, or `_`.</param>
        /// <param name="logs">Return logs</param>
        /// <param name="stream">Return stream</param>
        /// <param name="stdin">Attach to `stdin`</param>
        /// <param name="stdout">Attach to `stdout`</param>
        /// <param name="stderr">Attach to `stderr`</param>
        /// <returns>no error, no upgrade header found</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ContainerAttachWebsocketAsync(string id, string detachKeys, bool? logs, bool? stream, bool? stdin, bool? stdout, bool? stderr)
        {
            return ContainerAttachWebsocketAsync(id, detachKeys, logs, stream, stdin, stdout, stderr, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Attach to a container via a websocket
        /// </summary>
        /// <param name="id">ID or name of the container</param>
        /// <param name="detachKeys">Override the key sequence for detaching a container.Format is a single
        /// <br/>character `[a-Z]` or `ctrl-&lt;value&gt;` where `&lt;value&gt;` is one of: `a-z`,
        /// <br/>`@`, `^`, `[`, `,`, or `_`.</param>
        /// <param name="logs">Return logs</param>
        /// <param name="stream">Return stream</param>
        /// <param name="stdin">Attach to `stdin`</param>
        /// <param name="stdout">Attach to `stdout`</param>
        /// <param name="stderr">Attach to `stderr`</param>
        /// <returns>no error, no upgrade header found</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ContainerAttachWebsocketAsync(string id, string detachKeys, bool? logs, bool? stream, bool? stdin, bool? stdout, bool? stderr, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "containers/{id}/attach/ws"
                    urlBuilder_.Append("containers/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/attach/ws");
                    urlBuilder_.Append('?');
                    if (detachKeys != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("detachKeys")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(detachKeys, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (logs != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("logs")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(logs, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (stream != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("stream")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(stream, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (stdin != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("stdin")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(stdin, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (stdout != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("stdout")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(stdout, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (stderr != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("stderr")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(stderr, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 101)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("no error, hints proxy about hijacking", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("bad parameter", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("no such container", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Wait for a container
        /// </summary>
        /// <remarks>
        /// Block until a container stops, then returns the exit code.
        /// </remarks>
        /// <param name="id">ID or name of the container</param>
        /// <param name="condition">Wait until a container state reaches the given condition.
        /// <br/>
        /// <br/>Defaults to `not-running` if omitted or empty.</param>
        /// <returns>The container has exit.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ContainerWaitResponse> ContainerWaitAsync(string id, Condition? condition)
        {
            return ContainerWaitAsync(id, condition, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Wait for a container
        /// </summary>
        /// <remarks>
        /// Block until a container stops, then returns the exit code.
        /// </remarks>
        /// <param name="id">ID or name of the container</param>
        /// <param name="condition">Wait until a container state reaches the given condition.
        /// <br/>
        /// <br/>Defaults to `not-running` if omitted or empty.</param>
        /// <returns>The container has exit.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ContainerWaitResponse> ContainerWaitAsync(string id, Condition? condition, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "containers/{id}/wait"
                    urlBuilder_.Append("containers/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/wait");
                    urlBuilder_.Append('?');
                    if (condition != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("condition")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(condition, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ContainerWaitResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("bad parameter", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("no such container", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove a container
        /// </summary>
        /// <param name="id">ID or name of the container</param>
        /// <param name="v">Remove anonymous volumes associated with the container.</param>
        /// <param name="force">If the container is running, kill it before removing it.</param>
        /// <param name="link">Remove the specified link associated with the container.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ContainerDeleteAsync(string id, bool? v, bool? force, bool? link)
        {
            return ContainerDeleteAsync(id, v, force, link, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove a container
        /// </summary>
        /// <param name="id">ID or name of the container</param>
        /// <param name="v">Remove anonymous volumes associated with the container.</param>
        /// <param name="force">If the container is running, kill it before removing it.</param>
        /// <param name="link">Remove the specified link associated with the container.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ContainerDeleteAsync(string id, bool? v, bool? force, bool? link, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "containers/{id}"
                    urlBuilder_.Append("containers/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('?');
                    if (v != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("v")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(v, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (force != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("force")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(force, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (link != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("link")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(link, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("bad parameter", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("no such container", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("conflict", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get information about files in a container
        /// </summary>
        /// <remarks>
        /// A response header `X-Docker-Container-Path-Stat` is returned, containing
        /// <br/>a base64 - encoded JSON object with some filesystem header information
        /// <br/>about the path.
        /// </remarks>
        /// <param name="id">ID or name of the container</param>
        /// <param name="path">Resource in the container’s filesystem to archive.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ContainerArchiveInfoAsync(string id, string path)
        {
            return ContainerArchiveInfoAsync(id, path, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get information about files in a container
        /// </summary>
        /// <remarks>
        /// A response header `X-Docker-Container-Path-Stat` is returned, containing
        /// <br/>a base64 - encoded JSON object with some filesystem header information
        /// <br/>about the path.
        /// </remarks>
        /// <param name="id">ID or name of the container</param>
        /// <param name="path">Resource in the container’s filesystem to archive.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ContainerArchiveInfoAsync(string id, string path, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            if (path == null)
                throw new System.ArgumentNullException("path");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("HEAD");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "containers/{id}/archive"
                    urlBuilder_.Append("containers/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/archive");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("path")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(path, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Bad parameter", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Container or path does not exist", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get an archive of a filesystem resource in a container
        /// </summary>
        /// <remarks>
        /// Get a tar archive of a resource in the filesystem of container id.
        /// </remarks>
        /// <param name="id">ID or name of the container</param>
        /// <param name="path">Resource in the container’s filesystem to archive.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<FileResponse> ContainerArchiveAsync(string id, string path)
        {
            return ContainerArchiveAsync(id, path, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get an archive of a filesystem resource in a container
        /// </summary>
        /// <remarks>
        /// Get a tar archive of a resource in the filesystem of container id.
        /// </remarks>
        /// <param name="id">ID or name of the container</param>
        /// <param name="path">Resource in the container’s filesystem to archive.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<FileResponse> ContainerArchiveAsync(string id, string path, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            if (path == null)
                throw new System.ArgumentNullException("path");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/x-tar"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "containers/{id}/archive"
                    urlBuilder_.Append("containers/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/archive");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("path")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(path, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200 || status_ == 206)
                        {
                            return default(FileResponse);
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Bad parameter", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Container or path does not exist", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Extract an archive of files or folders to a directory in a container
        /// </summary>
        /// <remarks>
        /// Upload a tar archive to be extracted to a path in the filesystem of container id.
        /// <br/>`path` parameter is asserted to be a directory. If it exists as a file, 400 error
        /// <br/>will be returned with message "not a directory".
        /// </remarks>
        /// <param name="id">ID or name of the container</param>
        /// <param name="path">Path to a directory in the container to extract the archive’s contents into.</param>
        /// <param name="noOverwriteDirNonDir">If `1`, `true`, or `True` then it will be an error if unpacking the
        /// <br/>given content would cause an existing directory to be replaced with
        /// <br/>a non-directory and vice versa.</param>
        /// <param name="copyUIDGID">If `1`, `true`, then it will copy UID/GID maps to the dest file or
        /// <br/>dir</param>
        /// <param name="inputStream">The input stream must be a tar archive compressed with one of the
        /// <br/>following algorithms: `identity` (no compression), `gzip`, `bzip2`,
        /// <br/>or `xz`.</param>
        /// <returns>The content was extracted successfully</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task PutContainerArchiveAsync(string id, string path, string noOverwriteDirNonDir, string copyUIDGID, FileParameter inputStream)
        {
            return PutContainerArchiveAsync(id, path, noOverwriteDirNonDir, copyUIDGID, inputStream, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Extract an archive of files or folders to a directory in a container
        /// </summary>
        /// <remarks>
        /// Upload a tar archive to be extracted to a path in the filesystem of container id.
        /// <br/>`path` parameter is asserted to be a directory. If it exists as a file, 400 error
        /// <br/>will be returned with message "not a directory".
        /// </remarks>
        /// <param name="id">ID or name of the container</param>
        /// <param name="path">Path to a directory in the container to extract the archive’s contents into.</param>
        /// <param name="noOverwriteDirNonDir">If `1`, `true`, or `True` then it will be an error if unpacking the
        /// <br/>given content would cause an existing directory to be replaced with
        /// <br/>a non-directory and vice versa.</param>
        /// <param name="copyUIDGID">If `1`, `true`, then it will copy UID/GID maps to the dest file or
        /// <br/>dir</param>
        /// <param name="inputStream">The input stream must be a tar archive compressed with one of the
        /// <br/>following algorithms: `identity` (no compression), `gzip`, `bzip2`,
        /// <br/>or `xz`.</param>
        /// <returns>The content was extracted successfully</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task PutContainerArchiveAsync(string id, string path, string noOverwriteDirNonDir, string copyUIDGID, FileParameter inputStream, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            if (path == null)
                throw new System.ArgumentNullException("path");

            if (inputStream == null)
                throw new System.ArgumentNullException("inputStream");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StreamContent(inputStream.Data);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse(inputStream.ContentType);
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "containers/{id}/archive"
                    urlBuilder_.Append("containers/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/archive");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("path")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(path, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (noOverwriteDirNonDir != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("noOverwriteDirNonDir")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(noOverwriteDirNonDir, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (copyUIDGID != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("copyUIDGID")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(copyUIDGID, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Bad parameter", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Permission denied, the volume or container rootfs is marked as read-only.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("No such container or path does not exist inside the container", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete stopped containers
        /// </summary>
        /// <param name="filters">Filters to process on the prune list, encoded as JSON (a `map[string][]string`).
        /// <br/>
        /// <br/>Available filters:
        /// <br/>- `until=&lt;timestamp&gt;` Prune containers created before this timestamp. The `&lt;timestamp&gt;` can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. `10m`, `1h30m`) computed relative to the daemon machine’s time.
        /// <br/>- `label` (`label=&lt;key&gt;`, `label=&lt;key&gt;=&lt;value&gt;`, `label!=&lt;key&gt;`, or `label!=&lt;key&gt;=&lt;value&gt;`) Prune containers with (or without, in case `label!=...` is used) the specified labels.</param>
        /// <returns>No error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ContainerPruneResponse> ContainerPruneAsync(string filters)
        {
            return ContainerPruneAsync(filters, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete stopped containers
        /// </summary>
        /// <param name="filters">Filters to process on the prune list, encoded as JSON (a `map[string][]string`).
        /// <br/>
        /// <br/>Available filters:
        /// <br/>- `until=&lt;timestamp&gt;` Prune containers created before this timestamp. The `&lt;timestamp&gt;` can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. `10m`, `1h30m`) computed relative to the daemon machine’s time.
        /// <br/>- `label` (`label=&lt;key&gt;`, `label=&lt;key&gt;=&lt;value&gt;`, `label!=&lt;key&gt;`, or `label!=&lt;key&gt;=&lt;value&gt;`) Prune containers with (or without, in case `label!=...` is used) the specified labels.</param>
        /// <returns>No error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ContainerPruneResponse> ContainerPruneAsync(string filters, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "containers/prune"
                    urlBuilder_.Append("containers/prune");
                    urlBuilder_.Append('?');
                    if (filters != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("filters")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(filters, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ContainerPruneResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// List Images
        /// </summary>
        /// <remarks>
        /// Returns a list of images on the server. Note that it uses a different, smaller representation of an image than inspecting a single image.
        /// </remarks>
        /// <param name="all">Show all images. Only images from a final layer (no children) are shown by default.</param>
        /// <param name="filters">A JSON encoded value of the filters (a `map[string][]string`) to
        /// <br/>process on the images list.
        /// <br/>
        /// <br/>Available filters:
        /// <br/>
        /// <br/>- `before`=(`&lt;image-name&gt;[:&lt;tag&gt;]`,  `&lt;image id&gt;` or `&lt;image@digest&gt;`)
        /// <br/>- `dangling=true`
        /// <br/>- `label=key` or `label="key=value"` of an image label
        /// <br/>- `reference`=(`&lt;image-name&gt;[:&lt;tag&gt;]`)
        /// <br/>- `since`=(`&lt;image-name&gt;[:&lt;tag&gt;]`,  `&lt;image id&gt;` or `&lt;image@digest&gt;`)
        /// <br/>- `until=&lt;timestamp&gt;`</param>
        /// <param name="shared_size">Compute and show shared size as a `SharedSize` field on each image.</param>
        /// <param name="digests">Show digest information as a `RepoDigests` field on each image.</param>
        /// <returns>Summary image data for the images matching the query</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ImageSummary>> ImageListAsync(bool? all, string filters, bool? shared_size, bool? digests)
        {
            return ImageListAsync(all, filters, shared_size, digests, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// List Images
        /// </summary>
        /// <remarks>
        /// Returns a list of images on the server. Note that it uses a different, smaller representation of an image than inspecting a single image.
        /// </remarks>
        /// <param name="all">Show all images. Only images from a final layer (no children) are shown by default.</param>
        /// <param name="filters">A JSON encoded value of the filters (a `map[string][]string`) to
        /// <br/>process on the images list.
        /// <br/>
        /// <br/>Available filters:
        /// <br/>
        /// <br/>- `before`=(`&lt;image-name&gt;[:&lt;tag&gt;]`,  `&lt;image id&gt;` or `&lt;image@digest&gt;`)
        /// <br/>- `dangling=true`
        /// <br/>- `label=key` or `label="key=value"` of an image label
        /// <br/>- `reference`=(`&lt;image-name&gt;[:&lt;tag&gt;]`)
        /// <br/>- `since`=(`&lt;image-name&gt;[:&lt;tag&gt;]`,  `&lt;image id&gt;` or `&lt;image@digest&gt;`)
        /// <br/>- `until=&lt;timestamp&gt;`</param>
        /// <param name="shared_size">Compute and show shared size as a `SharedSize` field on each image.</param>
        /// <param name="digests">Show digest information as a `RepoDigests` field on each image.</param>
        /// <returns>Summary image data for the images matching the query</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ImageSummary>> ImageListAsync(bool? all, string filters, bool? shared_size, bool? digests, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "images/json"
                    urlBuilder_.Append("images/json");
                    urlBuilder_.Append('?');
                    if (all != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("all")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(all, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (filters != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("filters")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(filters, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (shared_size != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("shared-size")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(shared_size, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (digests != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("digests")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(digests, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<ImageSummary>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Build an image
        /// </summary>
        /// <remarks>
        /// Build an image from a tar archive with a `Dockerfile` in it.
        /// <br/>
        /// <br/>The `Dockerfile` specifies how the image is built from the tar archive. It is typically in the archive's root, but can be at a different path or have a different name by specifying the `dockerfile` parameter. [See the `Dockerfile` reference for more information](https://docs.docker.com/engine/reference/builder/).
        /// <br/>
        /// <br/>The Docker daemon performs a preliminary validation of the `Dockerfile` before starting the build, and returns an error if the syntax is incorrect. After that, each instruction is run one-by-one until the ID of the new image is output.
        /// <br/>
        /// <br/>The build is canceled if the client drops the connection by quitting or being killed.
        /// </remarks>
        /// <param name="inputStream">A tar archive compressed with one of the following algorithms: identity (no compression), gzip, bzip2, xz.</param>
        /// <param name="dockerfile">Path within the build context to the `Dockerfile`. This is ignored if `remote` is specified and points to an external `Dockerfile`.</param>
        /// <param name="t">A name and optional tag to apply to the image in the `name:tag` format. If you omit the tag the default `latest` value is assumed. You can provide several `t` parameters.</param>
        /// <param name="extrahosts">Extra hosts to add to /etc/hosts</param>
        /// <param name="remote">A Git repository URI or HTTP/HTTPS context URI. If the URI points to a single text file, the file’s contents are placed into a file called `Dockerfile` and the image is built from that file. If the URI points to a tarball, the file is downloaded by the daemon and the contents therein used as the context for the build. If the URI points to a tarball and the `dockerfile` parameter is also specified, there must be a file with the corresponding path inside the tarball.</param>
        /// <param name="q">Suppress verbose build output.</param>
        /// <param name="nocache">Do not use the cache when building the image.</param>
        /// <param name="cachefrom">JSON array of images used for build cache resolution.</param>
        /// <param name="pull">Attempt to pull the image even if an older image exists locally.</param>
        /// <param name="rm">Remove intermediate containers after a successful build.</param>
        /// <param name="forcerm">Always remove intermediate containers, even upon failure.</param>
        /// <param name="memory">Set memory limit for build.</param>
        /// <param name="memswap">Total memory (memory + swap). Set as `-1` to disable swap.</param>
        /// <param name="cpushares">CPU shares (relative weight).</param>
        /// <param name="cpusetcpus">CPUs in which to allow execution (e.g., `0-3`, `0,1`).</param>
        /// <param name="cpuperiod">The length of a CPU period in microseconds.</param>
        /// <param name="cpuquota">Microseconds of CPU time that the container can get in a CPU period.</param>
        /// <param name="buildargs">JSON map of string pairs for build-time variables. Users pass these values at build-time. Docker uses the buildargs as the environment context for commands run via the `Dockerfile` RUN instruction, or for variable expansion in other `Dockerfile` instructions. This is not meant for passing secret values.
        /// <br/>
        /// <br/>For example, the build arg `FOO=bar` would become `{"FOO":"bar"}` in JSON. This would result in the query parameter `buildargs={"FOO":"bar"}`. Note that `{"FOO":"bar"}` should be URI component encoded.
        /// <br/>
        /// <br/>[Read more about the buildargs instruction.](https://docs.docker.com/engine/reference/builder/#arg)</param>
        /// <param name="shmsize">Size of `/dev/shm` in bytes. The size must be greater than 0. If omitted the system uses 64MB.</param>
        /// <param name="squash">Squash the resulting images layers into a single layer. *(Experimental release only.)*</param>
        /// <param name="labels">Arbitrary key/value labels to set on the image, as a JSON map of string pairs.</param>
        /// <param name="networkmode">Sets the networking mode for the run commands during build. Supported
        /// <br/>standard values are: `bridge`, `host`, `none`, and `container:&lt;name|id&gt;`.
        /// <br/>Any other value is taken as a custom network's name or ID to which this
        /// <br/>container should connect to.</param>
        /// <param name="x_Registry_Config">This is a base64-encoded JSON object with auth configurations for multiple registries that a build may refer to.
        /// <br/>
        /// <br/>The key is a registry URL, and the value is an auth configuration object, [as described in the authentication section](#section/Authentication). For example:
        /// <br/>
        /// <br/>```
        /// <br/>{
        /// <br/>  "docker.example.com": {
        /// <br/>    "username": "janedoe",
        /// <br/>    "password": "hunter2"
        /// <br/>  },
        /// <br/>  "https://index.docker.io/v1/": {
        /// <br/>    "username": "mobydock",
        /// <br/>    "password": "conta1n3rize14"
        /// <br/>  }
        /// <br/>}
        /// <br/>```
        /// <br/>
        /// <br/>Only the registry domain name (and port if not the default 443) are required. However, for legacy reasons, the Docker Hub registry must be specified with both a `https://` prefix and a `/v1/` suffix even though Docker will prefer to use the v2 registry API.</param>
        /// <param name="platform">Platform in the format os[/arch[/variant]]</param>
        /// <param name="target">Target build stage</param>
        /// <param name="outputs">BuildKit output configuration</param>
        /// <param name="version">Version of the builder backend to use.
        /// <br/>
        /// <br/>- `1` is the first generation classic (deprecated) builder in the Docker daemon (default)
        /// <br/>- `2` is [BuildKit](https://github.com/moby/buildkit)</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ImageBuildAsync(System.IO.Stream inputStream, string dockerfile, string t, string extrahosts, string remote, bool? q, bool? nocache, string cachefrom, string pull, bool? rm, bool? forcerm, int? memory, int? memswap, int? cpushares, string cpusetcpus, int? cpuperiod, int? cpuquota, string buildargs, int? shmsize, bool? squash, string labels, string networkmode, ContentType? content_type, string x_Registry_Config, string platform, string target, string outputs, Version? version)
        {
            return ImageBuildAsync(inputStream, dockerfile, t, extrahosts, remote, q, nocache, cachefrom, pull, rm, forcerm, memory, memswap, cpushares, cpusetcpus, cpuperiod, cpuquota, buildargs, shmsize, squash, labels, networkmode, content_type, x_Registry_Config, platform, target, outputs, version, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Build an image
        /// </summary>
        /// <remarks>
        /// Build an image from a tar archive with a `Dockerfile` in it.
        /// <br/>
        /// <br/>The `Dockerfile` specifies how the image is built from the tar archive. It is typically in the archive's root, but can be at a different path or have a different name by specifying the `dockerfile` parameter. [See the `Dockerfile` reference for more information](https://docs.docker.com/engine/reference/builder/).
        /// <br/>
        /// <br/>The Docker daemon performs a preliminary validation of the `Dockerfile` before starting the build, and returns an error if the syntax is incorrect. After that, each instruction is run one-by-one until the ID of the new image is output.
        /// <br/>
        /// <br/>The build is canceled if the client drops the connection by quitting or being killed.
        /// </remarks>
        /// <param name="inputStream">A tar archive compressed with one of the following algorithms: identity (no compression), gzip, bzip2, xz.</param>
        /// <param name="dockerfile">Path within the build context to the `Dockerfile`. This is ignored if `remote` is specified and points to an external `Dockerfile`.</param>
        /// <param name="t">A name and optional tag to apply to the image in the `name:tag` format. If you omit the tag the default `latest` value is assumed. You can provide several `t` parameters.</param>
        /// <param name="extrahosts">Extra hosts to add to /etc/hosts</param>
        /// <param name="remote">A Git repository URI or HTTP/HTTPS context URI. If the URI points to a single text file, the file’s contents are placed into a file called `Dockerfile` and the image is built from that file. If the URI points to a tarball, the file is downloaded by the daemon and the contents therein used as the context for the build. If the URI points to a tarball and the `dockerfile` parameter is also specified, there must be a file with the corresponding path inside the tarball.</param>
        /// <param name="q">Suppress verbose build output.</param>
        /// <param name="nocache">Do not use the cache when building the image.</param>
        /// <param name="cachefrom">JSON array of images used for build cache resolution.</param>
        /// <param name="pull">Attempt to pull the image even if an older image exists locally.</param>
        /// <param name="rm">Remove intermediate containers after a successful build.</param>
        /// <param name="forcerm">Always remove intermediate containers, even upon failure.</param>
        /// <param name="memory">Set memory limit for build.</param>
        /// <param name="memswap">Total memory (memory + swap). Set as `-1` to disable swap.</param>
        /// <param name="cpushares">CPU shares (relative weight).</param>
        /// <param name="cpusetcpus">CPUs in which to allow execution (e.g., `0-3`, `0,1`).</param>
        /// <param name="cpuperiod">The length of a CPU period in microseconds.</param>
        /// <param name="cpuquota">Microseconds of CPU time that the container can get in a CPU period.</param>
        /// <param name="buildargs">JSON map of string pairs for build-time variables. Users pass these values at build-time. Docker uses the buildargs as the environment context for commands run via the `Dockerfile` RUN instruction, or for variable expansion in other `Dockerfile` instructions. This is not meant for passing secret values.
        /// <br/>
        /// <br/>For example, the build arg `FOO=bar` would become `{"FOO":"bar"}` in JSON. This would result in the query parameter `buildargs={"FOO":"bar"}`. Note that `{"FOO":"bar"}` should be URI component encoded.
        /// <br/>
        /// <br/>[Read more about the buildargs instruction.](https://docs.docker.com/engine/reference/builder/#arg)</param>
        /// <param name="shmsize">Size of `/dev/shm` in bytes. The size must be greater than 0. If omitted the system uses 64MB.</param>
        /// <param name="squash">Squash the resulting images layers into a single layer. *(Experimental release only.)*</param>
        /// <param name="labels">Arbitrary key/value labels to set on the image, as a JSON map of string pairs.</param>
        /// <param name="networkmode">Sets the networking mode for the run commands during build. Supported
        /// <br/>standard values are: `bridge`, `host`, `none`, and `container:&lt;name|id&gt;`.
        /// <br/>Any other value is taken as a custom network's name or ID to which this
        /// <br/>container should connect to.</param>
        /// <param name="x_Registry_Config">This is a base64-encoded JSON object with auth configurations for multiple registries that a build may refer to.
        /// <br/>
        /// <br/>The key is a registry URL, and the value is an auth configuration object, [as described in the authentication section](#section/Authentication). For example:
        /// <br/>
        /// <br/>```
        /// <br/>{
        /// <br/>  "docker.example.com": {
        /// <br/>    "username": "janedoe",
        /// <br/>    "password": "hunter2"
        /// <br/>  },
        /// <br/>  "https://index.docker.io/v1/": {
        /// <br/>    "username": "mobydock",
        /// <br/>    "password": "conta1n3rize14"
        /// <br/>  }
        /// <br/>}
        /// <br/>```
        /// <br/>
        /// <br/>Only the registry domain name (and port if not the default 443) are required. However, for legacy reasons, the Docker Hub registry must be specified with both a `https://` prefix and a `/v1/` suffix even though Docker will prefer to use the v2 registry API.</param>
        /// <param name="platform">Platform in the format os[/arch[/variant]]</param>
        /// <param name="target">Target build stage</param>
        /// <param name="outputs">BuildKit output configuration</param>
        /// <param name="version">Version of the builder backend to use.
        /// <br/>
        /// <br/>- `1` is the first generation classic (deprecated) builder in the Docker daemon (default)
        /// <br/>- `2` is [BuildKit](https://github.com/moby/buildkit)</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ImageBuildAsync(System.IO.Stream inputStream, string dockerfile, string t, string extrahosts, string remote, bool? q, bool? nocache, string cachefrom, string pull, bool? rm, bool? forcerm, int? memory, int? memswap, int? cpushares, string cpusetcpus, int? cpuperiod, int? cpuquota, string buildargs, int? shmsize, bool? squash, string labels, string networkmode, ContentType? content_type, string x_Registry_Config, string platform, string target, string outputs, Version? version, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (content_type != null)
                        request_.Headers.TryAddWithoutValidation("Content-type", ConvertToString(content_type, System.Globalization.CultureInfo.InvariantCulture));

                    if (x_Registry_Config != null)
                        request_.Headers.TryAddWithoutValidation("X-Registry-Config", ConvertToString(x_Registry_Config, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StreamContent(inputStream);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/octet-stream");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "build"
                    urlBuilder_.Append("build");
                    urlBuilder_.Append('?');
                    if (dockerfile != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("dockerfile")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(dockerfile, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (t != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("t")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(t, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (extrahosts != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("extrahosts")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(extrahosts, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (remote != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("remote")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(remote, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (q != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("q")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(q, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (nocache != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("nocache")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(nocache, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cachefrom != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cachefrom")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cachefrom, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (pull != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("pull")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(pull, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (rm != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("rm")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(rm, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (forcerm != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("forcerm")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(forcerm, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (memory != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("memory")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(memory, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (memswap != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("memswap")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(memswap, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cpushares != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cpushares")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cpushares, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cpusetcpus != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cpusetcpus")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cpusetcpus, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cpuperiod != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cpuperiod")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cpuperiod, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cpuquota != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cpuquota")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cpuquota, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (buildargs != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("buildargs")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(buildargs, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (shmsize != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("shmsize")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(shmsize, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (squash != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("squash")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(squash, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (labels != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("labels")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(labels, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (networkmode != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("networkmode")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(networkmode, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (platform != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("platform")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(platform, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (target != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("target")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(target, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (outputs != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("outputs")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(outputs, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (version != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("version")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Bad parameter", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete builder cache
        /// </summary>
        /// <param name="keep_storage">Amount of disk space in bytes to keep for cache</param>
        /// <param name="all">Remove all types of build cache</param>
        /// <param name="filters">A JSON encoded value of the filters (a `map[string][]string`) to
        /// <br/>process on the list of build cache objects.
        /// <br/>
        /// <br/>Available filters:
        /// <br/>
        /// <br/>- `until=&lt;timestamp&gt;` remove cache older than `&lt;timestamp&gt;`. The `&lt;timestamp&gt;` can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. `10m`, `1h30m`) computed relative to the daemon's local time.
        /// <br/>- `id=&lt;id&gt;`
        /// <br/>- `parent=&lt;id&gt;`
        /// <br/>- `type=&lt;string&gt;`
        /// <br/>- `description=&lt;string&gt;`
        /// <br/>- `inuse`
        /// <br/>- `shared`
        /// <br/>- `private`</param>
        /// <returns>No error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<BuildPruneResponse> BuildPruneAsync(long? keep_storage, bool? all, string filters)
        {
            return BuildPruneAsync(keep_storage, all, filters, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete builder cache
        /// </summary>
        /// <param name="keep_storage">Amount of disk space in bytes to keep for cache</param>
        /// <param name="all">Remove all types of build cache</param>
        /// <param name="filters">A JSON encoded value of the filters (a `map[string][]string`) to
        /// <br/>process on the list of build cache objects.
        /// <br/>
        /// <br/>Available filters:
        /// <br/>
        /// <br/>- `until=&lt;timestamp&gt;` remove cache older than `&lt;timestamp&gt;`. The `&lt;timestamp&gt;` can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. `10m`, `1h30m`) computed relative to the daemon's local time.
        /// <br/>- `id=&lt;id&gt;`
        /// <br/>- `parent=&lt;id&gt;`
        /// <br/>- `type=&lt;string&gt;`
        /// <br/>- `description=&lt;string&gt;`
        /// <br/>- `inuse`
        /// <br/>- `shared`
        /// <br/>- `private`</param>
        /// <returns>No error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<BuildPruneResponse> BuildPruneAsync(long? keep_storage, bool? all, string filters, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "build/prune"
                    urlBuilder_.Append("build/prune");
                    urlBuilder_.Append('?');
                    if (keep_storage != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("keep-storage")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(keep_storage, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (all != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("all")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(all, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (filters != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("filters")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(filters, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<BuildPruneResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Create an image
        /// </summary>
        /// <remarks>
        /// Pull or import an image.
        /// </remarks>
        /// <param name="fromImage">Name of the image to pull. The name may include a tag or digest. This parameter may only be used when pulling an image. The pull is cancelled if the HTTP connection is closed.</param>
        /// <param name="fromSrc">Source to import. The value may be a URL from which the image can be retrieved or `-` to read the image from the request body. This parameter may only be used when importing an image.</param>
        /// <param name="repo">Repository name given to an image when it is imported. The repo may include a tag. This parameter may only be used when importing an image.</param>
        /// <param name="tag">Tag or digest. If empty when pulling an image, this causes all tags for the given image to be pulled.</param>
        /// <param name="message">Set commit message for imported image.</param>
        /// <param name="inputImage">Image content if the value `-` has been specified in fromSrc query parameter</param>
        /// <param name="x_Registry_Auth">A base64url-encoded auth configuration.
        /// <br/>
        /// <br/>Refer to the [authentication section](#section/Authentication) for
        /// <br/>details.</param>
        /// <param name="changes">Apply `Dockerfile` instructions to the image that is created,
        /// <br/>for example: `changes=ENV DEBUG=true`.
        /// <br/>Note that `ENV DEBUG=true` should be URI component encoded.
        /// <br/>
        /// <br/>Supported `Dockerfile` instructions:
        /// <br/>`CMD`|`ENTRYPOINT`|`ENV`|`EXPOSE`|`ONBUILD`|`USER`|`VOLUME`|`WORKDIR`</param>
        /// <param name="platform">Platform in the format os[/arch[/variant]].
        /// <br/>
        /// <br/>When used in combination with the `fromImage` option, the daemon checks
        /// <br/>if the given image is present in the local image cache with the given
        /// <br/>OS and Architecture, and otherwise attempts to pull the image. If the
        /// <br/>option is not set, the host's native OS and Architecture are used.
        /// <br/>If the given image does not exist in the local image cache, the daemon
        /// <br/>attempts to pull the image with the host's native OS and Architecture.
        /// <br/>If the given image does exists in the local image cache, but its OS or
        /// <br/>architecture does not match, a warning is produced.
        /// <br/>
        /// <br/>When used with the `fromSrc` option to import an image from an archive,
        /// <br/>this option sets the platform information for the imported image. If
        /// <br/>the option is not set, the host's native OS and Architecture are used
        /// <br/>for the imported image.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ImageCreateAsync(string fromImage, string fromSrc, string repo, string tag, string message, string inputImage, string x_Registry_Auth, System.Collections.Generic.IEnumerable<string> changes, string platform)
        {
            return ImageCreateAsync(fromImage, fromSrc, repo, tag, message, inputImage, x_Registry_Auth, changes, platform, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create an image
        /// </summary>
        /// <remarks>
        /// Pull or import an image.
        /// </remarks>
        /// <param name="fromImage">Name of the image to pull. The name may include a tag or digest. This parameter may only be used when pulling an image. The pull is cancelled if the HTTP connection is closed.</param>
        /// <param name="fromSrc">Source to import. The value may be a URL from which the image can be retrieved or `-` to read the image from the request body. This parameter may only be used when importing an image.</param>
        /// <param name="repo">Repository name given to an image when it is imported. The repo may include a tag. This parameter may only be used when importing an image.</param>
        /// <param name="tag">Tag or digest. If empty when pulling an image, this causes all tags for the given image to be pulled.</param>
        /// <param name="message">Set commit message for imported image.</param>
        /// <param name="inputImage">Image content if the value `-` has been specified in fromSrc query parameter</param>
        /// <param name="x_Registry_Auth">A base64url-encoded auth configuration.
        /// <br/>
        /// <br/>Refer to the [authentication section](#section/Authentication) for
        /// <br/>details.</param>
        /// <param name="changes">Apply `Dockerfile` instructions to the image that is created,
        /// <br/>for example: `changes=ENV DEBUG=true`.
        /// <br/>Note that `ENV DEBUG=true` should be URI component encoded.
        /// <br/>
        /// <br/>Supported `Dockerfile` instructions:
        /// <br/>`CMD`|`ENTRYPOINT`|`ENV`|`EXPOSE`|`ONBUILD`|`USER`|`VOLUME`|`WORKDIR`</param>
        /// <param name="platform">Platform in the format os[/arch[/variant]].
        /// <br/>
        /// <br/>When used in combination with the `fromImage` option, the daemon checks
        /// <br/>if the given image is present in the local image cache with the given
        /// <br/>OS and Architecture, and otherwise attempts to pull the image. If the
        /// <br/>option is not set, the host's native OS and Architecture are used.
        /// <br/>If the given image does not exist in the local image cache, the daemon
        /// <br/>attempts to pull the image with the host's native OS and Architecture.
        /// <br/>If the given image does exists in the local image cache, but its OS or
        /// <br/>architecture does not match, a warning is produced.
        /// <br/>
        /// <br/>When used with the `fromSrc` option to import an image from an archive,
        /// <br/>this option sets the platform information for the imported image. If
        /// <br/>the option is not set, the host's native OS and Architecture are used
        /// <br/>for the imported image.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ImageCreateAsync(string fromImage, string fromSrc, string repo, string tag, string message, string inputImage, string x_Registry_Auth, System.Collections.Generic.IEnumerable<string> changes, string platform, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (x_Registry_Auth != null)
                        request_.Headers.TryAddWithoutValidation("X-Registry-Auth", ConvertToString(x_Registry_Auth, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(inputImage);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("text/plain");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "images/create"
                    urlBuilder_.Append("images/create");
                    urlBuilder_.Append('?');
                    if (fromImage != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("fromImage")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(fromImage, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (fromSrc != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("fromSrc")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(fromSrc, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (repo != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("repo")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(repo, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (tag != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("tag")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(tag, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (message != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("message")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(message, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (changes != null)
                    {
                        foreach (var item_ in changes) { urlBuilder_.Append(System.Uri.EscapeDataString("changes")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (platform != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("platform")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(platform, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("repository does not exist or no read access", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Inspect an image
        /// </summary>
        /// <remarks>
        /// Return low-level information about an image.
        /// </remarks>
        /// <param name="name">Image name or id</param>
        /// <returns>No error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ImageInspect> ImageInspectAsync(string name)
        {
            return ImageInspectAsync(name, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Inspect an image
        /// </summary>
        /// <remarks>
        /// Return low-level information about an image.
        /// </remarks>
        /// <param name="name">Image name or id</param>
        /// <returns>No error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ImageInspect> ImageInspectAsync(string name, System.Threading.CancellationToken cancellationToken)
        {
            if (name == null)
                throw new System.ArgumentNullException("name");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "images/{name}/json"
                    urlBuilder_.Append("images/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/json");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ImageInspect>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("No such image", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the history of an image
        /// </summary>
        /// <remarks>
        /// Return parent layers of an image.
        /// </remarks>
        /// <param name="name">Image name or ID</param>
        /// <returns>List of image layers</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<HistoryResponseItem>> ImageHistoryAsync(string name)
        {
            return ImageHistoryAsync(name, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the history of an image
        /// </summary>
        /// <remarks>
        /// Return parent layers of an image.
        /// </remarks>
        /// <param name="name">Image name or ID</param>
        /// <returns>List of image layers</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<HistoryResponseItem>> ImageHistoryAsync(string name, System.Threading.CancellationToken cancellationToken)
        {
            if (name == null)
                throw new System.ArgumentNullException("name");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "images/{name}/history"
                    urlBuilder_.Append("images/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/history");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<HistoryResponseItem>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("No such image", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Push an image
        /// </summary>
        /// <remarks>
        /// Push an image to a registry.
        /// <br/>
        /// <br/>If you wish to push an image on to a private registry, that image must
        /// <br/>already have a tag which references the registry. For example,
        /// <br/>`registry.example.com/myimage:latest`.
        /// <br/>
        /// <br/>The push is cancelled if the HTTP connection is closed.
        /// </remarks>
        /// <param name="name">Image name or ID.</param>
        /// <param name="tag">The tag to associate with the image on the registry.</param>
        /// <param name="x_Registry_Auth">A base64url-encoded auth configuration.
        /// <br/>
        /// <br/>Refer to the [authentication section](#section/Authentication) for
        /// <br/>details.</param>
        /// <param name="platform">Select a platform-specific manifest to be pushed. OCI platform (JSON encoded)</param>
        /// <returns>No error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ImagePushAsync(string name, string tag, string x_Registry_Auth, string platform)
        {
            return ImagePushAsync(name, tag, x_Registry_Auth, platform, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Push an image
        /// </summary>
        /// <remarks>
        /// Push an image to a registry.
        /// <br/>
        /// <br/>If you wish to push an image on to a private registry, that image must
        /// <br/>already have a tag which references the registry. For example,
        /// <br/>`registry.example.com/myimage:latest`.
        /// <br/>
        /// <br/>The push is cancelled if the HTTP connection is closed.
        /// </remarks>
        /// <param name="name">Image name or ID.</param>
        /// <param name="tag">The tag to associate with the image on the registry.</param>
        /// <param name="x_Registry_Auth">A base64url-encoded auth configuration.
        /// <br/>
        /// <br/>Refer to the [authentication section](#section/Authentication) for
        /// <br/>details.</param>
        /// <param name="platform">Select a platform-specific manifest to be pushed. OCI platform (JSON encoded)</param>
        /// <returns>No error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ImagePushAsync(string name, string tag, string x_Registry_Auth, string platform, System.Threading.CancellationToken cancellationToken)
        {
            if (name == null)
                throw new System.ArgumentNullException("name");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (x_Registry_Auth == null)
                        throw new System.ArgumentNullException("x_Registry_Auth");
                    request_.Headers.TryAddWithoutValidation("X-Registry-Auth", ConvertToString(x_Registry_Auth, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "images/{name}/push"
                    urlBuilder_.Append("images/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/push");
                    urlBuilder_.Append('?');
                    if (tag != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("tag")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(tag, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (platform != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("platform")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(platform, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("No such image", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Tag an image
        /// </summary>
        /// <remarks>
        /// Tag an image so that it becomes part of a repository.
        /// </remarks>
        /// <param name="name">Image name or ID to tag.</param>
        /// <param name="repo">The repository to tag in. For example, `someuser/someimage`.</param>
        /// <param name="tag">The name of the new tag.</param>
        /// <returns>No error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ImageTagAsync(string name, string repo, string tag)
        {
            return ImageTagAsync(name, repo, tag, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Tag an image
        /// </summary>
        /// <remarks>
        /// Tag an image so that it becomes part of a repository.
        /// </remarks>
        /// <param name="name">Image name or ID to tag.</param>
        /// <param name="repo">The repository to tag in. For example, `someuser/someimage`.</param>
        /// <param name="tag">The name of the new tag.</param>
        /// <returns>No error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ImageTagAsync(string name, string repo, string tag, System.Threading.CancellationToken cancellationToken)
        {
            if (name == null)
                throw new System.ArgumentNullException("name");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "images/{name}/tag"
                    urlBuilder_.Append("images/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/tag");
                    urlBuilder_.Append('?');
                    if (repo != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("repo")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(repo, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (tag != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("tag")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(tag, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 201)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Bad parameter", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("No such image", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Conflict", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove an image
        /// </summary>
        /// <remarks>
        /// Remove an image, along with any untagged parent images that were
        /// <br/>referenced by that image.
        /// <br/>
        /// <br/>Images can't be removed if they have descendant images, are being
        /// <br/>used by a running container or are being used by a build.
        /// </remarks>
        /// <param name="name">Image name or ID</param>
        /// <param name="force">Remove the image even if it is being used by stopped containers or has other tags</param>
        /// <param name="noprune">Do not delete untagged parent images</param>
        /// <returns>The image was deleted successfully</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ImageDeleteResponseItem>> ImageDeleteAsync(string name, bool? force, bool? noprune)
        {
            return ImageDeleteAsync(name, force, noprune, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove an image
        /// </summary>
        /// <remarks>
        /// Remove an image, along with any untagged parent images that were
        /// <br/>referenced by that image.
        /// <br/>
        /// <br/>Images can't be removed if they have descendant images, are being
        /// <br/>used by a running container or are being used by a build.
        /// </remarks>
        /// <param name="name">Image name or ID</param>
        /// <param name="force">Remove the image even if it is being used by stopped containers or has other tags</param>
        /// <param name="noprune">Do not delete untagged parent images</param>
        /// <returns>The image was deleted successfully</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ImageDeleteResponseItem>> ImageDeleteAsync(string name, bool? force, bool? noprune, System.Threading.CancellationToken cancellationToken)
        {
            if (name == null)
                throw new System.ArgumentNullException("name");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "images/{name}"
                    urlBuilder_.Append("images/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('?');
                    if (force != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("force")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(force, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (noprune != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("noprune")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(noprune, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<ImageDeleteResponseItem>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("No such image", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Conflict", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Search images
        /// </summary>
        /// <remarks>
        /// Search for an image on Docker Hub.
        /// </remarks>
        /// <param name="term">Term to search</param>
        /// <param name="limit">Maximum number of results to return</param>
        /// <param name="filters">A JSON encoded value of the filters (a `map[string][]string`) to process on the images list. Available filters:
        /// <br/>
        /// <br/>- `is-official=(true|false)`
        /// <br/>- `stars=&lt;number&gt;` Matches images that has at least 'number' stars.</param>
        /// <returns>No error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ImageSearchResponseItem>> ImageSearchAsync(string term, int? limit, string filters)
        {
            return ImageSearchAsync(term, limit, filters, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Search images
        /// </summary>
        /// <remarks>
        /// Search for an image on Docker Hub.
        /// </remarks>
        /// <param name="term">Term to search</param>
        /// <param name="limit">Maximum number of results to return</param>
        /// <param name="filters">A JSON encoded value of the filters (a `map[string][]string`) to process on the images list. Available filters:
        /// <br/>
        /// <br/>- `is-official=(true|false)`
        /// <br/>- `stars=&lt;number&gt;` Matches images that has at least 'number' stars.</param>
        /// <returns>No error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ImageSearchResponseItem>> ImageSearchAsync(string term, int? limit, string filters, System.Threading.CancellationToken cancellationToken)
        {
            if (term == null)
                throw new System.ArgumentNullException("term");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "images/search"
                    urlBuilder_.Append("images/search");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("term")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(term, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (filters != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("filters")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(filters, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<ImageSearchResponseItem>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete unused images
        /// </summary>
        /// <param name="filters">Filters to process on the prune list, encoded as JSON (a `map[string][]string`). Available filters:
        /// <br/>
        /// <br/>- `dangling=&lt;boolean&gt;` When set to `true` (or `1`), prune only
        /// <br/>   unused *and* untagged images. When set to `false`
        /// <br/>   (or `0`), all unused images are pruned.
        /// <br/>- `until=&lt;string&gt;` Prune images created before this timestamp. The `&lt;timestamp&gt;` can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. `10m`, `1h30m`) computed relative to the daemon machine’s time.
        /// <br/>- `label` (`label=&lt;key&gt;`, `label=&lt;key&gt;=&lt;value&gt;`, `label!=&lt;key&gt;`, or `label!=&lt;key&gt;=&lt;value&gt;`) Prune images with (or without, in case `label!=...` is used) the specified labels.</param>
        /// <returns>No error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ImagePruneResponse> ImagePruneAsync(string filters)
        {
            return ImagePruneAsync(filters, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete unused images
        /// </summary>
        /// <param name="filters">Filters to process on the prune list, encoded as JSON (a `map[string][]string`). Available filters:
        /// <br/>
        /// <br/>- `dangling=&lt;boolean&gt;` When set to `true` (or `1`), prune only
        /// <br/>   unused *and* untagged images. When set to `false`
        /// <br/>   (or `0`), all unused images are pruned.
        /// <br/>- `until=&lt;string&gt;` Prune images created before this timestamp. The `&lt;timestamp&gt;` can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. `10m`, `1h30m`) computed relative to the daemon machine’s time.
        /// <br/>- `label` (`label=&lt;key&gt;`, `label=&lt;key&gt;=&lt;value&gt;`, `label!=&lt;key&gt;`, or `label!=&lt;key&gt;=&lt;value&gt;`) Prune images with (or without, in case `label!=...` is used) the specified labels.</param>
        /// <returns>No error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ImagePruneResponse> ImagePruneAsync(string filters, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "images/prune"
                    urlBuilder_.Append("images/prune");
                    urlBuilder_.Append('?');
                    if (filters != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("filters")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(filters, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ImagePruneResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Check auth configuration
        /// </summary>
        /// <remarks>
        /// Validate credentials for a registry and, if available, get an identity
        /// <br/>token for accessing the registry without password.
        /// </remarks>
        /// <param name="authConfig">Authentication to check</param>
        /// <returns>An identity token was generated successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response> SystemAuthAsync(AuthConfig authConfig)
        {
            return SystemAuthAsync(authConfig, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Check auth configuration
        /// </summary>
        /// <remarks>
        /// Validate credentials for a registry and, if available, get an identity
        /// <br/>token for accessing the registry without password.
        /// </remarks>
        /// <param name="authConfig">Authentication to check</param>
        /// <returns>An identity token was generated successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response> SystemAuthAsync(AuthConfig authConfig, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(authConfig, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "auth"
                    urlBuilder_.Append("auth");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 204)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("No error", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Auth error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get system information
        /// </summary>
        /// <returns>No error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SystemInfo> SystemInfoAsync()
        {
            return SystemInfoAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get system information
        /// </summary>
        /// <returns>No error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SystemInfo> SystemInfoAsync(System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "info"
                    urlBuilder_.Append("info");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SystemInfo>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get version
        /// </summary>
        /// <remarks>
        /// Returns the version of Docker that is running and various information about the system that Docker is running on.
        /// </remarks>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SystemVersion> SystemVersionAsync()
        {
            return SystemVersionAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get version
        /// </summary>
        /// <remarks>
        /// Returns the version of Docker that is running and various information about the system that Docker is running on.
        /// </remarks>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SystemVersion> SystemVersionAsync(System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "version"
                    urlBuilder_.Append("version");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SystemVersion>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Ping
        /// </summary>
        /// <remarks>
        /// This is a dummy endpoint you can use to test if the server is accessible.
        /// </remarks>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<string> SystemPingAsync()
        {
            return SystemPingAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Ping
        /// </summary>
        /// <remarks>
        /// This is a dummy endpoint you can use to test if the server is accessible.
        /// </remarks>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<string> SystemPingAsync(System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("text/plain"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "_ping"
                    urlBuilder_.Append("_ping");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<string>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Ping
        /// </summary>
        /// <remarks>
        /// This is a dummy endpoint you can use to test if the server is accessible.
        /// </remarks>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<string> SystemPingHeadAsync()
        {
            return SystemPingHeadAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Ping
        /// </summary>
        /// <remarks>
        /// This is a dummy endpoint you can use to test if the server is accessible.
        /// </remarks>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<string> SystemPingHeadAsync(System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("HEAD");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("text/plain"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "_ping"
                    urlBuilder_.Append("_ping");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<string>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Create a new image from a container
        /// </summary>
        /// <param name="containerConfig">The container configuration</param>
        /// <param name="container">The ID or name of the container to commit</param>
        /// <param name="repo">Repository name for the created image</param>
        /// <param name="tag">Tag name for the create image</param>
        /// <param name="comment">Commit message</param>
        /// <param name="author">Author of the image (e.g., `John Hannibal Smith &lt;hannibal@a-team.com&gt;`)</param>
        /// <param name="pause">Whether to pause the container before committing</param>
        /// <param name="changes">`Dockerfile` instructions to apply while committing</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<IdResponse> ImageCommitAsync(ContainerConfig containerConfig, string container, string repo, string tag, string comment, string author, bool? pause, string changes)
        {
            return ImageCommitAsync(containerConfig, container, repo, tag, comment, author, pause, changes, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create a new image from a container
        /// </summary>
        /// <param name="containerConfig">The container configuration</param>
        /// <param name="container">The ID or name of the container to commit</param>
        /// <param name="repo">Repository name for the created image</param>
        /// <param name="tag">Tag name for the create image</param>
        /// <param name="comment">Commit message</param>
        /// <param name="author">Author of the image (e.g., `John Hannibal Smith &lt;hannibal@a-team.com&gt;`)</param>
        /// <param name="pause">Whether to pause the container before committing</param>
        /// <param name="changes">`Dockerfile` instructions to apply while committing</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<IdResponse> ImageCommitAsync(ContainerConfig containerConfig, string container, string repo, string tag, string comment, string author, bool? pause, string changes, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(containerConfig, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "commit"
                    urlBuilder_.Append("commit");
                    urlBuilder_.Append('?');
                    if (container != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("container")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(container, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (repo != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("repo")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(repo, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (tag != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("tag")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(tag, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (comment != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("comment")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(comment, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (author != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("author")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(author, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (pause != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("pause")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(pause, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (changes != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("changes")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(changes, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 201)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<IdResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("no such container", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Monitor events
        /// </summary>
        /// <remarks>
        /// Stream real-time events from the server.
        /// <br/>
        /// <br/>Various objects within Docker report events when something happens to them.
        /// <br/>
        /// <br/>Containers report these events: `attach`, `commit`, `copy`, `create`, `destroy`, `detach`, `die`, `exec_create`, `exec_detach`, `exec_start`, `exec_die`, `export`, `health_status`, `kill`, `oom`, `pause`, `rename`, `resize`, `restart`, `start`, `stop`, `top`, `unpause`, `update`, and `prune`
        /// <br/>
        /// <br/>Images report these events: `create`, `delete`, `import`, `load`, `pull`, `push`, `save`, `tag`, `untag`, and `prune`
        /// <br/>
        /// <br/>Volumes report these events: `create`, `mount`, `unmount`, `destroy`, and `prune`
        /// <br/>
        /// <br/>Networks report these events: `create`, `connect`, `disconnect`, `destroy`, `update`, `remove`, and `prune`
        /// <br/>
        /// <br/>The Docker daemon reports these events: `reload`
        /// <br/>
        /// <br/>Services report these events: `create`, `update`, and `remove`
        /// <br/>
        /// <br/>Nodes report these events: `create`, `update`, and `remove`
        /// <br/>
        /// <br/>Secrets report these events: `create`, `update`, and `remove`
        /// <br/>
        /// <br/>Configs report these events: `create`, `update`, and `remove`
        /// <br/>
        /// <br/>The Builder reports `prune` events
        /// </remarks>
        /// <param name="since">Show events created since this timestamp then stream new events.</param>
        /// <param name="until">Show events created until this timestamp then stop streaming.</param>
        /// <param name="filters">A JSON encoded value of filters (a `map[string][]string`) to process on the event list. Available filters:
        /// <br/>
        /// <br/>- `config=&lt;string&gt;` config name or ID
        /// <br/>- `container=&lt;string&gt;` container name or ID
        /// <br/>- `daemon=&lt;string&gt;` daemon name or ID
        /// <br/>- `event=&lt;string&gt;` event type
        /// <br/>- `image=&lt;string&gt;` image name or ID
        /// <br/>- `label=&lt;string&gt;` image or container label
        /// <br/>- `network=&lt;string&gt;` network name or ID
        /// <br/>- `node=&lt;string&gt;` node ID
        /// <br/>- `plugin`=&lt;string&gt; plugin name or ID
        /// <br/>- `scope`=&lt;string&gt; local or swarm
        /// <br/>- `secret=&lt;string&gt;` secret name or ID
        /// <br/>- `service=&lt;string&gt;` service name or ID
        /// <br/>- `type=&lt;string&gt;` object to filter by, one of `container`, `image`, `volume`, `network`, `daemon`, `plugin`, `node`, `service`, `secret` or `config`
        /// <br/>- `volume=&lt;string&gt;` volume name</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<EventMessage> SystemEventsAsync(string since, string until, string filters)
        {
            return SystemEventsAsync(since, until, filters, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Monitor events
        /// </summary>
        /// <remarks>
        /// Stream real-time events from the server.
        /// <br/>
        /// <br/>Various objects within Docker report events when something happens to them.
        /// <br/>
        /// <br/>Containers report these events: `attach`, `commit`, `copy`, `create`, `destroy`, `detach`, `die`, `exec_create`, `exec_detach`, `exec_start`, `exec_die`, `export`, `health_status`, `kill`, `oom`, `pause`, `rename`, `resize`, `restart`, `start`, `stop`, `top`, `unpause`, `update`, and `prune`
        /// <br/>
        /// <br/>Images report these events: `create`, `delete`, `import`, `load`, `pull`, `push`, `save`, `tag`, `untag`, and `prune`
        /// <br/>
        /// <br/>Volumes report these events: `create`, `mount`, `unmount`, `destroy`, and `prune`
        /// <br/>
        /// <br/>Networks report these events: `create`, `connect`, `disconnect`, `destroy`, `update`, `remove`, and `prune`
        /// <br/>
        /// <br/>The Docker daemon reports these events: `reload`
        /// <br/>
        /// <br/>Services report these events: `create`, `update`, and `remove`
        /// <br/>
        /// <br/>Nodes report these events: `create`, `update`, and `remove`
        /// <br/>
        /// <br/>Secrets report these events: `create`, `update`, and `remove`
        /// <br/>
        /// <br/>Configs report these events: `create`, `update`, and `remove`
        /// <br/>
        /// <br/>The Builder reports `prune` events
        /// </remarks>
        /// <param name="since">Show events created since this timestamp then stream new events.</param>
        /// <param name="until">Show events created until this timestamp then stop streaming.</param>
        /// <param name="filters">A JSON encoded value of filters (a `map[string][]string`) to process on the event list. Available filters:
        /// <br/>
        /// <br/>- `config=&lt;string&gt;` config name or ID
        /// <br/>- `container=&lt;string&gt;` container name or ID
        /// <br/>- `daemon=&lt;string&gt;` daemon name or ID
        /// <br/>- `event=&lt;string&gt;` event type
        /// <br/>- `image=&lt;string&gt;` image name or ID
        /// <br/>- `label=&lt;string&gt;` image or container label
        /// <br/>- `network=&lt;string&gt;` network name or ID
        /// <br/>- `node=&lt;string&gt;` node ID
        /// <br/>- `plugin`=&lt;string&gt; plugin name or ID
        /// <br/>- `scope`=&lt;string&gt; local or swarm
        /// <br/>- `secret=&lt;string&gt;` secret name or ID
        /// <br/>- `service=&lt;string&gt;` service name or ID
        /// <br/>- `type=&lt;string&gt;` object to filter by, one of `container`, `image`, `volume`, `network`, `daemon`, `plugin`, `node`, `service`, `secret` or `config`
        /// <br/>- `volume=&lt;string&gt;` volume name</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<EventMessage> SystemEventsAsync(string since, string until, string filters, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "events"
                    urlBuilder_.Append("events");
                    urlBuilder_.Append('?');
                    if (since != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("since")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(since, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (until != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("until")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(until, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (filters != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("filters")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(filters, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<EventMessage>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("bad parameter", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get data usage information
        /// </summary>
        /// <param name="type">Object types, for which to compute and return data.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SystemDataUsageResponse> SystemDataUsageAsync(System.Collections.Generic.IEnumerable<Anonymous> type)
        {
            return SystemDataUsageAsync(type, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get data usage information
        /// </summary>
        /// <param name="type">Object types, for which to compute and return data.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SystemDataUsageResponse> SystemDataUsageAsync(System.Collections.Generic.IEnumerable<Anonymous> type, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "system/df"
                    urlBuilder_.Append("system/df");
                    urlBuilder_.Append('?');
                    if (type != null)
                    {
                        foreach (var item_ in type) { urlBuilder_.Append(System.Uri.EscapeDataString("type")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SystemDataUsageResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Export an image
        /// </summary>
        /// <remarks>
        /// Get a tarball containing all images and metadata for a repository.
        /// <br/>
        /// <br/>If `name` is a specific name and tag (e.g. `ubuntu:latest`), then only that image (and its parents) are returned. If `name` is an image ID, similarly only that image (and its parents) are returned, but with the exclusion of the `repositories` file in the tarball, as there were no image names referenced.
        /// <br/>
        /// <br/>### Image tarball format
        /// <br/>
        /// <br/>An image tarball contains one directory per image layer (named using its long ID), each containing these files:
        /// <br/>
        /// <br/>- `VERSION`: currently `1.0` - the file format version
        /// <br/>- `json`: detailed layer information, similar to `docker inspect layer_id`
        /// <br/>- `layer.tar`: A tarfile containing the filesystem changes in this layer
        /// <br/>
        /// <br/>The `layer.tar` file contains `aufs` style `.wh..wh.aufs` files and directories for storing attribute changes and deletions.
        /// <br/>
        /// <br/>If the tarball defines a repository, the tarball should also include a `repositories` file at the root that contains a list of repository and tag names mapped to layer IDs.
        /// <br/>
        /// <br/>```json
        /// <br/>{
        /// <br/>  "hello-world": {
        /// <br/>    "latest": "565a9d68a73f6706862bfe8409a7f659776d4d60a8d096eb4a3cbce6999cc2a1"
        /// <br/>  }
        /// <br/>}
        /// <br/>```
        /// </remarks>
        /// <param name="name">Image name or ID</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<FileResponse> ImageGetAsync(string name)
        {
            return ImageGetAsync(name, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Export an image
        /// </summary>
        /// <remarks>
        /// Get a tarball containing all images and metadata for a repository.
        /// <br/>
        /// <br/>If `name` is a specific name and tag (e.g. `ubuntu:latest`), then only that image (and its parents) are returned. If `name` is an image ID, similarly only that image (and its parents) are returned, but with the exclusion of the `repositories` file in the tarball, as there were no image names referenced.
        /// <br/>
        /// <br/>### Image tarball format
        /// <br/>
        /// <br/>An image tarball contains one directory per image layer (named using its long ID), each containing these files:
        /// <br/>
        /// <br/>- `VERSION`: currently `1.0` - the file format version
        /// <br/>- `json`: detailed layer information, similar to `docker inspect layer_id`
        /// <br/>- `layer.tar`: A tarfile containing the filesystem changes in this layer
        /// <br/>
        /// <br/>The `layer.tar` file contains `aufs` style `.wh..wh.aufs` files and directories for storing attribute changes and deletions.
        /// <br/>
        /// <br/>If the tarball defines a repository, the tarball should also include a `repositories` file at the root that contains a list of repository and tag names mapped to layer IDs.
        /// <br/>
        /// <br/>```json
        /// <br/>{
        /// <br/>  "hello-world": {
        /// <br/>    "latest": "565a9d68a73f6706862bfe8409a7f659776d4d60a8d096eb4a3cbce6999cc2a1"
        /// <br/>  }
        /// <br/>}
        /// <br/>```
        /// </remarks>
        /// <param name="name">Image name or ID</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<FileResponse> ImageGetAsync(string name, System.Threading.CancellationToken cancellationToken)
        {
            if (name == null)
                throw new System.ArgumentNullException("name");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/x-tar"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "images/{name}/get"
                    urlBuilder_.Append("images/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/get");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200 || status_ == 206)
                        {
                            var responseStream_ = response_.Content == null ? System.IO.Stream.Null : await response_.Content.ReadAsStreamAsync().ConfigureAwait(false);
                            var fileResponse_ = new FileResponse(status_, headers_, responseStream_, null, response_);
                            disposeClient_ = false; disposeResponse_ = false; // response and client are disposed by FileResponse
                            return fileResponse_;
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Export several images
        /// </summary>
        /// <remarks>
        /// Get a tarball containing all images and metadata for several image
        /// <br/>repositories.
        /// <br/>
        /// <br/>For each value of the `names` parameter: if it is a specific name and
        /// <br/>tag (e.g. `ubuntu:latest`), then only that image (and its parents) are
        /// <br/>returned; if it is an image ID, similarly only that image (and its parents)
        /// <br/>are returned and there would be no names referenced in the 'repositories'
        /// <br/>file for this image ID.
        /// <br/>
        /// <br/>For details on the format, see the [export image endpoint](#operation/ImageGet).
        /// </remarks>
        /// <param name="names">Image names to filter by</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<FileResponse> ImageGetAllAsync(System.Collections.Generic.IEnumerable<string> names)
        {
            return ImageGetAllAsync(names, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Export several images
        /// </summary>
        /// <remarks>
        /// Get a tarball containing all images and metadata for several image
        /// <br/>repositories.
        /// <br/>
        /// <br/>For each value of the `names` parameter: if it is a specific name and
        /// <br/>tag (e.g. `ubuntu:latest`), then only that image (and its parents) are
        /// <br/>returned; if it is an image ID, similarly only that image (and its parents)
        /// <br/>are returned and there would be no names referenced in the 'repositories'
        /// <br/>file for this image ID.
        /// <br/>
        /// <br/>For details on the format, see the [export image endpoint](#operation/ImageGet).
        /// </remarks>
        /// <param name="names">Image names to filter by</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<FileResponse> ImageGetAllAsync(System.Collections.Generic.IEnumerable<string> names, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/x-tar"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "images/get"
                    urlBuilder_.Append("images/get");
                    urlBuilder_.Append('?');
                    if (names != null)
                    {
                        foreach (var item_ in names) { urlBuilder_.Append(System.Uri.EscapeDataString("names")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200 || status_ == 206)
                        {
                            var responseStream_ = response_.Content == null ? System.IO.Stream.Null : await response_.Content.ReadAsStreamAsync().ConfigureAwait(false);
                            var fileResponse_ = new FileResponse(status_, headers_, responseStream_, null, response_);
                            disposeClient_ = false; disposeResponse_ = false; // response and client are disposed by FileResponse
                            return fileResponse_;
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Import images
        /// </summary>
        /// <remarks>
        /// Load a set of images and tags into a repository.
        /// <br/>
        /// <br/>For details on the format, see the [export image endpoint](#operation/ImageGet).
        /// </remarks>
        /// <param name="imagesTarball">Tar archive containing images</param>
        /// <param name="quiet">Suppress progress details during load.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ImageLoadAsync(System.IO.Stream imagesTarball, bool? quiet)
        {
            return ImageLoadAsync(imagesTarball, quiet, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Import images
        /// </summary>
        /// <remarks>
        /// Load a set of images and tags into a repository.
        /// <br/>
        /// <br/>For details on the format, see the [export image endpoint](#operation/ImageGet).
        /// </remarks>
        /// <param name="imagesTarball">Tar archive containing images</param>
        /// <param name="quiet">Suppress progress details during load.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ImageLoadAsync(System.IO.Stream imagesTarball, bool? quiet, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StreamContent(imagesTarball);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-tar");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "images/load"
                    urlBuilder_.Append("images/load");
                    urlBuilder_.Append('?');
                    if (quiet != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("quiet")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(quiet, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Create an exec instance
        /// </summary>
        /// <remarks>
        /// Run a command inside a running container.
        /// </remarks>
        /// <param name="execConfig">Exec configuration</param>
        /// <param name="id">ID or name of container</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<IdResponse> ContainerExecAsync(ExecConfig execConfig, string id)
        {
            return ContainerExecAsync(execConfig, id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create an exec instance
        /// </summary>
        /// <remarks>
        /// Run a command inside a running container.
        /// </remarks>
        /// <param name="execConfig">Exec configuration</param>
        /// <param name="id">ID or name of container</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<IdResponse> ContainerExecAsync(ExecConfig execConfig, string id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            if (execConfig == null)
                throw new System.ArgumentNullException("execConfig");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(execConfig, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "containers/{id}/exec"
                    urlBuilder_.Append("containers/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/exec");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 201)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<IdResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("no such container", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("container is paused", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Start an exec instance
        /// </summary>
        /// <remarks>
        /// Starts a previously set up exec instance. If detach is true, this endpoint
        /// <br/>returns immediately after starting the command. Otherwise, it sets up an
        /// <br/>interactive session with the command.
        /// </remarks>
        /// <param name="id">Exec instance ID</param>
        /// <returns>No error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<FileResponse> ExecStartAsync(ExecStartConfig execStartConfig, string id)
        {
            return ExecStartAsync(execStartConfig, id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Start an exec instance
        /// </summary>
        /// <remarks>
        /// Starts a previously set up exec instance. If detach is true, this endpoint
        /// <br/>returns immediately after starting the command. Otherwise, it sets up an
        /// <br/>interactive session with the command.
        /// </remarks>
        /// <param name="id">Exec instance ID</param>
        /// <returns>No error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<FileResponse> ExecStartAsync(ExecStartConfig execStartConfig, string id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(execStartConfig, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/vnd.docker.raw-stream"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "exec/{id}/start"
                    urlBuilder_.Append("exec/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/start");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200 || status_ == 206)
                        {
                            return default(FileResponse);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("No such exec instance", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Container is stopped or paused", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Resize an exec instance
        /// </summary>
        /// <remarks>
        /// Resize the TTY session used by an exec instance. This endpoint only works
        /// <br/>if `tty` was specified as part of creating and starting the exec instance.
        /// </remarks>
        /// <param name="id">Exec instance ID</param>
        /// <param name="h">Height of the TTY session in characters</param>
        /// <param name="w">Width of the TTY session in characters</param>
        /// <returns>No error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ExecResizeAsync(string id, int? h, int? w)
        {
            return ExecResizeAsync(id, h, w, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Resize an exec instance
        /// </summary>
        /// <remarks>
        /// Resize the TTY session used by an exec instance. This endpoint only works
        /// <br/>if `tty` was specified as part of creating and starting the exec instance.
        /// </remarks>
        /// <param name="id">Exec instance ID</param>
        /// <param name="h">Height of the TTY session in characters</param>
        /// <param name="w">Width of the TTY session in characters</param>
        /// <returns>No error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ExecResizeAsync(string id, int? h, int? w, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "exec/{id}/resize"
                    urlBuilder_.Append("exec/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/resize");
                    urlBuilder_.Append('?');
                    if (h != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("h")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(h, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (w != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("w")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(w, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("bad parameter", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("No such exec instance", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Inspect an exec instance
        /// </summary>
        /// <remarks>
        /// Return low-level information about an exec instance.
        /// </remarks>
        /// <param name="id">Exec instance ID</param>
        /// <returns>No error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ExecInspectResponse> ExecInspectAsync(string id)
        {
            return ExecInspectAsync(id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Inspect an exec instance
        /// </summary>
        /// <remarks>
        /// Return low-level information about an exec instance.
        /// </remarks>
        /// <param name="id">Exec instance ID</param>
        /// <returns>No error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ExecInspectResponse> ExecInspectAsync(string id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "exec/{id}/json"
                    urlBuilder_.Append("exec/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/json");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExecInspectResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("No such exec instance", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// List volumes
        /// </summary>
        /// <param name="filters">JSON encoded value of the filters (a `map[string][]string`) to
        /// <br/>process on the volumes list. Available filters:
        /// <br/>
        /// <br/>- `dangling=&lt;boolean&gt;` When set to `true` (or `1`), returns all
        /// <br/>   volumes that are not in use by a container. When set to `false`
        /// <br/>   (or `0`), only volumes that are in use by one or more
        /// <br/>   containers are returned.
        /// <br/>- `driver=&lt;volume-driver-name&gt;` Matches volumes based on their driver.
        /// <br/>- `label=&lt;key&gt;` or `label=&lt;key&gt;:&lt;value&gt;` Matches volumes based on
        /// <br/>   the presence of a `label` alone or a `label` and a value.
        /// <br/>- `name=&lt;volume-name&gt;` Matches all or part of a volume name.</param>
        /// <returns>Summary volume data that matches the query</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<VolumeListResponse> VolumeListAsync(string filters)
        {
            return VolumeListAsync(filters, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// List volumes
        /// </summary>
        /// <param name="filters">JSON encoded value of the filters (a `map[string][]string`) to
        /// <br/>process on the volumes list. Available filters:
        /// <br/>
        /// <br/>- `dangling=&lt;boolean&gt;` When set to `true` (or `1`), returns all
        /// <br/>   volumes that are not in use by a container. When set to `false`
        /// <br/>   (or `0`), only volumes that are in use by one or more
        /// <br/>   containers are returned.
        /// <br/>- `driver=&lt;volume-driver-name&gt;` Matches volumes based on their driver.
        /// <br/>- `label=&lt;key&gt;` or `label=&lt;key&gt;:&lt;value&gt;` Matches volumes based on
        /// <br/>   the presence of a `label` alone or a `label` and a value.
        /// <br/>- `name=&lt;volume-name&gt;` Matches all or part of a volume name.</param>
        /// <returns>Summary volume data that matches the query</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<VolumeListResponse> VolumeListAsync(string filters, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "volumes"
                    urlBuilder_.Append("volumes");
                    urlBuilder_.Append('?');
                    if (filters != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("filters")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(filters, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<VolumeListResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Create a volume
        /// </summary>
        /// <param name="volumeConfig">Volume configuration</param>
        /// <returns>The volume was created successfully</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Volume> VolumeCreateAsync(VolumeCreateOptions volumeConfig)
        {
            return VolumeCreateAsync(volumeConfig, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create a volume
        /// </summary>
        /// <param name="volumeConfig">Volume configuration</param>
        /// <returns>The volume was created successfully</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Volume> VolumeCreateAsync(VolumeCreateOptions volumeConfig, System.Threading.CancellationToken cancellationToken)
        {
            if (volumeConfig == null)
                throw new System.ArgumentNullException("volumeConfig");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(volumeConfig, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "volumes/create"
                    urlBuilder_.Append("volumes/create");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 201)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Volume>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Inspect a volume
        /// </summary>
        /// <param name="name">Volume name or ID</param>
        /// <returns>No error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Volume> VolumeInspectAsync(string name)
        {
            return VolumeInspectAsync(name, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Inspect a volume
        /// </summary>
        /// <param name="name">Volume name or ID</param>
        /// <returns>No error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Volume> VolumeInspectAsync(string name, System.Threading.CancellationToken cancellationToken)
        {
            if (name == null)
                throw new System.ArgumentNullException("name");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "volumes/{name}"
                    urlBuilder_.Append("volumes/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Volume>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("No such volume", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// "Update a volume. Valid only for Swarm cluster volumes"
        /// </summary>
        /// <param name="name">The name or ID of the volume</param>
        /// <param name="body">The spec of the volume to update. Currently, only Availability may
        /// <br/>change. All other fields must remain unchanged.</param>
        /// <param name="version">The version number of the volume being updated. This is required to
        /// <br/>avoid conflicting writes. Found in the volume's `ClusterVolume`
        /// <br/>field.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task VolumeUpdateAsync(string name, Body2 body, long version)
        {
            return VolumeUpdateAsync(name, body, version, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// "Update a volume. Valid only for Swarm cluster volumes"
        /// </summary>
        /// <param name="name">The name or ID of the volume</param>
        /// <param name="body">The spec of the volume to update. Currently, only Availability may
        /// <br/>change. All other fields must remain unchanged.</param>
        /// <param name="version">The version number of the volume being updated. This is required to
        /// <br/>avoid conflicting writes. Found in the volume's `ClusterVolume`
        /// <br/>field.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task VolumeUpdateAsync(string name, Body2 body, long version, System.Threading.CancellationToken cancellationToken)
        {
            if (name == null)
                throw new System.ArgumentNullException("name");

            if (version == null)
                throw new System.ArgumentNullException("version");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "volumes/{name}"
                    urlBuilder_.Append("volumes/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("version")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("bad parameter", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("no such volume", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("node is not part of a swarm", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove a volume
        /// </summary>
        /// <remarks>
        /// Instruct the driver to remove the volume.
        /// </remarks>
        /// <param name="name">Volume name or ID</param>
        /// <param name="force">Force the removal of the volume</param>
        /// <returns>The volume was removed</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task VolumeDeleteAsync(string name, bool? force)
        {
            return VolumeDeleteAsync(name, force, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove a volume
        /// </summary>
        /// <remarks>
        /// Instruct the driver to remove the volume.
        /// </remarks>
        /// <param name="name">Volume name or ID</param>
        /// <param name="force">Force the removal of the volume</param>
        /// <returns>The volume was removed</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task VolumeDeleteAsync(string name, bool? force, System.Threading.CancellationToken cancellationToken)
        {
            if (name == null)
                throw new System.ArgumentNullException("name");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "volumes/{name}"
                    urlBuilder_.Append("volumes/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('?');
                    if (force != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("force")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(force, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("No such volume or volume driver", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Volume is in use and cannot be removed", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete unused volumes
        /// </summary>
        /// <param name="filters">Filters to process on the prune list, encoded as JSON (a `map[string][]string`).
        /// <br/>
        /// <br/>Available filters:
        /// <br/>- `label` (`label=&lt;key&gt;`, `label=&lt;key&gt;=&lt;value&gt;`, `label!=&lt;key&gt;`, or `label!=&lt;key&gt;=&lt;value&gt;`) Prune volumes with (or without, in case `label!=...` is used) the specified labels.
        /// <br/>- `all` (`all=true`) - Consider all (local) volumes for pruning and not just anonymous volumes.</param>
        /// <returns>No error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<VolumePruneResponse> VolumePruneAsync(string filters)
        {
            return VolumePruneAsync(filters, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete unused volumes
        /// </summary>
        /// <param name="filters">Filters to process on the prune list, encoded as JSON (a `map[string][]string`).
        /// <br/>
        /// <br/>Available filters:
        /// <br/>- `label` (`label=&lt;key&gt;`, `label=&lt;key&gt;=&lt;value&gt;`, `label!=&lt;key&gt;`, or `label!=&lt;key&gt;=&lt;value&gt;`) Prune volumes with (or without, in case `label!=...` is used) the specified labels.
        /// <br/>- `all` (`all=true`) - Consider all (local) volumes for pruning and not just anonymous volumes.</param>
        /// <returns>No error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<VolumePruneResponse> VolumePruneAsync(string filters, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "volumes/prune"
                    urlBuilder_.Append("volumes/prune");
                    urlBuilder_.Append('?');
                    if (filters != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("filters")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(filters, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<VolumePruneResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// List networks
        /// </summary>
        /// <remarks>
        /// Returns a list of networks. For details on the format, see the
        /// <br/>[network inspect endpoint](#operation/NetworkInspect).
        /// <br/>
        /// <br/>Note that it uses a different, smaller representation of a network than
        /// <br/>inspecting a single network. For example, the list of containers attached
        /// <br/>to the network is not propagated in API versions 1.28 and up.
        /// </remarks>
        /// <param name="filters">JSON encoded value of the filters (a `map[string][]string`) to process
        /// <br/>on the networks list.
        /// <br/>
        /// <br/>Available filters:
        /// <br/>
        /// <br/>- `dangling=&lt;boolean&gt;` When set to `true` (or `1`), returns all
        /// <br/>   networks that are not in use by a container. When set to `false`
        /// <br/>   (or `0`), only networks that are in use by one or more
        /// <br/>   containers are returned.
        /// <br/>- `driver=&lt;driver-name&gt;` Matches a network's driver.
        /// <br/>- `id=&lt;network-id&gt;` Matches all or part of a network ID.
        /// <br/>- `label=&lt;key&gt;` or `label=&lt;key&gt;=&lt;value&gt;` of a network label.
        /// <br/>- `name=&lt;network-name&gt;` Matches all or part of a network name.
        /// <br/>- `scope=["swarm"|"global"|"local"]` Filters networks by scope (`swarm`, `global`, or `local`).
        /// <br/>- `type=["custom"|"builtin"]` Filters networks by type. The `custom` keyword returns all user-defined networks.</param>
        /// <returns>No error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Network>> NetworkListAsync(string filters)
        {
            return NetworkListAsync(filters, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// List networks
        /// </summary>
        /// <remarks>
        /// Returns a list of networks. For details on the format, see the
        /// <br/>[network inspect endpoint](#operation/NetworkInspect).
        /// <br/>
        /// <br/>Note that it uses a different, smaller representation of a network than
        /// <br/>inspecting a single network. For example, the list of containers attached
        /// <br/>to the network is not propagated in API versions 1.28 and up.
        /// </remarks>
        /// <param name="filters">JSON encoded value of the filters (a `map[string][]string`) to process
        /// <br/>on the networks list.
        /// <br/>
        /// <br/>Available filters:
        /// <br/>
        /// <br/>- `dangling=&lt;boolean&gt;` When set to `true` (or `1`), returns all
        /// <br/>   networks that are not in use by a container. When set to `false`
        /// <br/>   (or `0`), only networks that are in use by one or more
        /// <br/>   containers are returned.
        /// <br/>- `driver=&lt;driver-name&gt;` Matches a network's driver.
        /// <br/>- `id=&lt;network-id&gt;` Matches all or part of a network ID.
        /// <br/>- `label=&lt;key&gt;` or `label=&lt;key&gt;=&lt;value&gt;` of a network label.
        /// <br/>- `name=&lt;network-name&gt;` Matches all or part of a network name.
        /// <br/>- `scope=["swarm"|"global"|"local"]` Filters networks by scope (`swarm`, `global`, or `local`).
        /// <br/>- `type=["custom"|"builtin"]` Filters networks by type. The `custom` keyword returns all user-defined networks.</param>
        /// <returns>No error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Network>> NetworkListAsync(string filters, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "networks"
                    urlBuilder_.Append("networks");
                    urlBuilder_.Append('?');
                    if (filters != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("filters")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(filters, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<Network>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Inspect a network
        /// </summary>
        /// <param name="id">Network ID or name</param>
        /// <param name="verbose">Detailed inspect output for troubleshooting</param>
        /// <param name="scope">Filter the network by scope (swarm, global, or local)</param>
        /// <returns>No error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Network> NetworkInspectAsync(string id, bool? verbose, string scope)
        {
            return NetworkInspectAsync(id, verbose, scope, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Inspect a network
        /// </summary>
        /// <param name="id">Network ID or name</param>
        /// <param name="verbose">Detailed inspect output for troubleshooting</param>
        /// <param name="scope">Filter the network by scope (swarm, global, or local)</param>
        /// <returns>No error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Network> NetworkInspectAsync(string id, bool? verbose, string scope, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "networks/{id}"
                    urlBuilder_.Append("networks/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('?');
                    if (verbose != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("verbose")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(verbose, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (scope != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("scope")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(scope, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Network>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Network not found", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove a network
        /// </summary>
        /// <param name="id">Network ID or name</param>
        /// <returns>No error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task NetworkDeleteAsync(string id)
        {
            return NetworkDeleteAsync(id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove a network
        /// </summary>
        /// <param name="id">Network ID or name</param>
        /// <returns>No error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task NetworkDeleteAsync(string id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "networks/{id}"
                    urlBuilder_.Append("networks/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 403)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("operation not supported for pre-defined networks", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("no such network", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Create a network
        /// </summary>
        /// <param name="networkConfig">Network configuration</param>
        /// <returns>Network created successfully</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<NetworkCreateResponse> NetworkCreateAsync(NetworkCreateRequest networkConfig)
        {
            return NetworkCreateAsync(networkConfig, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create a network
        /// </summary>
        /// <param name="networkConfig">Network configuration</param>
        /// <returns>Network created successfully</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<NetworkCreateResponse> NetworkCreateAsync(NetworkCreateRequest networkConfig, System.Threading.CancellationToken cancellationToken)
        {
            if (networkConfig == null)
                throw new System.ArgumentNullException("networkConfig");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(networkConfig, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "networks/create"
                    urlBuilder_.Append("networks/create");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 201)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NetworkCreateResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("bad parameter", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Forbidden operation. This happens when trying to create a network named after a pre-defined network,\nor when trying to create an overlay network on a daemon which is not part of a Swarm cluster.\n", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("plugin not found", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Connect a container to a network
        /// </summary>
        /// <remarks>
        /// The network must be either a local-scoped network or a swarm-scoped network with the `attachable` option set. A network cannot be re-attached to a running container
        /// </remarks>
        /// <param name="id">Network ID or name</param>
        /// <returns>No error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task NetworkConnectAsync(string id, NetworkConnectRequest container)
        {
            return NetworkConnectAsync(id, container, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Connect a container to a network
        /// </summary>
        /// <remarks>
        /// The network must be either a local-scoped network or a swarm-scoped network with the `attachable` option set. A network cannot be re-attached to a running container
        /// </remarks>
        /// <param name="id">Network ID or name</param>
        /// <returns>No error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task NetworkConnectAsync(string id, NetworkConnectRequest container, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            if (container == null)
                throw new System.ArgumentNullException("container");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(container, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "networks/{id}/connect"
                    urlBuilder_.Append("networks/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/connect");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("bad parameter", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Operation forbidden", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Network or container not found", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Disconnect a container from a network
        /// </summary>
        /// <param name="id">Network ID or name</param>
        /// <returns>No error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task NetworkDisconnectAsync(string id, NetworkDisconnectRequest container)
        {
            return NetworkDisconnectAsync(id, container, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Disconnect a container from a network
        /// </summary>
        /// <param name="id">Network ID or name</param>
        /// <returns>No error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task NetworkDisconnectAsync(string id, NetworkDisconnectRequest container, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            if (container == null)
                throw new System.ArgumentNullException("container");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(container, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "networks/{id}/disconnect"
                    urlBuilder_.Append("networks/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/disconnect");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 403)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Operation not supported for swarm scoped networks", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Network or container not found", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete unused networks
        /// </summary>
        /// <param name="filters">Filters to process on the prune list, encoded as JSON (a `map[string][]string`).
        /// <br/>
        /// <br/>Available filters:
        /// <br/>- `until=&lt;timestamp&gt;` Prune networks created before this timestamp. The `&lt;timestamp&gt;` can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. `10m`, `1h30m`) computed relative to the daemon machine’s time.
        /// <br/>- `label` (`label=&lt;key&gt;`, `label=&lt;key&gt;=&lt;value&gt;`, `label!=&lt;key&gt;`, or `label!=&lt;key&gt;=&lt;value&gt;`) Prune networks with (or without, in case `label!=...` is used) the specified labels.</param>
        /// <returns>No error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<NetworkPruneResponse> NetworkPruneAsync(string filters)
        {
            return NetworkPruneAsync(filters, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete unused networks
        /// </summary>
        /// <param name="filters">Filters to process on the prune list, encoded as JSON (a `map[string][]string`).
        /// <br/>
        /// <br/>Available filters:
        /// <br/>- `until=&lt;timestamp&gt;` Prune networks created before this timestamp. The `&lt;timestamp&gt;` can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. `10m`, `1h30m`) computed relative to the daemon machine’s time.
        /// <br/>- `label` (`label=&lt;key&gt;`, `label=&lt;key&gt;=&lt;value&gt;`, `label!=&lt;key&gt;`, or `label!=&lt;key&gt;=&lt;value&gt;`) Prune networks with (or without, in case `label!=...` is used) the specified labels.</param>
        /// <returns>No error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<NetworkPruneResponse> NetworkPruneAsync(string filters, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "networks/prune"
                    urlBuilder_.Append("networks/prune");
                    urlBuilder_.Append('?');
                    if (filters != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("filters")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(filters, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NetworkPruneResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// List plugins
        /// </summary>
        /// <remarks>
        /// Returns information about installed plugins.
        /// </remarks>
        /// <param name="filters">A JSON encoded value of the filters (a `map[string][]string`) to
        /// <br/>process on the plugin list.
        /// <br/>
        /// <br/>Available filters:
        /// <br/>
        /// <br/>- `capability=&lt;capability name&gt;`
        /// <br/>- `enable=&lt;true&gt;|&lt;false&gt;`</param>
        /// <returns>No error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Plugin>> PluginListAsync(string filters)
        {
            return PluginListAsync(filters, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// List plugins
        /// </summary>
        /// <remarks>
        /// Returns information about installed plugins.
        /// </remarks>
        /// <param name="filters">A JSON encoded value of the filters (a `map[string][]string`) to
        /// <br/>process on the plugin list.
        /// <br/>
        /// <br/>Available filters:
        /// <br/>
        /// <br/>- `capability=&lt;capability name&gt;`
        /// <br/>- `enable=&lt;true&gt;|&lt;false&gt;`</param>
        /// <returns>No error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Plugin>> PluginListAsync(string filters, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "plugins"
                    urlBuilder_.Append("plugins");
                    urlBuilder_.Append('?');
                    if (filters != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("filters")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(filters, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<Plugin>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get plugin privileges
        /// </summary>
        /// <param name="remote">The name of the plugin. The `:latest` tag is optional, and is the
        /// <br/>default if omitted.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<PluginPrivilege>> GetPluginPrivilegesAsync(string remote)
        {
            return GetPluginPrivilegesAsync(remote, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get plugin privileges
        /// </summary>
        /// <param name="remote">The name of the plugin. The `:latest` tag is optional, and is the
        /// <br/>default if omitted.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<PluginPrivilege>> GetPluginPrivilegesAsync(string remote, System.Threading.CancellationToken cancellationToken)
        {
            if (remote == null)
                throw new System.ArgumentNullException("remote");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "plugins/privileges"
                    urlBuilder_.Append("plugins/privileges");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("remote")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(remote, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<PluginPrivilege>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Install a plugin
        /// </summary>
        /// <remarks>
        /// Pulls and installs a plugin. After the plugin is installed, it can be
        /// <br/>enabled using the [`POST /plugins/{name}/enable` endpoint](#operation/PostPluginsEnable).
        /// </remarks>
        /// <param name="remote">Remote reference for plugin to install.
        /// <br/>
        /// <br/>The `:latest` tag is optional, and is used as the default if omitted.</param>
        /// <param name="name">Local name for the pulled plugin.
        /// <br/>
        /// <br/>The `:latest` tag is optional, and is used as the default if omitted.</param>
        /// <param name="x_Registry_Auth">A base64url-encoded auth configuration to use when pulling a plugin
        /// <br/>from a registry.
        /// <br/>
        /// <br/>Refer to the [authentication section](#section/Authentication) for
        /// <br/>details.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task PluginPullAsync(string remote, string name, string x_Registry_Auth, System.Collections.Generic.IEnumerable<PluginPrivilege> body)
        {
            return PluginPullAsync(remote, name, x_Registry_Auth, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Install a plugin
        /// </summary>
        /// <remarks>
        /// Pulls and installs a plugin. After the plugin is installed, it can be
        /// <br/>enabled using the [`POST /plugins/{name}/enable` endpoint](#operation/PostPluginsEnable).
        /// </remarks>
        /// <param name="remote">Remote reference for plugin to install.
        /// <br/>
        /// <br/>The `:latest` tag is optional, and is used as the default if omitted.</param>
        /// <param name="name">Local name for the pulled plugin.
        /// <br/>
        /// <br/>The `:latest` tag is optional, and is used as the default if omitted.</param>
        /// <param name="x_Registry_Auth">A base64url-encoded auth configuration to use when pulling a plugin
        /// <br/>from a registry.
        /// <br/>
        /// <br/>Refer to the [authentication section](#section/Authentication) for
        /// <br/>details.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task PluginPullAsync(string remote, string name, string x_Registry_Auth, System.Collections.Generic.IEnumerable<PluginPrivilege> body, System.Threading.CancellationToken cancellationToken)
        {
            if (remote == null)
                throw new System.ArgumentNullException("remote");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (x_Registry_Auth != null)
                        request_.Headers.TryAddWithoutValidation("X-Registry-Auth", ConvertToString(x_Registry_Auth, System.Globalization.CultureInfo.InvariantCulture));
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "plugins/pull"
                    urlBuilder_.Append("plugins/pull");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("remote")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(remote, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (name != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("name")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Inspect a plugin
        /// </summary>
        /// <param name="name">The name of the plugin. The `:latest` tag is optional, and is the
        /// <br/>default if omitted.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Plugin> PluginInspectAsync(string name)
        {
            return PluginInspectAsync(name, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Inspect a plugin
        /// </summary>
        /// <param name="name">The name of the plugin. The `:latest` tag is optional, and is the
        /// <br/>default if omitted.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Plugin> PluginInspectAsync(string name, System.Threading.CancellationToken cancellationToken)
        {
            if (name == null)
                throw new System.ArgumentNullException("name");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "plugins/{name}/json"
                    urlBuilder_.Append("plugins/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/json");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Plugin>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("plugin is not installed", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Remove a plugin
        /// </summary>
        /// <param name="name">The name of the plugin. The `:latest` tag is optional, and is the
        /// <br/>default if omitted.</param>
        /// <param name="force">Disable the plugin before removing. This may result in issues if the
        /// <br/>plugin is in use by a container.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Plugin> PluginDeleteAsync(string name, bool? force)
        {
            return PluginDeleteAsync(name, force, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Remove a plugin
        /// </summary>
        /// <param name="name">The name of the plugin. The `:latest` tag is optional, and is the
        /// <br/>default if omitted.</param>
        /// <param name="force">Disable the plugin before removing. This may result in issues if the
        /// <br/>plugin is in use by a container.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Plugin> PluginDeleteAsync(string name, bool? force, System.Threading.CancellationToken cancellationToken)
        {
            if (name == null)
                throw new System.ArgumentNullException("name");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "plugins/{name}"
                    urlBuilder_.Append("plugins/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('?');
                    if (force != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("force")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(force, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Plugin>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("plugin is not installed", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Enable a plugin
        /// </summary>
        /// <param name="name">The name of the plugin. The `:latest` tag is optional, and is the
        /// <br/>default if omitted.</param>
        /// <param name="timeout">Set the HTTP client timeout (in seconds)</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task PluginEnableAsync(string name, int? timeout)
        {
            return PluginEnableAsync(name, timeout, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Enable a plugin
        /// </summary>
        /// <param name="name">The name of the plugin. The `:latest` tag is optional, and is the
        /// <br/>default if omitted.</param>
        /// <param name="timeout">Set the HTTP client timeout (in seconds)</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task PluginEnableAsync(string name, int? timeout, System.Threading.CancellationToken cancellationToken)
        {
            if (name == null)
                throw new System.ArgumentNullException("name");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "plugins/{name}/enable"
                    urlBuilder_.Append("plugins/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/enable");
                    urlBuilder_.Append('?');
                    if (timeout != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("timeout")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(timeout, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("plugin is not installed", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Disable a plugin
        /// </summary>
        /// <param name="name">The name of the plugin. The `:latest` tag is optional, and is the
        /// <br/>default if omitted.</param>
        /// <param name="force">Force disable a plugin even if still in use.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task PluginDisableAsync(string name, bool? force)
        {
            return PluginDisableAsync(name, force, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Disable a plugin
        /// </summary>
        /// <param name="name">The name of the plugin. The `:latest` tag is optional, and is the
        /// <br/>default if omitted.</param>
        /// <param name="force">Force disable a plugin even if still in use.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task PluginDisableAsync(string name, bool? force, System.Threading.CancellationToken cancellationToken)
        {
            if (name == null)
                throw new System.ArgumentNullException("name");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "plugins/{name}/disable"
                    urlBuilder_.Append("plugins/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/disable");
                    urlBuilder_.Append('?');
                    if (force != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("force")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(force, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("plugin is not installed", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Upgrade a plugin
        /// </summary>
        /// <param name="name">The name of the plugin. The `:latest` tag is optional, and is the
        /// <br/>default if omitted.</param>
        /// <param name="remote">Remote reference to upgrade to.
        /// <br/>
        /// <br/>The `:latest` tag is optional, and is used as the default if omitted.</param>
        /// <param name="x_Registry_Auth">A base64url-encoded auth configuration to use when pulling a plugin
        /// <br/>from a registry.
        /// <br/>
        /// <br/>Refer to the [authentication section](#section/Authentication) for
        /// <br/>details.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task PluginUpgradeAsync(string name, string remote, string x_Registry_Auth, System.Collections.Generic.IEnumerable<PluginPrivilege> body)
        {
            return PluginUpgradeAsync(name, remote, x_Registry_Auth, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Upgrade a plugin
        /// </summary>
        /// <param name="name">The name of the plugin. The `:latest` tag is optional, and is the
        /// <br/>default if omitted.</param>
        /// <param name="remote">Remote reference to upgrade to.
        /// <br/>
        /// <br/>The `:latest` tag is optional, and is used as the default if omitted.</param>
        /// <param name="x_Registry_Auth">A base64url-encoded auth configuration to use when pulling a plugin
        /// <br/>from a registry.
        /// <br/>
        /// <br/>Refer to the [authentication section](#section/Authentication) for
        /// <br/>details.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task PluginUpgradeAsync(string name, string remote, string x_Registry_Auth, System.Collections.Generic.IEnumerable<PluginPrivilege> body, System.Threading.CancellationToken cancellationToken)
        {
            if (name == null)
                throw new System.ArgumentNullException("name");

            if (remote == null)
                throw new System.ArgumentNullException("remote");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (x_Registry_Auth != null)
                        request_.Headers.TryAddWithoutValidation("X-Registry-Auth", ConvertToString(x_Registry_Auth, System.Globalization.CultureInfo.InvariantCulture));
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "plugins/{name}/upgrade"
                    urlBuilder_.Append("plugins/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/upgrade");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("remote")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(remote, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("plugin not installed", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Create a plugin
        /// </summary>
        /// <param name="name">The name of the plugin. The `:latest` tag is optional, and is the
        /// <br/>default if omitted.</param>
        /// <param name="tarContext">Path to tar containing plugin rootfs and manifest</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task PluginCreateAsync(string name, System.IO.Stream tarContext)
        {
            return PluginCreateAsync(name, tarContext, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create a plugin
        /// </summary>
        /// <param name="name">The name of the plugin. The `:latest` tag is optional, and is the
        /// <br/>default if omitted.</param>
        /// <param name="tarContext">Path to tar containing plugin rootfs and manifest</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task PluginCreateAsync(string name, System.IO.Stream tarContext, System.Threading.CancellationToken cancellationToken)
        {
            if (name == null)
                throw new System.ArgumentNullException("name");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StreamContent(tarContext);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-tar");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "plugins/create"
                    urlBuilder_.Append("plugins/create");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("name")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Push a plugin
        /// </summary>
        /// <remarks>
        /// Push a plugin to the registry.
        /// </remarks>
        /// <param name="name">The name of the plugin. The `:latest` tag is optional, and is the
        /// <br/>default if omitted.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task PluginPushAsync(string name)
        {
            return PluginPushAsync(name, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Push a plugin
        /// </summary>
        /// <remarks>
        /// Push a plugin to the registry.
        /// </remarks>
        /// <param name="name">The name of the plugin. The `:latest` tag is optional, and is the
        /// <br/>default if omitted.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task PluginPushAsync(string name, System.Threading.CancellationToken cancellationToken)
        {
            if (name == null)
                throw new System.ArgumentNullException("name");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "plugins/{name}/push"
                    urlBuilder_.Append("plugins/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/push");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("plugin not installed", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Configure a plugin
        /// </summary>
        /// <param name="name">The name of the plugin. The `:latest` tag is optional, and is the
        /// <br/>default if omitted.</param>
        /// <returns>No error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task PluginSetAsync(string name, System.Collections.Generic.IEnumerable<string> body)
        {
            return PluginSetAsync(name, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Configure a plugin
        /// </summary>
        /// <param name="name">The name of the plugin. The `:latest` tag is optional, and is the
        /// <br/>default if omitted.</param>
        /// <returns>No error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task PluginSetAsync(string name, System.Collections.Generic.IEnumerable<string> body, System.Threading.CancellationToken cancellationToken)
        {
            if (name == null)
                throw new System.ArgumentNullException("name");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "plugins/{name}/set"
                    urlBuilder_.Append("plugins/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/set");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Plugin not installed", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// List nodes
        /// </summary>
        /// <param name="filters">Filters to process on the nodes list, encoded as JSON (a `map[string][]string`).
        /// <br/>
        /// <br/>Available filters:
        /// <br/>- `id=&lt;node id&gt;`
        /// <br/>- `label=&lt;engine label&gt;`
        /// <br/>- `membership=`(`accepted`|`pending`)`
        /// <br/>- `name=&lt;node name&gt;`
        /// <br/>- `node.label=&lt;node label&gt;`
        /// <br/>- `role=`(`manager`|`worker`)`</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Node>> NodeListAsync(string filters)
        {
            return NodeListAsync(filters, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// List nodes
        /// </summary>
        /// <param name="filters">Filters to process on the nodes list, encoded as JSON (a `map[string][]string`).
        /// <br/>
        /// <br/>Available filters:
        /// <br/>- `id=&lt;node id&gt;`
        /// <br/>- `label=&lt;engine label&gt;`
        /// <br/>- `membership=`(`accepted`|`pending`)`
        /// <br/>- `name=&lt;node name&gt;`
        /// <br/>- `node.label=&lt;node label&gt;`
        /// <br/>- `role=`(`manager`|`worker`)`</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Node>> NodeListAsync(string filters, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "nodes"
                    urlBuilder_.Append("nodes");
                    urlBuilder_.Append('?');
                    if (filters != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("filters")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(filters, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<Node>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("node is not part of a swarm", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Inspect a node
        /// </summary>
        /// <param name="id">The ID or name of the node</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Node> NodeInspectAsync(string id)
        {
            return NodeInspectAsync(id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Inspect a node
        /// </summary>
        /// <param name="id">The ID or name of the node</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Node> NodeInspectAsync(string id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "nodes/{id}"
                    urlBuilder_.Append("nodes/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Node>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("no such node", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("node is not part of a swarm", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete a node
        /// </summary>
        /// <param name="id">The ID or name of the node</param>
        /// <param name="force">Force remove a node from the swarm</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task NodeDeleteAsync(string id, bool? force)
        {
            return NodeDeleteAsync(id, force, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete a node
        /// </summary>
        /// <param name="id">The ID or name of the node</param>
        /// <param name="force">Force remove a node from the swarm</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task NodeDeleteAsync(string id, bool? force, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "nodes/{id}"
                    urlBuilder_.Append("nodes/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('?');
                    if (force != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("force")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(force, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("no such node", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("node is not part of a swarm", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Update a node
        /// </summary>
        /// <param name="id">The ID of the node</param>
        /// <param name="version">The version number of the node object being updated. This is required
        /// <br/>to avoid conflicting writes.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task NodeUpdateAsync(string id, NodeSpec body, long version)
        {
            return NodeUpdateAsync(id, body, version, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update a node
        /// </summary>
        /// <param name="id">The ID of the node</param>
        /// <param name="version">The version number of the node object being updated. This is required
        /// <br/>to avoid conflicting writes.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task NodeUpdateAsync(string id, NodeSpec body, long version, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            if (version == null)
                throw new System.ArgumentNullException("version");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "nodes/{id}/update"
                    urlBuilder_.Append("nodes/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/update");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("version")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("bad parameter", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("no such node", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("node is not part of a swarm", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Inspect swarm
        /// </summary>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Swarm> SwarmInspectAsync()
        {
            return SwarmInspectAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Inspect swarm
        /// </summary>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Swarm> SwarmInspectAsync(System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "swarm"
                    urlBuilder_.Append("swarm");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Swarm>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("no such swarm", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("node is not part of a swarm", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Initialize a new swarm
        /// </summary>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<string> SwarmInitAsync(SwarmInitRequest body)
        {
            return SwarmInitAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Initialize a new swarm
        /// </summary>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<string> SwarmInitAsync(SwarmInitRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "swarm/init"
                    urlBuilder_.Append("swarm/init");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<string>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("bad parameter", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("node is already part of a swarm", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Join an existing swarm
        /// </summary>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SwarmJoinAsync(SwarmJoinRequest body)
        {
            return SwarmJoinAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Join an existing swarm
        /// </summary>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SwarmJoinAsync(SwarmJoinRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "swarm/join"
                    urlBuilder_.Append("swarm/join");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("bad parameter", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("node is already part of a swarm", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Leave a swarm
        /// </summary>
        /// <param name="force">Force leave swarm, even if this is the last manager or that it will
        /// <br/>break the cluster.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SwarmLeaveAsync(bool? force)
        {
            return SwarmLeaveAsync(force, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Leave a swarm
        /// </summary>
        /// <param name="force">Force leave swarm, even if this is the last manager or that it will
        /// <br/>break the cluster.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SwarmLeaveAsync(bool? force, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "swarm/leave"
                    urlBuilder_.Append("swarm/leave");
                    urlBuilder_.Append('?');
                    if (force != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("force")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(force, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("node is not part of a swarm", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Update a swarm
        /// </summary>
        /// <param name="version">The version number of the swarm object being updated. This is
        /// <br/>required to avoid conflicting writes.</param>
        /// <param name="rotateWorkerToken">Rotate the worker join token.</param>
        /// <param name="rotateManagerToken">Rotate the manager join token.</param>
        /// <param name="rotateManagerUnlockKey">Rotate the manager unlock key.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SwarmUpdateAsync(SwarmSpec body, long version, bool? rotateWorkerToken, bool? rotateManagerToken, bool? rotateManagerUnlockKey)
        {
            return SwarmUpdateAsync(body, version, rotateWorkerToken, rotateManagerToken, rotateManagerUnlockKey, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update a swarm
        /// </summary>
        /// <param name="version">The version number of the swarm object being updated. This is
        /// <br/>required to avoid conflicting writes.</param>
        /// <param name="rotateWorkerToken">Rotate the worker join token.</param>
        /// <param name="rotateManagerToken">Rotate the manager join token.</param>
        /// <param name="rotateManagerUnlockKey">Rotate the manager unlock key.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SwarmUpdateAsync(SwarmSpec body, long version, bool? rotateWorkerToken, bool? rotateManagerToken, bool? rotateManagerUnlockKey, System.Threading.CancellationToken cancellationToken)
        {
            if (version == null)
                throw new System.ArgumentNullException("version");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "swarm/update"
                    urlBuilder_.Append("swarm/update");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("version")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (rotateWorkerToken != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("rotateWorkerToken")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(rotateWorkerToken, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (rotateManagerToken != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("rotateManagerToken")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(rotateManagerToken, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (rotateManagerUnlockKey != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("rotateManagerUnlockKey")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(rotateManagerUnlockKey, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("bad parameter", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("node is not part of a swarm", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get the unlock key
        /// </summary>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<UnlockKeyResponse> SwarmUnlockkeyAsync()
        {
            return SwarmUnlockkeyAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the unlock key
        /// </summary>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<UnlockKeyResponse> SwarmUnlockkeyAsync(System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "swarm/unlockkey"
                    urlBuilder_.Append("swarm/unlockkey");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<UnlockKeyResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("node is not part of a swarm", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Unlock a locked manager
        /// </summary>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SwarmUnlockAsync(SwarmUnlockRequest body)
        {
            return SwarmUnlockAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Unlock a locked manager
        /// </summary>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SwarmUnlockAsync(SwarmUnlockRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "swarm/unlock"
                    urlBuilder_.Append("swarm/unlock");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("node is not part of a swarm", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// List services
        /// </summary>
        /// <param name="filters">A JSON encoded value of the filters (a `map[string][]string`) to
        /// <br/>process on the services list.
        /// <br/>
        /// <br/>Available filters:
        /// <br/>
        /// <br/>- `id=&lt;service id&gt;`
        /// <br/>- `label=&lt;service label&gt;`
        /// <br/>- `mode=["replicated"|"global"]`
        /// <br/>- `name=&lt;service name&gt;`</param>
        /// <param name="status">Include service status, with count of running and desired tasks.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Service>> ServiceListAsync(string filters, bool? status)
        {
            return ServiceListAsync(filters, status, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// List services
        /// </summary>
        /// <param name="filters">A JSON encoded value of the filters (a `map[string][]string`) to
        /// <br/>process on the services list.
        /// <br/>
        /// <br/>Available filters:
        /// <br/>
        /// <br/>- `id=&lt;service id&gt;`
        /// <br/>- `label=&lt;service label&gt;`
        /// <br/>- `mode=["replicated"|"global"]`
        /// <br/>- `name=&lt;service name&gt;`</param>
        /// <param name="status">Include service status, with count of running and desired tasks.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Service>> ServiceListAsync(string filters, bool? status, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "services"
                    urlBuilder_.Append("services");
                    urlBuilder_.Append('?');
                    if (filters != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("filters")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(filters, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (status != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("status")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(status, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<Service>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("node is not part of a swarm", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Create a service
        /// </summary>
        /// <param name="x_Registry_Auth">A base64url-encoded auth configuration for pulling from private
        /// <br/>registries.
        /// <br/>
        /// <br/>Refer to the [authentication section](#section/Authentication) for
        /// <br/>details.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ServiceCreateResponse> ServiceCreateAsync(Body3 body, string x_Registry_Auth)
        {
            return ServiceCreateAsync(body, x_Registry_Auth, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create a service
        /// </summary>
        /// <param name="x_Registry_Auth">A base64url-encoded auth configuration for pulling from private
        /// <br/>registries.
        /// <br/>
        /// <br/>Refer to the [authentication section](#section/Authentication) for
        /// <br/>details.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ServiceCreateResponse> ServiceCreateAsync(Body3 body, string x_Registry_Auth, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (x_Registry_Auth != null)
                        request_.Headers.TryAddWithoutValidation("X-Registry-Auth", ConvertToString(x_Registry_Auth, System.Globalization.CultureInfo.InvariantCulture));
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "services/create"
                    urlBuilder_.Append("services/create");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 201)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ServiceCreateResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("bad parameter", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("network is not eligible for services", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("name conflicts with an existing service", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("node is not part of a swarm", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Inspect a service
        /// </summary>
        /// <param name="id">ID or name of service.</param>
        /// <param name="insertDefaults">Fill empty fields with default values.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Service> ServiceInspectAsync(string id, bool? insertDefaults)
        {
            return ServiceInspectAsync(id, insertDefaults, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Inspect a service
        /// </summary>
        /// <param name="id">ID or name of service.</param>
        /// <param name="insertDefaults">Fill empty fields with default values.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Service> ServiceInspectAsync(string id, bool? insertDefaults, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "services/{id}"
                    urlBuilder_.Append("services/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('?');
                    if (insertDefaults != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("insertDefaults")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(insertDefaults, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Service>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("no such service", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("node is not part of a swarm", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete a service
        /// </summary>
        /// <param name="id">ID or name of service.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ServiceDeleteAsync(string id)
        {
            return ServiceDeleteAsync(id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete a service
        /// </summary>
        /// <param name="id">ID or name of service.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ServiceDeleteAsync(string id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "services/{id}"
                    urlBuilder_.Append("services/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("no such service", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("node is not part of a swarm", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Update a service
        /// </summary>
        /// <param name="id">ID or name of service.</param>
        /// <param name="version">The version number of the service object being updated. This is
        /// <br/>required to avoid conflicting writes.
        /// <br/>This version number should be the value as currently set on the
        /// <br/>service *before* the update. You can find the current version by
        /// <br/>calling `GET /services/{id}`</param>
        /// <param name="registryAuthFrom">If the `X-Registry-Auth` header is not specified, this parameter
        /// <br/>indicates where to find registry authorization credentials.</param>
        /// <param name="rollback">Set to this parameter to `previous` to cause a server-side rollback
        /// <br/>to the previous service spec. The supplied spec will be ignored in
        /// <br/>this case.</param>
        /// <param name="x_Registry_Auth">A base64url-encoded auth configuration for pulling from private
        /// <br/>registries.
        /// <br/>
        /// <br/>Refer to the [authentication section](#section/Authentication) for
        /// <br/>details.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ServiceUpdateResponse> ServiceUpdateAsync(string id, Body4 body, int version, RegistryAuthFrom? registryAuthFrom, string rollback, string x_Registry_Auth)
        {
            return ServiceUpdateAsync(id, body, version, registryAuthFrom, rollback, x_Registry_Auth, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update a service
        /// </summary>
        /// <param name="id">ID or name of service.</param>
        /// <param name="version">The version number of the service object being updated. This is
        /// <br/>required to avoid conflicting writes.
        /// <br/>This version number should be the value as currently set on the
        /// <br/>service *before* the update. You can find the current version by
        /// <br/>calling `GET /services/{id}`</param>
        /// <param name="registryAuthFrom">If the `X-Registry-Auth` header is not specified, this parameter
        /// <br/>indicates where to find registry authorization credentials.</param>
        /// <param name="rollback">Set to this parameter to `previous` to cause a server-side rollback
        /// <br/>to the previous service spec. The supplied spec will be ignored in
        /// <br/>this case.</param>
        /// <param name="x_Registry_Auth">A base64url-encoded auth configuration for pulling from private
        /// <br/>registries.
        /// <br/>
        /// <br/>Refer to the [authentication section](#section/Authentication) for
        /// <br/>details.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ServiceUpdateResponse> ServiceUpdateAsync(string id, Body4 body, int version, RegistryAuthFrom? registryAuthFrom, string rollback, string x_Registry_Auth, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            if (version == null)
                throw new System.ArgumentNullException("version");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (x_Registry_Auth != null)
                        request_.Headers.TryAddWithoutValidation("X-Registry-Auth", ConvertToString(x_Registry_Auth, System.Globalization.CultureInfo.InvariantCulture));
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "services/{id}/update"
                    urlBuilder_.Append("services/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/update");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("version")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (registryAuthFrom != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("registryAuthFrom")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(registryAuthFrom, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (rollback != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("rollback")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(rollback, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ServiceUpdateResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("bad parameter", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("no such service", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("node is not part of a swarm", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get service logs
        /// </summary>
        /// <remarks>
        /// Get `stdout` and `stderr` logs from a service. See also
        /// <br/>[`/containers/{id}/logs`](#operation/ContainerLogs).
        /// <br/>
        /// <br/>**Note**: This endpoint works only for services with the `local`,
        /// <br/>`json-file` or `journald` logging drivers.
        /// </remarks>
        /// <param name="id">ID or name of the service</param>
        /// <param name="details">Show service context and extra details provided to logs.</param>
        /// <param name="follow">Keep connection after returning logs.</param>
        /// <param name="stdout">Return logs from `stdout`</param>
        /// <param name="stderr">Return logs from `stderr`</param>
        /// <param name="since">Only return logs since this time, as a UNIX timestamp</param>
        /// <param name="timestamps">Add timestamps to every log line</param>
        /// <param name="tail">Only return this number of log lines from the end of the logs.
        /// <br/>Specify as an integer or `all` to output all log lines.</param>
        /// <returns>logs returned as a stream in response body</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<FileResponse> ServiceLogsAsync(string id, bool? details, bool? follow, bool? stdout, bool? stderr, int? since, bool? timestamps, string tail)
        {
            return ServiceLogsAsync(id, details, follow, stdout, stderr, since, timestamps, tail, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get service logs
        /// </summary>
        /// <remarks>
        /// Get `stdout` and `stderr` logs from a service. See also
        /// <br/>[`/containers/{id}/logs`](#operation/ContainerLogs).
        /// <br/>
        /// <br/>**Note**: This endpoint works only for services with the `local`,
        /// <br/>`json-file` or `journald` logging drivers.
        /// </remarks>
        /// <param name="id">ID or name of the service</param>
        /// <param name="details">Show service context and extra details provided to logs.</param>
        /// <param name="follow">Keep connection after returning logs.</param>
        /// <param name="stdout">Return logs from `stdout`</param>
        /// <param name="stderr">Return logs from `stderr`</param>
        /// <param name="since">Only return logs since this time, as a UNIX timestamp</param>
        /// <param name="timestamps">Add timestamps to every log line</param>
        /// <param name="tail">Only return this number of log lines from the end of the logs.
        /// <br/>Specify as an integer or `all` to output all log lines.</param>
        /// <returns>logs returned as a stream in response body</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<FileResponse> ServiceLogsAsync(string id, bool? details, bool? follow, bool? stdout, bool? stderr, int? since, bool? timestamps, string tail, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/vnd.docker.raw-stream"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "services/{id}/logs"
                    urlBuilder_.Append("services/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/logs");
                    urlBuilder_.Append('?');
                    if (details != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("details")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(details, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (follow != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("follow")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(follow, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (stdout != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("stdout")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(stdout, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (stderr != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("stderr")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(stderr, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (since != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("since")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(since, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (timestamps != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("timestamps")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(timestamps, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (tail != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("tail")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(tail, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200 || status_ == 206)
                        {
                            var responseStream_ = response_.Content == null ? System.IO.Stream.Null : await response_.Content.ReadAsStreamAsync().ConfigureAwait(false);
                            var fileResponse_ = new FileResponse(status_, headers_, responseStream_, null, response_);
                            disposeClient_ = false; disposeResponse_ = false; // response and client are disposed by FileResponse
                            return fileResponse_;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("no such service", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("node is not part of a swarm", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// List tasks
        /// </summary>
        /// <param name="filters">A JSON encoded value of the filters (a `map[string][]string`) to
        /// <br/>process on the tasks list.
        /// <br/>
        /// <br/>Available filters:
        /// <br/>
        /// <br/>- `desired-state=(running | shutdown | accepted)`
        /// <br/>- `id=&lt;task id&gt;`
        /// <br/>- `label=key` or `label="key=value"`
        /// <br/>- `name=&lt;task name&gt;`
        /// <br/>- `node=&lt;node id or name&gt;`
        /// <br/>- `service=&lt;service name&gt;`</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Task>> TaskListAsync(string filters)
        {
            return TaskListAsync(filters, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// List tasks
        /// </summary>
        /// <param name="filters">A JSON encoded value of the filters (a `map[string][]string`) to
        /// <br/>process on the tasks list.
        /// <br/>
        /// <br/>Available filters:
        /// <br/>
        /// <br/>- `desired-state=(running | shutdown | accepted)`
        /// <br/>- `id=&lt;task id&gt;`
        /// <br/>- `label=key` or `label="key=value"`
        /// <br/>- `name=&lt;task name&gt;`
        /// <br/>- `node=&lt;node id or name&gt;`
        /// <br/>- `service=&lt;service name&gt;`</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Task>> TaskListAsync(string filters, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "tasks"
                    urlBuilder_.Append("tasks");
                    urlBuilder_.Append('?');
                    if (filters != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("filters")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(filters, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<Task>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("node is not part of a swarm", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Inspect a task
        /// </summary>
        /// <param name="id">ID of the task</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Task> TaskInspectAsync(string id)
        {
            return TaskInspectAsync(id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Inspect a task
        /// </summary>
        /// <param name="id">ID of the task</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Task> TaskInspectAsync(string id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "tasks/{id}"
                    urlBuilder_.Append("tasks/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Task>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("no such task", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("node is not part of a swarm", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get task logs
        /// </summary>
        /// <remarks>
        /// Get `stdout` and `stderr` logs from a task.
        /// <br/>See also [`/containers/{id}/logs`](#operation/ContainerLogs).
        /// <br/>
        /// <br/>**Note**: This endpoint works only for services with the `local`,
        /// <br/>`json-file` or `journald` logging drivers.
        /// </remarks>
        /// <param name="id">ID of the task</param>
        /// <param name="details">Show task context and extra details provided to logs.</param>
        /// <param name="follow">Keep connection after returning logs.</param>
        /// <param name="stdout">Return logs from `stdout`</param>
        /// <param name="stderr">Return logs from `stderr`</param>
        /// <param name="since">Only return logs since this time, as a UNIX timestamp</param>
        /// <param name="timestamps">Add timestamps to every log line</param>
        /// <param name="tail">Only return this number of log lines from the end of the logs.
        /// <br/>Specify as an integer or `all` to output all log lines.</param>
        /// <returns>logs returned as a stream in response body</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<FileResponse> TaskLogsAsync(string id, bool? details, bool? follow, bool? stdout, bool? stderr, int? since, bool? timestamps, string tail)
        {
            return TaskLogsAsync(id, details, follow, stdout, stderr, since, timestamps, tail, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get task logs
        /// </summary>
        /// <remarks>
        /// Get `stdout` and `stderr` logs from a task.
        /// <br/>See also [`/containers/{id}/logs`](#operation/ContainerLogs).
        /// <br/>
        /// <br/>**Note**: This endpoint works only for services with the `local`,
        /// <br/>`json-file` or `journald` logging drivers.
        /// </remarks>
        /// <param name="id">ID of the task</param>
        /// <param name="details">Show task context and extra details provided to logs.</param>
        /// <param name="follow">Keep connection after returning logs.</param>
        /// <param name="stdout">Return logs from `stdout`</param>
        /// <param name="stderr">Return logs from `stderr`</param>
        /// <param name="since">Only return logs since this time, as a UNIX timestamp</param>
        /// <param name="timestamps">Add timestamps to every log line</param>
        /// <param name="tail">Only return this number of log lines from the end of the logs.
        /// <br/>Specify as an integer or `all` to output all log lines.</param>
        /// <returns>logs returned as a stream in response body</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<FileResponse> TaskLogsAsync(string id, bool? details, bool? follow, bool? stdout, bool? stderr, int? since, bool? timestamps, string tail, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/vnd.docker.raw-stream"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "tasks/{id}/logs"
                    urlBuilder_.Append("tasks/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/logs");
                    urlBuilder_.Append('?');
                    if (details != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("details")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(details, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (follow != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("follow")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(follow, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (stdout != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("stdout")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(stdout, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (stderr != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("stderr")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(stderr, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (since != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("since")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(since, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (timestamps != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("timestamps")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(timestamps, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (tail != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("tail")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(tail, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200 || status_ == 206)
                        {
                            var responseStream_ = response_.Content == null ? System.IO.Stream.Null : await response_.Content.ReadAsStreamAsync().ConfigureAwait(false);
                            var fileResponse_ = new FileResponse(status_, headers_, responseStream_, null, response_);
                            disposeClient_ = false; disposeResponse_ = false; // response and client are disposed by FileResponse
                            return fileResponse_;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("no such task", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("node is not part of a swarm", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// List secrets
        /// </summary>
        /// <param name="filters">A JSON encoded value of the filters (a `map[string][]string`) to
        /// <br/>process on the secrets list.
        /// <br/>
        /// <br/>Available filters:
        /// <br/>
        /// <br/>- `id=&lt;secret id&gt;`
        /// <br/>- `label=&lt;key&gt; or label=&lt;key&gt;=value`
        /// <br/>- `name=&lt;secret name&gt;`
        /// <br/>- `names=&lt;secret name&gt;`</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Secret>> SecretListAsync(string filters)
        {
            return SecretListAsync(filters, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// List secrets
        /// </summary>
        /// <param name="filters">A JSON encoded value of the filters (a `map[string][]string`) to
        /// <br/>process on the secrets list.
        /// <br/>
        /// <br/>Available filters:
        /// <br/>
        /// <br/>- `id=&lt;secret id&gt;`
        /// <br/>- `label=&lt;key&gt; or label=&lt;key&gt;=value`
        /// <br/>- `name=&lt;secret name&gt;`
        /// <br/>- `names=&lt;secret name&gt;`</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Secret>> SecretListAsync(string filters, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "secrets"
                    urlBuilder_.Append("secrets");
                    urlBuilder_.Append('?');
                    if (filters != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("filters")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(filters, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<Secret>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("node is not part of a swarm", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Create a secret
        /// </summary>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<IdResponse> SecretCreateAsync(Body5 body)
        {
            return SecretCreateAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create a secret
        /// </summary>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<IdResponse> SecretCreateAsync(Body5 body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "secrets/create"
                    urlBuilder_.Append("secrets/create");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 201)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<IdResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 409)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("name conflicts with an existing object", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("node is not part of a swarm", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Inspect a secret
        /// </summary>
        /// <param name="id">ID of the secret</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Secret> SecretInspectAsync(string id)
        {
            return SecretInspectAsync(id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Inspect a secret
        /// </summary>
        /// <param name="id">ID of the secret</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Secret> SecretInspectAsync(string id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "secrets/{id}"
                    urlBuilder_.Append("secrets/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Secret>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("secret not found", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("node is not part of a swarm", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete a secret
        /// </summary>
        /// <param name="id">ID of the secret</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SecretDeleteAsync(string id)
        {
            return SecretDeleteAsync(id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete a secret
        /// </summary>
        /// <param name="id">ID of the secret</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SecretDeleteAsync(string id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "secrets/{id}"
                    urlBuilder_.Append("secrets/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("secret not found", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("node is not part of a swarm", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Update a Secret
        /// </summary>
        /// <param name="id">The ID or name of the secret</param>
        /// <param name="body">The spec of the secret to update. Currently, only the Labels field
        /// <br/>can be updated. All other fields must remain unchanged from the
        /// <br/>[SecretInspect endpoint](#operation/SecretInspect) response values.</param>
        /// <param name="version">The version number of the secret object being updated. This is
        /// <br/>required to avoid conflicting writes.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SecretUpdateAsync(string id, SecretSpec body, long version)
        {
            return SecretUpdateAsync(id, body, version, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update a Secret
        /// </summary>
        /// <param name="id">The ID or name of the secret</param>
        /// <param name="body">The spec of the secret to update. Currently, only the Labels field
        /// <br/>can be updated. All other fields must remain unchanged from the
        /// <br/>[SecretInspect endpoint](#operation/SecretInspect) response values.</param>
        /// <param name="version">The version number of the secret object being updated. This is
        /// <br/>required to avoid conflicting writes.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SecretUpdateAsync(string id, SecretSpec body, long version, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            if (version == null)
                throw new System.ArgumentNullException("version");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "secrets/{id}/update"
                    urlBuilder_.Append("secrets/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/update");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("version")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("bad parameter", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("no such secret", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("node is not part of a swarm", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// List configs
        /// </summary>
        /// <param name="filters">A JSON encoded value of the filters (a `map[string][]string`) to
        /// <br/>process on the configs list.
        /// <br/>
        /// <br/>Available filters:
        /// <br/>
        /// <br/>- `id=&lt;config id&gt;`
        /// <br/>- `label=&lt;key&gt; or label=&lt;key&gt;=value`
        /// <br/>- `name=&lt;config name&gt;`
        /// <br/>- `names=&lt;config name&gt;`</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Config>> ConfigListAsync(string filters)
        {
            return ConfigListAsync(filters, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// List configs
        /// </summary>
        /// <param name="filters">A JSON encoded value of the filters (a `map[string][]string`) to
        /// <br/>process on the configs list.
        /// <br/>
        /// <br/>Available filters:
        /// <br/>
        /// <br/>- `id=&lt;config id&gt;`
        /// <br/>- `label=&lt;key&gt; or label=&lt;key&gt;=value`
        /// <br/>- `name=&lt;config name&gt;`
        /// <br/>- `names=&lt;config name&gt;`</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Config>> ConfigListAsync(string filters, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "configs"
                    urlBuilder_.Append("configs");
                    urlBuilder_.Append('?');
                    if (filters != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("filters")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(filters, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<Config>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("node is not part of a swarm", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Create a config
        /// </summary>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<IdResponse> ConfigCreateAsync(Body6 body)
        {
            return ConfigCreateAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create a config
        /// </summary>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<IdResponse> ConfigCreateAsync(Body6 body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "configs/create"
                    urlBuilder_.Append("configs/create");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 201)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<IdResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 409)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("name conflicts with an existing object", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("node is not part of a swarm", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Inspect a config
        /// </summary>
        /// <param name="id">ID of the config</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Config> ConfigInspectAsync(string id)
        {
            return ConfigInspectAsync(id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Inspect a config
        /// </summary>
        /// <param name="id">ID of the config</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Config> ConfigInspectAsync(string id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "configs/{id}"
                    urlBuilder_.Append("configs/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Config>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("config not found", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("node is not part of a swarm", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete a config
        /// </summary>
        /// <param name="id">ID of the config</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ConfigDeleteAsync(string id)
        {
            return ConfigDeleteAsync(id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete a config
        /// </summary>
        /// <param name="id">ID of the config</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ConfigDeleteAsync(string id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "configs/{id}"
                    urlBuilder_.Append("configs/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("config not found", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("node is not part of a swarm", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Update a Config
        /// </summary>
        /// <param name="id">The ID or name of the config</param>
        /// <param name="body">The spec of the config to update. Currently, only the Labels field
        /// <br/>can be updated. All other fields must remain unchanged from the
        /// <br/>[ConfigInspect endpoint](#operation/ConfigInspect) response values.</param>
        /// <param name="version">The version number of the config object being updated. This is
        /// <br/>required to avoid conflicting writes.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ConfigUpdateAsync(string id, ConfigSpec body, long version)
        {
            return ConfigUpdateAsync(id, body, version, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update a Config
        /// </summary>
        /// <param name="id">The ID or name of the config</param>
        /// <param name="body">The spec of the config to update. Currently, only the Labels field
        /// <br/>can be updated. All other fields must remain unchanged from the
        /// <br/>[ConfigInspect endpoint](#operation/ConfigInspect) response values.</param>
        /// <param name="version">The version number of the config object being updated. This is
        /// <br/>required to avoid conflicting writes.</param>
        /// <returns>no error</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ConfigUpdateAsync(string id, ConfigSpec body, long version, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            if (version == null)
                throw new System.ArgumentNullException("version");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "configs/{id}/update"
                    urlBuilder_.Append("configs/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/update");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("version")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("bad parameter", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("no such config", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("node is not part of a swarm", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get image information from the registry
        /// </summary>
        /// <remarks>
        /// Return image digest and platform information by contacting the registry.
        /// </remarks>
        /// <param name="name">Image name or id</param>
        /// <returns>descriptor and platform information</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<DistributionInspect> DistributionInspectAsync(string name)
        {
            return DistributionInspectAsync(name, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get image information from the registry
        /// </summary>
        /// <remarks>
        /// Return image digest and platform information by contacting the registry.
        /// </remarks>
        /// <param name="name">Image name or id</param>
        /// <returns>descriptor and platform information</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<DistributionInspect> DistributionInspectAsync(string name, System.Threading.CancellationToken cancellationToken)
        {
            if (name == null)
                throw new System.ArgumentNullException("name");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "distribution/{name}/json"
                    urlBuilder_.Append("distribution/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/json");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DistributionInspect>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Failed authentication or no image found", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("Server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Initialize interactive session
        /// </summary>
        /// <remarks>
        /// Start a new interactive session with a server. Session allows server to
        /// <br/>call back to the client for advanced capabilities.
        /// <br/>
        /// <br/>### Hijacking
        /// <br/>
        /// <br/>This endpoint hijacks the HTTP connection to HTTP2 transport that allows
        /// <br/>the client to expose gPRC services on that connection.
        /// <br/>
        /// <br/>For example, the client sends this request to upgrade the connection:
        /// <br/>
        /// <br/>```
        /// <br/>POST /session HTTP/1.1
        /// <br/>Upgrade: h2c
        /// <br/>Connection: Upgrade
        /// <br/>```
        /// <br/>
        /// <br/>The Docker daemon responds with a `101 UPGRADED` response follow with
        /// <br/>the raw stream:
        /// <br/>
        /// <br/>```
        /// <br/>HTTP/1.1 101 UPGRADED
        /// <br/>Connection: Upgrade
        /// <br/>Upgrade: h2c
        /// <br/>```
        /// </remarks>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SessionAsync()
        {
            return SessionAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Initialize interactive session
        /// </summary>
        /// <remarks>
        /// Start a new interactive session with a server. Session allows server to
        /// <br/>call back to the client for advanced capabilities.
        /// <br/>
        /// <br/>### Hijacking
        /// <br/>
        /// <br/>This endpoint hijacks the HTTP connection to HTTP2 transport that allows
        /// <br/>the client to expose gPRC services on that connection.
        /// <br/>
        /// <br/>For example, the client sends this request to upgrade the connection:
        /// <br/>
        /// <br/>```
        /// <br/>POST /session HTTP/1.1
        /// <br/>Upgrade: h2c
        /// <br/>Connection: Upgrade
        /// <br/>```
        /// <br/>
        /// <br/>The Docker daemon responds with a `101 UPGRADED` response follow with
        /// <br/>the raw stream:
        /// <br/>
        /// <br/>```
        /// <br/>HTTP/1.1 101 UPGRADED
        /// <br/>Connection: Upgrade
        /// <br/>Upgrade: h2c
        /// <br/>```
        /// </remarks>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SessionAsync(System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/vnd.docker.raw-stream");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "session"
                    urlBuilder_.Append("session");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 101)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("no error, hijacking successful", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("bad parameter", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorResponse>("server error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Threading.CancellationToken cancellationToken)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = System.Text.Json.JsonSerializer.Deserialize<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (System.Text.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    {
                        var typedBody = await System.Text.Json.JsonSerializer.DeserializeAsync<T>(responseStream, JsonSerializerSettings, cancellationToken).ConfigureAwait(false);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (System.Text.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value == null)
            {
                return "";
            }

            if (value is System.Enum)
            {
                var name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute)) 
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }

                    var converted = System.Convert.ToString(System.Convert.ChangeType(value, System.Enum.GetUnderlyingType(value.GetType()), cultureInfo));
                    return converted == null ? string.Empty : converted;
                }
            }
            else if (value is bool) 
            {
                return System.Convert.ToString((bool)value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[]) value);
            }
            else if (value is string[])
            {
                return string.Join(",", (string[])value);
            }
            else if (value.GetType().IsArray)
            {
                var valueArray = (System.Array)value;
                var valueTextArray = new string[valueArray.Length];
                for (var i = 0; i < valueArray.Length; i++)
                {
                    valueTextArray[i] = ConvertToString(valueArray.GetValue(i), cultureInfo);
                }
                return string.Join(",", valueTextArray);
            }

            var result = System.Convert.ToString(value, cultureInfo);
            return result == null ? "" : result;
        }
    }

    /// <summary>
    /// An open port on a container
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Port
    {
        /// <summary>
        /// Host IP address that the container's port is mapped to
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("IP")]
        public string IP { get; set; }

        /// <summary>
        /// Port on the container
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("PrivatePort")]
        public int PrivatePort { get; set; }

        /// <summary>
        /// Port exposed on the host
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("PublicPort")]
        public int? PublicPort { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Type")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public PortType Type { get; set; }

    }

    /// <summary>
    /// MountPoint represents a mount point configuration inside the container.
    /// <br/>This is used for reporting the mountpoints in use by a container.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class MountPoint
    {
        /// <summary>
        /// The mount type:
        /// <br/>
        /// <br/>- `bind` a mount of a file or directory from the host into the container.
        /// <br/>- `volume` a docker volume with the given `Name`.
        /// <br/>- `tmpfs` a `tmpfs`.
        /// <br/>- `npipe` a named pipe from the host into the container.
        /// <br/>- `cluster` a Swarm cluster volume
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Type")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public MountPointType? Type { get; set; }

        /// <summary>
        /// Name is the name reference to the underlying data defined by `Source`
        /// <br/>e.g., the volume name.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Name")]
        public string Name { get; set; }

        /// <summary>
        /// Source location of the mount.
        /// <br/>
        /// <br/>For volumes, this contains the storage location of the volume (within
        /// <br/>`/var/lib/docker/volumes/`). For bind-mounts, and `npipe`, this contains
        /// <br/>the source (host) part of the bind-mount. For `tmpfs` mount points, this
        /// <br/>field is empty.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Source")]
        public string Source { get; set; }

        /// <summary>
        /// Destination is the path relative to the container root (`/`) where
        /// <br/>the `Source` is mounted inside the container.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Destination")]
        public string Destination { get; set; }

        /// <summary>
        /// Driver is the volume driver used to create the volume (if it is a volume).
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Driver")]
        public string Driver { get; set; }

        /// <summary>
        /// Mode is a comma separated list of options supplied by the user when
        /// <br/>creating the bind/volume mount.
        /// <br/>
        /// <br/>The default is platform-specific (`"z"` on Linux, empty on Windows).
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Mode")]
        public string Mode { get; set; }

        /// <summary>
        /// Whether the mount is mounted writable (read-write).
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("RW")]
        public bool? RW { get; set; }

        /// <summary>
        /// Propagation describes how mounts are propagated from the host into the
        /// <br/>mount point, and vice-versa. Refer to the [Linux kernel documentation](https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt)
        /// <br/>for details. This field is not used on Windows.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Propagation")]
        public string Propagation { get; set; }

    }

    /// <summary>
    /// A device mapping between the host and container
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class DeviceMapping
    {

        [System.Text.Json.Serialization.JsonPropertyName("PathOnHost")]
        public string PathOnHost { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("PathInContainer")]
        public string PathInContainer { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("CgroupPermissions")]
        public string CgroupPermissions { get; set; }

    }

    /// <summary>
    /// A request for devices to be sent to device drivers
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class DeviceRequest
    {

        [System.Text.Json.Serialization.JsonPropertyName("Driver")]
        public string Driver { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Count")]
        public int? Count { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("DeviceIDs")]
        public System.Collections.Generic.ICollection<string> DeviceIDs { get; set; }

        /// <summary>
        /// A list of capabilities; an OR list of AND lists of capabilities.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Capabilities")]
        public System.Collections.Generic.ICollection<System.Collections.Generic.ICollection<string>> Capabilities { get; set; }

        /// <summary>
        /// Driver-specific options, specified as a key/value pairs. These options
        /// <br/>are passed directly to the driver.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Options")]
        public System.Collections.Generic.IDictionary<string, string> Options { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ThrottleDevice
    {
        /// <summary>
        /// Device path
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Path")]
        public string Path { get; set; }

        /// <summary>
        /// Rate
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Rate")]
        [System.ComponentModel.DataAnnotations.Range(0D, double.MaxValue)]
        public long? Rate { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Mount
    {
        /// <summary>
        /// Container path.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Target")]
        public string Target { get; set; }

        /// <summary>
        /// Mount source (e.g. a volume name, a host path).
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Source")]
        public string Source { get; set; }

        /// <summary>
        /// The mount type. Available types:
        /// <br/>
        /// <br/>- `bind` Mounts a file or directory from the host into the container. Must exist prior to creating the container.
        /// <br/>- `volume` Creates a volume with the given name and options (or uses a pre-existing volume with the same name and options). These are **not** removed when the container is removed.
        /// <br/>- `tmpfs` Create a tmpfs with the given options. The mount source cannot be specified for tmpfs.
        /// <br/>- `npipe` Mounts a named pipe from the host into the container. Must exist prior to creating the container.
        /// <br/>- `cluster` a Swarm cluster volume
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Type")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public MountType? Type { get; set; }

        /// <summary>
        /// Whether the mount should be read-only.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ReadOnly")]
        public bool? ReadOnly { get; set; }

        /// <summary>
        /// The consistency requirement for the mount: `default`, `consistent`, `cached`, or `delegated`.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Consistency")]
        public string Consistency { get; set; }

        /// <summary>
        /// Optional configuration for the `bind` type.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("BindOptions")]
        public BindOptions BindOptions { get; set; }

        /// <summary>
        /// Optional configuration for the `volume` type.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("VolumeOptions")]
        public VolumeOptions VolumeOptions { get; set; }

        /// <summary>
        /// Optional configuration for the `tmpfs` type.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("TmpfsOptions")]
        public TmpfsOptions TmpfsOptions { get; set; }

    }

    /// <summary>
    /// The behavior to apply when the container exits. The default is not to
    /// <br/>restart.
    /// <br/>
    /// <br/>An ever increasing delay (double the previous delay, starting at 100ms) is
    /// <br/>added before each restart to prevent flooding the server.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class RestartPolicy
    {
        /// <summary>
        /// - Empty string means not to restart
        /// <br/>- `no` Do not automatically restart
        /// <br/>- `always` Always restart
        /// <br/>- `unless-stopped` Restart always except when the user has manually stopped the container
        /// <br/>- `on-failure` Restart only when the container exit code is non-zero
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Name")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public RestartPolicyName? Name { get; set; }

        /// <summary>
        /// If `on-failure` is used, the number of times to retry before giving up.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("MaximumRetryCount")]
        public int? MaximumRetryCount { get; set; }

    }

    /// <summary>
    /// A container's resources (cgroups config, ulimits, etc)
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Resources
    {
        /// <summary>
        /// An integer value representing this container's relative CPU weight
        /// <br/>versus other containers.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("CpuShares")]
        public int? CpuShares { get; set; }

        /// <summary>
        /// Memory limit in bytes.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Memory")]
        public long? Memory { get; set; } = 0L;

        /// <summary>
        /// Path to `cgroups` under which the container's `cgroup` is created. If
        /// <br/>the path is not absolute, the path is considered to be relative to the
        /// <br/>`cgroups` path of the init process. Cgroups are created if they do not
        /// <br/>already exist.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("CgroupParent")]
        public string CgroupParent { get; set; }

        /// <summary>
        /// Block IO weight (relative weight).
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("BlkioWeight")]
        [System.ComponentModel.DataAnnotations.Range(0, 1000)]
        public int? BlkioWeight { get; set; }

        /// <summary>
        /// Block IO weight (relative device weight) in the form:
        /// <br/>
        /// <br/>```
        /// <br/>[{"Path": "device_path", "Weight": weight}]
        /// <br/>```
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("BlkioWeightDevice")]
        public System.Collections.Generic.ICollection<BlkioWeightDevice> BlkioWeightDevice { get; set; }

        /// <summary>
        /// Limit read rate (bytes per second) from a device, in the form:
        /// <br/>
        /// <br/>```
        /// <br/>[{"Path": "device_path", "Rate": rate}]
        /// <br/>```
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("BlkioDeviceReadBps")]
        public System.Collections.Generic.ICollection<ThrottleDevice> BlkioDeviceReadBps { get; set; }

        /// <summary>
        /// Limit write rate (bytes per second) to a device, in the form:
        /// <br/>
        /// <br/>```
        /// <br/>[{"Path": "device_path", "Rate": rate}]
        /// <br/>```
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("BlkioDeviceWriteBps")]
        public System.Collections.Generic.ICollection<ThrottleDevice> BlkioDeviceWriteBps { get; set; }

        /// <summary>
        /// Limit read rate (IO per second) from a device, in the form:
        /// <br/>
        /// <br/>```
        /// <br/>[{"Path": "device_path", "Rate": rate}]
        /// <br/>```
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("BlkioDeviceReadIOps")]
        public System.Collections.Generic.ICollection<ThrottleDevice> BlkioDeviceReadIOps { get; set; }

        /// <summary>
        /// Limit write rate (IO per second) to a device, in the form:
        /// <br/>
        /// <br/>```
        /// <br/>[{"Path": "device_path", "Rate": rate}]
        /// <br/>```
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("BlkioDeviceWriteIOps")]
        public System.Collections.Generic.ICollection<ThrottleDevice> BlkioDeviceWriteIOps { get; set; }

        /// <summary>
        /// The length of a CPU period in microseconds.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("CpuPeriod")]
        public long? CpuPeriod { get; set; }

        /// <summary>
        /// Microseconds of CPU time that the container can get in a CPU period.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("CpuQuota")]
        public long? CpuQuota { get; set; }

        /// <summary>
        /// The length of a CPU real-time period in microseconds. Set to 0 to
        /// <br/>allocate no time allocated to real-time tasks.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("CpuRealtimePeriod")]
        public long? CpuRealtimePeriod { get; set; }

        /// <summary>
        /// The length of a CPU real-time runtime in microseconds. Set to 0 to
        /// <br/>allocate no time allocated to real-time tasks.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("CpuRealtimeRuntime")]
        public long? CpuRealtimeRuntime { get; set; }

        /// <summary>
        /// CPUs in which to allow execution (e.g., `0-3`, `0,1`).
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("CpusetCpus")]
        public string CpusetCpus { get; set; }

        /// <summary>
        /// Memory nodes (MEMs) in which to allow execution (0-3, 0,1). Only
        /// <br/>effective on NUMA systems.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("CpusetMems")]
        public string CpusetMems { get; set; }

        /// <summary>
        /// A list of devices to add to the container.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Devices")]
        public System.Collections.Generic.ICollection<DeviceMapping> Devices { get; set; }

        /// <summary>
        /// a list of cgroup rules to apply to the container
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("DeviceCgroupRules")]
        public System.Collections.Generic.ICollection<string> DeviceCgroupRules { get; set; }

        /// <summary>
        /// A list of requests for devices to be sent to device drivers.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("DeviceRequests")]
        public System.Collections.Generic.ICollection<DeviceRequest> DeviceRequests { get; set; }

        /// <summary>
        /// Hard limit for kernel TCP buffer memory (in bytes). Depending on the
        /// <br/>OCI runtime in use, this option may be ignored. It is no longer supported
        /// <br/>by the default (runc) runtime.
        /// <br/>
        /// <br/>This field is omitted when empty.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("KernelMemoryTCP")]
        public long? KernelMemoryTCP { get; set; }

        /// <summary>
        /// Memory soft limit in bytes.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("MemoryReservation")]
        public long? MemoryReservation { get; set; }

        /// <summary>
        /// Total memory limit (memory + swap). Set as `-1` to enable unlimited
        /// <br/>swap.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("MemorySwap")]
        public long? MemorySwap { get; set; }

        /// <summary>
        /// Tune a container's memory swappiness behavior. Accepts an integer
        /// <br/>between 0 and 100.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("MemorySwappiness")]
        [System.ComponentModel.DataAnnotations.Range(0D, 100D)]
        public long? MemorySwappiness { get; set; }

        /// <summary>
        /// CPU quota in units of 10&lt;sup&gt;-9&lt;/sup&gt; CPUs.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("NanoCpus")]
        public long? NanoCpus { get; set; }

        /// <summary>
        /// Disable OOM Killer for the container.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("OomKillDisable")]
        public bool? OomKillDisable { get; set; }

        /// <summary>
        /// Run an init inside the container that forwards signals and reaps
        /// <br/>processes. This field is omitted if empty, and the default (as
        /// <br/>configured on the daemon) is used.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Init")]
        public bool? Init { get; set; }

        /// <summary>
        /// Tune a container's PIDs limit. Set `0` or `-1` for unlimited, or `null`
        /// <br/>to not change.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("PidsLimit")]
        public long? PidsLimit { get; set; }

        /// <summary>
        /// A list of resource limits to set in the container. For example:
        /// <br/>
        /// <br/>```
        /// <br/>{"Name": "nofile", "Soft": 1024, "Hard": 2048}
        /// <br/>```
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Ulimits")]
        public System.Collections.Generic.ICollection<Ulimits> Ulimits { get; set; }

        /// <summary>
        /// The number of usable CPUs (Windows only).
        /// <br/>
        /// <br/>On Windows Server containers, the processor resource controls are
        /// <br/>mutually exclusive. The order of precedence is `CPUCount` first, then
        /// <br/>`CPUShares`, and `CPUPercent` last.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("CpuCount")]
        public long? CpuCount { get; set; }

        /// <summary>
        /// The usable percentage of the available CPUs (Windows only).
        /// <br/>
        /// <br/>On Windows Server containers, the processor resource controls are
        /// <br/>mutually exclusive. The order of precedence is `CPUCount` first, then
        /// <br/>`CPUShares`, and `CPUPercent` last.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("CpuPercent")]
        public long? CpuPercent { get; set; }

        /// <summary>
        /// Maximum IOps for the container system drive (Windows only)
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("IOMaximumIOps")]
        public long? IOMaximumIOps { get; set; }

        /// <summary>
        /// Maximum IO in bytes per second for the container system drive
        /// <br/>(Windows only).
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("IOMaximumBandwidth")]
        public long? IOMaximumBandwidth { get; set; }

    }

    /// <summary>
    /// An object describing a limit on resources which can be requested by a task.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Limit
    {

        [System.Text.Json.Serialization.JsonPropertyName("NanoCPUs")]
        public long? NanoCPUs { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("MemoryBytes")]
        public long? MemoryBytes { get; set; }

        /// <summary>
        /// Limits the maximum number of PIDs in the container. Set `0` for unlimited.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Pids")]
        public long? Pids { get; set; } = 0L;

    }

    /// <summary>
    /// An object describing the resources which can be advertised by a node and
    /// <br/>requested by a task.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ResourceObject
    {

        [System.Text.Json.Serialization.JsonPropertyName("NanoCPUs")]
        public long? NanoCPUs { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("MemoryBytes")]
        public long? MemoryBytes { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("GenericResources")]
        public GenericResources GenericResources { get; set; }

    }

    /// <summary>
    /// User-defined resources can be either Integer resources (e.g, `SSD=3`) or
    /// <br/>String resources (e.g, `GPU=UUID1`).
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class GenericResources : System.Collections.ObjectModel.Collection<Anonymous2>
    {

    }

    /// <summary>
    /// A test to perform to check that the container is healthy.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class HealthConfig
    {
        /// <summary>
        /// The test to perform. Possible values are:
        /// <br/>
        /// <br/>- `[]` inherit healthcheck from image or parent image
        /// <br/>- `["NONE"]` disable healthcheck
        /// <br/>- `["CMD", args...]` exec arguments directly
        /// <br/>- `["CMD-SHELL", command]` run command with system's default shell
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Test")]
        public System.Collections.Generic.ICollection<string> Test { get; set; }

        /// <summary>
        /// The time to wait between checks in nanoseconds. It should be 0 or at
        /// <br/>least 1000000 (1 ms). 0 means inherit.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Interval")]
        public long? Interval { get; set; }

        /// <summary>
        /// The time to wait before considering the check to have hung. It should
        /// <br/>be 0 or at least 1000000 (1 ms). 0 means inherit.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Timeout")]
        public long? Timeout { get; set; }

        /// <summary>
        /// The number of consecutive failures needed to consider a container as
        /// <br/>unhealthy. 0 means inherit.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Retries")]
        public int? Retries { get; set; }

        /// <summary>
        /// Start period for the container to initialize before starting
        /// <br/>health-retries countdown in nanoseconds. It should be 0 or at least
        /// <br/>1000000 (1 ms). 0 means inherit.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("StartPeriod")]
        public long? StartPeriod { get; set; }

        /// <summary>
        /// The time to wait between checks in nanoseconds during the start period.
        /// <br/>It should be 0 or at least 1000000 (1 ms). 0 means inherit.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("StartInterval")]
        public long? StartInterval { get; set; }

    }

    /// <summary>
    /// Health stores information about the container's healthcheck results.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Health
    {
        /// <summary>
        /// Status is one of `none`, `starting`, `healthy` or `unhealthy`
        /// <br/>
        /// <br/>- "none"      Indicates there is no healthcheck
        /// <br/>- "starting"  Starting indicates that the container is not yet ready
        /// <br/>- "healthy"   Healthy indicates that the container is running correctly
        /// <br/>- "unhealthy" Unhealthy indicates that the container has a problem
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Status")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public HealthStatus? Status { get; set; }

        /// <summary>
        /// FailingStreak is the number of consecutive failures
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("FailingStreak")]
        public int? FailingStreak { get; set; }

        /// <summary>
        /// Log contains the last few results (oldest first)
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Log")]
        public System.Collections.Generic.ICollection<HealthcheckResult> Log { get; set; }

    }

    /// <summary>
    /// HealthcheckResult stores information about a single run of a healthcheck probe
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class HealthcheckResult
    {
        /// <summary>
        /// Date and time at which this check started in
        /// <br/>[RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Start")]
        public System.DateTimeOffset? Start { get; set; }

        /// <summary>
        /// Date and time at which this check ended in
        /// <br/>[RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("End")]
        public string End { get; set; }

        /// <summary>
        /// ExitCode meanings:
        /// <br/>
        /// <br/>- `0` healthy
        /// <br/>- `1` unhealthy
        /// <br/>- `2` reserved (considered unhealthy)
        /// <br/>- other values: error running probe
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ExitCode")]
        public int? ExitCode { get; set; }

        /// <summary>
        /// Output from last check
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Output")]
        public string Output { get; set; }

    }

    /// <summary>
    /// Container configuration that depends on the host we are running on
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class HostConfig : Resources
    {
        /// <summary>
        /// A list of volume bindings for this container. Each volume binding
        /// <br/>is a string in one of these forms:
        /// <br/>
        /// <br/>- `host-src:container-dest[:options]` to bind-mount a host path
        /// <br/>  into the container. Both `host-src`, and `container-dest` must
        /// <br/>  be an _absolute_ path.
        /// <br/>- `volume-name:container-dest[:options]` to bind-mount a volume
        /// <br/>  managed by a volume driver into the container. `container-dest`
        /// <br/>  must be an _absolute_ path.
        /// <br/>
        /// <br/>`options` is an optional, comma-delimited list of:
        /// <br/>
        /// <br/>- `nocopy` disables automatic copying of data from the container
        /// <br/>  path to the volume. The `nocopy` flag only applies to named volumes.
        /// <br/>- `[ro|rw]` mounts a volume read-only or read-write, respectively.
        /// <br/>  If omitted or set to `rw`, volumes are mounted read-write.
        /// <br/>- `[z|Z]` applies SELinux labels to allow or deny multiple containers
        /// <br/>  to read and write to the same volume.
        /// <br/>    - `z`: a _shared_ content label is applied to the content. This
        /// <br/>      label indicates that multiple containers can share the volume
        /// <br/>      content, for both reading and writing.
        /// <br/>    - `Z`: a _private unshared_ label is applied to the content.
        /// <br/>      This label indicates that only the current container can use
        /// <br/>      a private volume. Labeling systems such as SELinux require
        /// <br/>      proper labels to be placed on volume content that is mounted
        /// <br/>      into a container. Without a label, the security system can
        /// <br/>      prevent a container's processes from using the content. By
        /// <br/>      default, the labels set by the host operating system are not
        /// <br/>      modified.
        /// <br/>- `[[r]shared|[r]slave|[r]private]` specifies mount
        /// <br/>  [propagation behavior](https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt).
        /// <br/>  This only applies to bind-mounted volumes, not internal volumes
        /// <br/>  or named volumes. Mount propagation requires the source mount
        /// <br/>  point (the location where the source directory is mounted in the
        /// <br/>  host operating system) to have the correct propagation properties.
        /// <br/>  For shared volumes, the source mount point must be set to `shared`.
        /// <br/>  For slave volumes, the mount must be set to either `shared` or
        /// <br/>  `slave`.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Binds")]
        public System.Collections.Generic.ICollection<string> Binds { get; set; }

        /// <summary>
        /// Path to a file where the container ID is written
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ContainerIDFile")]
        public string ContainerIDFile { get; set; }

        /// <summary>
        /// The logging configuration for this container
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("LogConfig")]
        public LogConfig LogConfig { get; set; }

        /// <summary>
        /// Network mode to use for this container. Supported standard values
        /// <br/>are: `bridge`, `host`, `none`, and `container:&lt;name|id&gt;`. Any
        /// <br/>other value is taken as a custom network's name to which this
        /// <br/>container should connect to.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("NetworkMode")]
        public string NetworkMode { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("PortBindings")]
        public PortMap PortBindings { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("RestartPolicy")]
        public RestartPolicy RestartPolicy { get; set; }

        /// <summary>
        /// Automatically remove the container when the container's process
        /// <br/>exits. This has no effect if `RestartPolicy` is set.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("AutoRemove")]
        public bool? AutoRemove { get; set; }

        /// <summary>
        /// Driver that this container uses to mount volumes.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("VolumeDriver")]
        public string VolumeDriver { get; set; }

        /// <summary>
        /// A list of volumes to inherit from another container, specified in
        /// <br/>the form `&lt;container name&gt;[:&lt;ro|rw&gt;]`.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("VolumesFrom")]
        public System.Collections.Generic.ICollection<string> VolumesFrom { get; set; }

        /// <summary>
        /// Specification for mounts to be added to the container.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Mounts")]
        public System.Collections.Generic.ICollection<Mount> Mounts { get; set; }

        /// <summary>
        /// Initial console size, as an `[height, width]` array.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ConsoleSize")]
        [System.ComponentModel.DataAnnotations.MinLength(2)]
        [System.ComponentModel.DataAnnotations.MaxLength(2)]
        public System.Collections.Generic.ICollection<int> ConsoleSize { get; set; }

        /// <summary>
        /// Arbitrary non-identifying metadata attached to container and
        /// <br/>provided to the runtime when the container is started.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Annotations")]
        public System.Collections.Generic.IDictionary<string, string> Annotations { get; set; }

        /// <summary>
        /// A list of kernel capabilities to add to the container. Conflicts
        /// <br/>with option 'Capabilities'.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("CapAdd")]
        public System.Collections.Generic.ICollection<string> CapAdd { get; set; }

        /// <summary>
        /// A list of kernel capabilities to drop from the container. Conflicts
        /// <br/>with option 'Capabilities'.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("CapDrop")]
        public System.Collections.Generic.ICollection<string> CapDrop { get; set; }

        /// <summary>
        /// cgroup namespace mode for the container. Possible values are:
        /// <br/>
        /// <br/>- `"private"`: the container runs in its own private cgroup namespace
        /// <br/>- `"host"`: use the host system's cgroup namespace
        /// <br/>
        /// <br/>If not specified, the daemon default is used, which can either be `"private"`
        /// <br/>or `"host"`, depending on daemon version, kernel support and configuration.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("CgroupnsMode")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public HostConfigCgroupnsMode? CgroupnsMode { get; set; }

        /// <summary>
        /// A list of DNS servers for the container to use.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Dns")]
        public System.Collections.Generic.ICollection<string> Dns { get; set; }

        /// <summary>
        /// A list of DNS options.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("DnsOptions")]
        public System.Collections.Generic.ICollection<string> DnsOptions { get; set; }

        /// <summary>
        /// A list of DNS search domains.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("DnsSearch")]
        public System.Collections.Generic.ICollection<string> DnsSearch { get; set; }

        /// <summary>
        /// A list of hostnames/IP mappings to add to the container's `/etc/hosts`
        /// <br/>file. Specified in the form `["hostname:IP"]`.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ExtraHosts")]
        public System.Collections.Generic.ICollection<string> ExtraHosts { get; set; }

        /// <summary>
        /// A list of additional groups that the container process will run as.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("GroupAdd")]
        public System.Collections.Generic.ICollection<string> GroupAdd { get; set; }

        /// <summary>
        /// IPC sharing mode for the container. Possible values are:
        /// <br/>
        /// <br/>- `"none"`: own private IPC namespace, with /dev/shm not mounted
        /// <br/>- `"private"`: own private IPC namespace
        /// <br/>- `"shareable"`: own private IPC namespace, with a possibility to share it with other containers
        /// <br/>- `"container:&lt;name|id&gt;"`: join another (shareable) container's IPC namespace
        /// <br/>- `"host"`: use the host system's IPC namespace
        /// <br/>
        /// <br/>If not specified, daemon default is used, which can either be `"private"`
        /// <br/>or `"shareable"`, depending on daemon version and configuration.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("IpcMode")]
        public string IpcMode { get; set; }

        /// <summary>
        /// Cgroup to use for the container.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Cgroup")]
        public string Cgroup { get; set; }

        /// <summary>
        /// A list of links for the container in the form `container_name:alias`.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Links")]
        public System.Collections.Generic.ICollection<string> Links { get; set; }

        /// <summary>
        /// An integer value containing the score given to the container in
        /// <br/>order to tune OOM killer preferences.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("OomScoreAdj")]
        public int? OomScoreAdj { get; set; }

        /// <summary>
        /// Set the PID (Process) Namespace mode for the container. It can be
        /// <br/>either:
        /// <br/>
        /// <br/>- `"container:&lt;name|id&gt;"`: joins another container's PID namespace
        /// <br/>- `"host"`: use the host's PID namespace inside the container
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("PidMode")]
        public string PidMode { get; set; }

        /// <summary>
        /// Gives the container full access to the host.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Privileged")]
        public bool? Privileged { get; set; }

        /// <summary>
        /// Allocates an ephemeral host port for all of a container's
        /// <br/>exposed ports.
        /// <br/>
        /// <br/>Ports are de-allocated when the container stops and allocated when
        /// <br/>the container starts. The allocated port might be changed when
        /// <br/>restarting the container.
        /// <br/>
        /// <br/>The port is selected from the ephemeral port range that depends on
        /// <br/>the kernel. For example, on Linux the range is defined by
        /// <br/>`/proc/sys/net/ipv4/ip_local_port_range`.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("PublishAllPorts")]
        public bool? PublishAllPorts { get; set; }

        /// <summary>
        /// Mount the container's root filesystem as read only.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ReadonlyRootfs")]
        public bool? ReadonlyRootfs { get; set; }

        /// <summary>
        /// A list of string values to customize labels for MLS systems, such
        /// <br/>as SELinux.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("SecurityOpt")]
        public System.Collections.Generic.ICollection<string> SecurityOpt { get; set; }

        /// <summary>
        /// Storage driver options for this container, in the form `{"size": "120G"}`.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("StorageOpt")]
        public System.Collections.Generic.IDictionary<string, string> StorageOpt { get; set; }

        /// <summary>
        /// A map of container directories which should be replaced by tmpfs
        /// <br/>mounts, and their corresponding mount options. For example:
        /// <br/>
        /// <br/>```
        /// <br/>{ "/run": "rw,noexec,nosuid,size=65536k" }
        /// <br/>```
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Tmpfs")]
        public System.Collections.Generic.IDictionary<string, string> Tmpfs { get; set; }

        /// <summary>
        /// UTS namespace to use for the container.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("UTSMode")]
        public string UTSMode { get; set; }

        /// <summary>
        /// Sets the usernamespace mode for the container when usernamespace
        /// <br/>remapping option is enabled.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("UsernsMode")]
        public string UsernsMode { get; set; }

        /// <summary>
        /// Size of `/dev/shm` in bytes. If omitted, the system uses 64MB.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ShmSize")]
        [System.ComponentModel.DataAnnotations.Range(0D, double.MaxValue)]
        public long? ShmSize { get; set; }

        /// <summary>
        /// A list of kernel parameters (sysctls) to set in the container.
        /// <br/>For example:
        /// <br/>
        /// <br/>```
        /// <br/>{"net.ipv4.ip_forward": "1"}
        /// <br/>```
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Sysctls")]
        public System.Collections.Generic.IDictionary<string, string> Sysctls { get; set; }

        /// <summary>
        /// Runtime to use with this container.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Runtime")]
        public string Runtime { get; set; }

        /// <summary>
        /// Isolation technology of the container. (Windows only)
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Isolation")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public HostConfigIsolation? Isolation { get; set; }

        /// <summary>
        /// The list of paths to be masked inside the container (this overrides
        /// <br/>the default set of paths).
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("MaskedPaths")]
        public System.Collections.Generic.ICollection<string> MaskedPaths { get; set; }

        /// <summary>
        /// The list of paths to be set as read-only inside the container
        /// <br/>(this overrides the default set of paths).
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ReadonlyPaths")]
        public System.Collections.Generic.ICollection<string> ReadonlyPaths { get; set; }

    }

    /// <summary>
    /// Configuration for a container that is portable between hosts.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ContainerConfig
    {
        /// <summary>
        /// The hostname to use for the container, as a valid RFC 1123 hostname.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Hostname")]
        public string Hostname { get; set; }

        /// <summary>
        /// The domain name to use for the container.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Domainname")]
        public string Domainname { get; set; }

        /// <summary>
        /// The user that commands are run as inside the container.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("User")]
        public string User { get; set; }

        /// <summary>
        /// Whether to attach to `stdin`.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("AttachStdin")]
        public bool? AttachStdin { get; set; } = false;

        /// <summary>
        /// Whether to attach to `stdout`.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("AttachStdout")]
        public bool? AttachStdout { get; set; } = true;

        /// <summary>
        /// Whether to attach to `stderr`.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("AttachStderr")]
        public bool? AttachStderr { get; set; } = true;

        /// <summary>
        /// An object mapping ports to an empty object in the form:
        /// <br/>
        /// <br/>`{"&lt;port&gt;/&lt;tcp|udp|sctp&gt;": {}}`
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ExposedPorts")]
        public System.Collections.Generic.IDictionary<string, Anonymous3> ExposedPorts { get; set; }

        /// <summary>
        /// Attach standard streams to a TTY, including `stdin` if it is not closed.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Tty")]
        public bool? Tty { get; set; } = false;

        /// <summary>
        /// Open `stdin`
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("OpenStdin")]
        public bool? OpenStdin { get; set; } = false;

        /// <summary>
        /// Close `stdin` after one attached client disconnects
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("StdinOnce")]
        public bool? StdinOnce { get; set; } = false;

        /// <summary>
        /// A list of environment variables to set inside the container in the
        /// <br/>form `["VAR=value", ...]`. A variable without `=` is removed from the
        /// <br/>environment, rather than to have an empty value.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Env")]
        public System.Collections.Generic.ICollection<string> Env { get; set; }

        /// <summary>
        /// Command to run specified as a string or an array of strings.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Cmd")]
        public System.Collections.Generic.ICollection<string> Cmd { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Healthcheck")]
        public HealthConfig Healthcheck { get; set; }

        /// <summary>
        /// Command is already escaped (Windows only)
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ArgsEscaped")]
        public bool? ArgsEscaped { get; set; } = false;

        /// <summary>
        /// The name (or reference) of the image to use when creating the container,
        /// <br/>or which was used when the container was created.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Image")]
        public string Image { get; set; }

        /// <summary>
        /// An object mapping mount point paths inside the container to empty
        /// <br/>objects.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Volumes")]
        public System.Collections.Generic.IDictionary<string, Anonymous4> Volumes { get; set; }

        /// <summary>
        /// The working directory for commands to run in.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("WorkingDir")]
        public string WorkingDir { get; set; }

        /// <summary>
        /// The entry point for the container as a string or an array of strings.
        /// <br/>
        /// <br/>If the array consists of exactly one empty string (`[""]`) then the
        /// <br/>entry point is reset to system default (i.e., the entry point used by
        /// <br/>docker when there is no `ENTRYPOINT` instruction in the `Dockerfile`).
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Entrypoint")]
        public System.Collections.Generic.ICollection<string> Entrypoint { get; set; }

        /// <summary>
        /// Disable networking for the container.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("NetworkDisabled")]
        public bool? NetworkDisabled { get; set; }

        /// <summary>
        /// MAC address of the container.
        /// <br/>
        /// <br/>Deprecated: this field is deprecated in API v1.44 and up. Use EndpointSettings.MacAddress instead.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("MacAddress")]
        public string MacAddress { get; set; }

        /// <summary>
        /// `ONBUILD` metadata that were defined in the image's `Dockerfile`.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("OnBuild")]
        public System.Collections.Generic.ICollection<string> OnBuild { get; set; }

        /// <summary>
        /// User-defined key/value metadata.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Labels")]
        public System.Collections.Generic.IDictionary<string, string> Labels { get; set; }

        /// <summary>
        /// Signal to stop a container as a string or unsigned integer.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("StopSignal")]
        public string StopSignal { get; set; }

        /// <summary>
        /// Timeout to stop a container in seconds.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("StopTimeout")]
        public int? StopTimeout { get; set; } = 10;

        /// <summary>
        /// Shell for when `RUN`, `CMD`, and `ENTRYPOINT` uses a shell.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Shell")]
        public System.Collections.Generic.ICollection<string> Shell { get; set; }

    }

    /// <summary>
    /// Configuration of the image. These fields are used as defaults
    /// <br/>when starting a container from the image.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ImageConfig
    {
        /// <summary>
        /// The hostname to use for the container, as a valid RFC 1123 hostname.
        /// <br/>
        /// <br/>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
        /// <br/>
        /// <br/>&gt; **Deprecated**: this field is not part of the image specification and is
        /// <br/>&gt; always empty. It must not be used, and will be removed in API v1.47.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Hostname")]
        public string Hostname { get; set; }

        /// <summary>
        /// The domain name to use for the container.
        /// <br/>
        /// <br/>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
        /// <br/>
        /// <br/>&gt; **Deprecated**: this field is not part of the image specification and is
        /// <br/>&gt; always empty. It must not be used, and will be removed in API v1.47.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Domainname")]
        public string Domainname { get; set; }

        /// <summary>
        /// The user that commands are run as inside the container.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("User")]
        public string User { get; set; }

        /// <summary>
        /// Whether to attach to `stdin`.
        /// <br/>
        /// <br/>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
        /// <br/>
        /// <br/>&gt; **Deprecated**: this field is not part of the image specification and is
        /// <br/>&gt; always false. It must not be used, and will be removed in API v1.47.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("AttachStdin")]
        public bool? AttachStdin { get; set; } = false;

        /// <summary>
        /// Whether to attach to `stdout`.
        /// <br/>
        /// <br/>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
        /// <br/>
        /// <br/>&gt; **Deprecated**: this field is not part of the image specification and is
        /// <br/>&gt; always false. It must not be used, and will be removed in API v1.47.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("AttachStdout")]
        public bool? AttachStdout { get; set; } = false;

        /// <summary>
        /// Whether to attach to `stderr`.
        /// <br/>
        /// <br/>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
        /// <br/>
        /// <br/>&gt; **Deprecated**: this field is not part of the image specification and is
        /// <br/>&gt; always false. It must not be used, and will be removed in API v1.47.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("AttachStderr")]
        public bool? AttachStderr { get; set; } = false;

        /// <summary>
        /// An object mapping ports to an empty object in the form:
        /// <br/>
        /// <br/>`{"&lt;port&gt;/&lt;tcp|udp|sctp&gt;": {}}`
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ExposedPorts")]
        public System.Collections.Generic.IDictionary<string, Anonymous5> ExposedPorts { get; set; }

        /// <summary>
        /// Attach standard streams to a TTY, including `stdin` if it is not closed.
        /// <br/>
        /// <br/>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
        /// <br/>
        /// <br/>&gt; **Deprecated**: this field is not part of the image specification and is
        /// <br/>&gt; always false. It must not be used, and will be removed in API v1.47.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Tty")]
        public bool? Tty { get; set; } = false;

        /// <summary>
        /// Open `stdin`
        /// <br/>
        /// <br/>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
        /// <br/>
        /// <br/>&gt; **Deprecated**: this field is not part of the image specification and is
        /// <br/>&gt; always false. It must not be used, and will be removed in API v1.47.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("OpenStdin")]
        public bool? OpenStdin { get; set; } = false;

        /// <summary>
        /// Close `stdin` after one attached client disconnects.
        /// <br/>
        /// <br/>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
        /// <br/>
        /// <br/>&gt; **Deprecated**: this field is not part of the image specification and is
        /// <br/>&gt; always false. It must not be used, and will be removed in API v1.47.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("StdinOnce")]
        public bool? StdinOnce { get; set; } = false;

        /// <summary>
        /// A list of environment variables to set inside the container in the
        /// <br/>form `["VAR=value", ...]`. A variable without `=` is removed from the
        /// <br/>environment, rather than to have an empty value.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Env")]
        public System.Collections.Generic.ICollection<string> Env { get; set; }

        /// <summary>
        /// Command to run specified as a string or an array of strings.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Cmd")]
        public System.Collections.Generic.ICollection<string> Cmd { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Healthcheck")]
        public HealthConfig Healthcheck { get; set; }

        /// <summary>
        /// Command is already escaped (Windows only)
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ArgsEscaped")]
        public bool? ArgsEscaped { get; set; } = false;

        /// <summary>
        /// The name (or reference) of the image to use when creating the container,
        /// <br/>or which was used when the container was created.
        /// <br/>
        /// <br/>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
        /// <br/>
        /// <br/>&gt; **Deprecated**: this field is not part of the image specification and is
        /// <br/>&gt; always empty. It must not be used, and will be removed in API v1.47.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Image")]
        public string Image { get; set; } = "";

        /// <summary>
        /// An object mapping mount point paths inside the container to empty
        /// <br/>objects.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Volumes")]
        public System.Collections.Generic.IDictionary<string, Anonymous6> Volumes { get; set; }

        /// <summary>
        /// The working directory for commands to run in.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("WorkingDir")]
        public string WorkingDir { get; set; }

        /// <summary>
        /// The entry point for the container as a string or an array of strings.
        /// <br/>
        /// <br/>If the array consists of exactly one empty string (`[""]`) then the
        /// <br/>entry point is reset to system default (i.e., the entry point used by
        /// <br/>docker when there is no `ENTRYPOINT` instruction in the `Dockerfile`).
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Entrypoint")]
        public System.Collections.Generic.ICollection<string> Entrypoint { get; set; }

        /// <summary>
        /// Disable networking for the container.
        /// <br/>
        /// <br/>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
        /// <br/>
        /// <br/>&gt; **Deprecated**: this field is not part of the image specification and is
        /// <br/>&gt; always omitted. It must not be used, and will be removed in API v1.47.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("NetworkDisabled")]
        public bool? NetworkDisabled { get; set; } = false;

        /// <summary>
        /// MAC address of the container.
        /// <br/>
        /// <br/>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
        /// <br/>
        /// <br/>&gt; **Deprecated**: this field is not part of the image specification and is
        /// <br/>&gt; always omitted. It must not be used, and will be removed in API v1.47.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("MacAddress")]
        public string MacAddress { get; set; } = "";

        /// <summary>
        /// `ONBUILD` metadata that were defined in the image's `Dockerfile`.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("OnBuild")]
        public System.Collections.Generic.ICollection<string> OnBuild { get; set; }

        /// <summary>
        /// User-defined key/value metadata.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Labels")]
        public System.Collections.Generic.IDictionary<string, string> Labels { get; set; }

        /// <summary>
        /// Signal to stop a container as a string or unsigned integer.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("StopSignal")]
        public string StopSignal { get; set; }

        /// <summary>
        /// Timeout to stop a container in seconds.
        /// <br/>
        /// <br/>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
        /// <br/>
        /// <br/>&gt; **Deprecated**: this field is not part of the image specification and is
        /// <br/>&gt; always omitted. It must not be used, and will be removed in API v1.47.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("StopTimeout")]
        public int? StopTimeout { get; set; } = 10;

        /// <summary>
        /// Shell for when `RUN`, `CMD`, and `ENTRYPOINT` uses a shell.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Shell")]
        public System.Collections.Generic.ICollection<string> Shell { get; set; }

    }

    /// <summary>
    /// NetworkingConfig represents the container's networking configuration for
    /// <br/>each of its interfaces.
    /// <br/>It is used for the networking configs specified in the `docker create`
    /// <br/>and `docker network connect` commands.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NetworkingConfig
    {
        /// <summary>
        /// A mapping of network name to endpoint configuration for that network.
        /// <br/>The endpoint configuration can be left empty to connect to that
        /// <br/>network with no particular endpoint configuration.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("EndpointsConfig")]
        public System.Collections.Generic.IDictionary<string, EndpointSettings> EndpointsConfig { get; set; }

    }

    /// <summary>
    /// NetworkSettings exposes the network settings in the API
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NetworkSettings
    {
        /// <summary>
        /// Name of the default bridge interface when dockerd's --bridge flag is set.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Bridge")]
        public string Bridge { get; set; }

        /// <summary>
        /// SandboxID uniquely represents a container's network stack.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("SandboxID")]
        public string SandboxID { get; set; }

        /// <summary>
        /// Indicates if hairpin NAT should be enabled on the virtual interface.
        /// <br/>
        /// <br/>Deprecated: This field is never set and will be removed in a future release.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("HairpinMode")]
        public bool? HairpinMode { get; set; }

        /// <summary>
        /// IPv6 unicast address using the link-local prefix.
        /// <br/>
        /// <br/>Deprecated: This field is never set and will be removed in a future release.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("LinkLocalIPv6Address")]
        public string LinkLocalIPv6Address { get; set; }

        /// <summary>
        /// Prefix length of the IPv6 unicast address.
        /// <br/>
        /// <br/>Deprecated: This field is never set and will be removed in a future release.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("LinkLocalIPv6PrefixLen")]
        public int? LinkLocalIPv6PrefixLen { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Ports")]
        public PortMap Ports { get; set; }

        /// <summary>
        /// SandboxKey is the full path of the netns handle
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("SandboxKey")]
        public string SandboxKey { get; set; }

        /// <summary>
        /// Deprecated: This field is never set and will be removed in a future release.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("SecondaryIPAddresses")]
        public System.Collections.Generic.ICollection<Address> SecondaryIPAddresses { get; set; }

        /// <summary>
        /// Deprecated: This field is never set and will be removed in a future release.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("SecondaryIPv6Addresses")]
        public System.Collections.Generic.ICollection<Address> SecondaryIPv6Addresses { get; set; }

        /// <summary>
        /// EndpointID uniquely represents a service endpoint in a Sandbox.
        /// <br/>
        /// <br/>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
        /// <br/>
        /// <br/>&gt; **Deprecated**: This field is only propagated when attached to the
        /// <br/>&gt; default "bridge" network. Use the information from the "bridge"
        /// <br/>&gt; network inside the `Networks` map instead, which contains the same
        /// <br/>&gt; information. This field was deprecated in Docker 1.9 and is scheduled
        /// <br/>&gt; to be removed in Docker 17.12.0
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("EndpointID")]
        public string EndpointID { get; set; }

        /// <summary>
        /// Gateway address for the default "bridge" network.
        /// <br/>
        /// <br/>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
        /// <br/>
        /// <br/>&gt; **Deprecated**: This field is only propagated when attached to the
        /// <br/>&gt; default "bridge" network. Use the information from the "bridge"
        /// <br/>&gt; network inside the `Networks` map instead, which contains the same
        /// <br/>&gt; information. This field was deprecated in Docker 1.9 and is scheduled
        /// <br/>&gt; to be removed in Docker 17.12.0
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Gateway")]
        public string Gateway { get; set; }

        /// <summary>
        /// Global IPv6 address for the default "bridge" network.
        /// <br/>
        /// <br/>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
        /// <br/>
        /// <br/>&gt; **Deprecated**: This field is only propagated when attached to the
        /// <br/>&gt; default "bridge" network. Use the information from the "bridge"
        /// <br/>&gt; network inside the `Networks` map instead, which contains the same
        /// <br/>&gt; information. This field was deprecated in Docker 1.9 and is scheduled
        /// <br/>&gt; to be removed in Docker 17.12.0
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("GlobalIPv6Address")]
        public string GlobalIPv6Address { get; set; }

        /// <summary>
        /// Mask length of the global IPv6 address.
        /// <br/>
        /// <br/>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
        /// <br/>
        /// <br/>&gt; **Deprecated**: This field is only propagated when attached to the
        /// <br/>&gt; default "bridge" network. Use the information from the "bridge"
        /// <br/>&gt; network inside the `Networks` map instead, which contains the same
        /// <br/>&gt; information. This field was deprecated in Docker 1.9 and is scheduled
        /// <br/>&gt; to be removed in Docker 17.12.0
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("GlobalIPv6PrefixLen")]
        public int? GlobalIPv6PrefixLen { get; set; }

        /// <summary>
        /// IPv4 address for the default "bridge" network.
        /// <br/>
        /// <br/>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
        /// <br/>
        /// <br/>&gt; **Deprecated**: This field is only propagated when attached to the
        /// <br/>&gt; default "bridge" network. Use the information from the "bridge"
        /// <br/>&gt; network inside the `Networks` map instead, which contains the same
        /// <br/>&gt; information. This field was deprecated in Docker 1.9 and is scheduled
        /// <br/>&gt; to be removed in Docker 17.12.0
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("IPAddress")]
        public string IPAddress { get; set; }

        /// <summary>
        /// Mask length of the IPv4 address.
        /// <br/>
        /// <br/>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
        /// <br/>
        /// <br/>&gt; **Deprecated**: This field is only propagated when attached to the
        /// <br/>&gt; default "bridge" network. Use the information from the "bridge"
        /// <br/>&gt; network inside the `Networks` map instead, which contains the same
        /// <br/>&gt; information. This field was deprecated in Docker 1.9 and is scheduled
        /// <br/>&gt; to be removed in Docker 17.12.0
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("IPPrefixLen")]
        public int? IPPrefixLen { get; set; }

        /// <summary>
        /// IPv6 gateway address for this network.
        /// <br/>
        /// <br/>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
        /// <br/>
        /// <br/>&gt; **Deprecated**: This field is only propagated when attached to the
        /// <br/>&gt; default "bridge" network. Use the information from the "bridge"
        /// <br/>&gt; network inside the `Networks` map instead, which contains the same
        /// <br/>&gt; information. This field was deprecated in Docker 1.9 and is scheduled
        /// <br/>&gt; to be removed in Docker 17.12.0
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("IPv6Gateway")]
        public string IPv6Gateway { get; set; }

        /// <summary>
        /// MAC address for the container on the default "bridge" network.
        /// <br/>
        /// <br/>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
        /// <br/>
        /// <br/>&gt; **Deprecated**: This field is only propagated when attached to the
        /// <br/>&gt; default "bridge" network. Use the information from the "bridge"
        /// <br/>&gt; network inside the `Networks` map instead, which contains the same
        /// <br/>&gt; information. This field was deprecated in Docker 1.9 and is scheduled
        /// <br/>&gt; to be removed in Docker 17.12.0
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("MacAddress")]
        public string MacAddress { get; set; }

        /// <summary>
        /// Information about all networks that the container is connected to.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Networks")]
        public System.Collections.Generic.IDictionary<string, EndpointSettings> Networks { get; set; }

    }

    /// <summary>
    /// Address represents an IPv4 or IPv6 IP address.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Address
    {
        /// <summary>
        /// IP address.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Addr")]
        public string Addr { get; set; }

        /// <summary>
        /// Mask length of the IP address.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("PrefixLen")]
        public int? PrefixLen { get; set; }

    }

    /// <summary>
    /// PortMap describes the mapping of container ports to host ports, using the
    /// <br/>container's port-number and protocol as key in the format `&lt;port&gt;/&lt;protocol&gt;`,
    /// <br/>for example, `80/udp`.
    /// <br/>
    /// <br/>If a container's port is mapped for multiple protocols, separate entries
    /// <br/>are added to the mapping table.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PortMap : System.Collections.Generic.Dictionary<string, System.Collections.ObjectModel.Collection<PortBinding>>
    {

    }

    /// <summary>
    /// PortBinding represents a binding between a host IP address and a host
    /// <br/>port.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PortBinding
    {
        /// <summary>
        /// Host IP address that the container's port is mapped to.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("HostIp")]
        public string HostIp { get; set; }

        /// <summary>
        /// Host port number that the container's port is mapped to.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("HostPort")]
        public string HostPort { get; set; }

    }

    /// <summary>
    /// Information about the storage driver used to store the container's and
    /// <br/>image's filesystem.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class GraphDriverData
    {
        /// <summary>
        /// Name of the storage driver.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Name")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// Low-level storage metadata, provided as key/value pairs.
        /// <br/>
        /// <br/>This information is driver-specific, and depends on the storage-driver
        /// <br/>in use, and should be used for informational purposes only.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Data")]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.IDictionary<string, string> Data { get; } = new System.Collections.Generic.Dictionary<string, string>();

    }

    /// <summary>
    /// Change in the container's filesystem.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FilesystemChange
    {
        /// <summary>
        /// Path to file or directory that has changed.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Path")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Path { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Kind")]
        public ChangeType Kind { get; set; }

    }

    /// <summary>
    /// Kind of change
    /// <br/>
    /// <br/>Can be one of:
    /// <br/>
    /// <br/>- `0`: Modified ("C")
    /// <br/>- `1`: Added ("A")
    /// <br/>- `2`: Deleted ("D")
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ChangeType
    {

        _0 = 0,

        _1 = 1,

        _2 = 2,

    }

    /// <summary>
    /// Information about an image in the local image cache.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ImageInspect
    {
        /// <summary>
        /// ID is the content-addressable ID of an image.
        /// <br/>
        /// <br/>This identifier is a content-addressable digest calculated from the
        /// <br/>image's configuration (which includes the digests of layers used by
        /// <br/>the image).
        /// <br/>
        /// <br/>Note that this digest differs from the `RepoDigests` below, which
        /// <br/>holds digests of image manifests that reference the image.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Id")]
        public string Id { get; set; }

        /// <summary>
        /// List of image names/tags in the local image cache that reference this
        /// <br/>image.
        /// <br/>
        /// <br/>Multiple image tags can refer to the same image, and this list may be
        /// <br/>empty if no tags reference the image, in which case the image is
        /// <br/>"untagged", in which case it can still be referenced by its ID.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("RepoTags")]
        public System.Collections.Generic.ICollection<string> RepoTags { get; set; }

        /// <summary>
        /// List of content-addressable digests of locally available image manifests
        /// <br/>that the image is referenced from. Multiple manifests can refer to the
        /// <br/>same image.
        /// <br/>
        /// <br/>These digests are usually only available if the image was either pulled
        /// <br/>from a registry, or if the image was pushed to a registry, which is when
        /// <br/>the manifest is generated and its digest calculated.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("RepoDigests")]
        public System.Collections.Generic.ICollection<string> RepoDigests { get; set; }

        /// <summary>
        /// ID of the parent image.
        /// <br/>
        /// <br/>Depending on how the image was created, this field may be empty and
        /// <br/>is only set for images that were built/created locally. This field
        /// <br/>is empty if the image was pulled from an image registry.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Parent")]
        public string Parent { get; set; }

        /// <summary>
        /// Optional message that was set when committing or importing the image.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Comment")]
        public string Comment { get; set; }

        /// <summary>
        /// Date and time at which the image was created, formatted in
        /// <br/>[RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds.
        /// <br/>
        /// <br/>This information is only available if present in the image,
        /// <br/>and omitted otherwise.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Created")]
        public string Created { get; set; }

        /// <summary>
        /// The version of Docker that was used to build the image.
        /// <br/>
        /// <br/>Depending on how the image was created, this field may be empty.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("DockerVersion")]
        public string DockerVersion { get; set; }

        /// <summary>
        /// Name of the author that was specified when committing the image, or as
        /// <br/>specified through MAINTAINER (deprecated) in the Dockerfile.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Author")]
        public string Author { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Config")]
        public ImageConfig Config { get; set; }

        /// <summary>
        /// Hardware CPU architecture that the image runs on.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Architecture")]
        public string Architecture { get; set; }

        /// <summary>
        /// CPU architecture variant (presently ARM-only).
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Variant")]
        public string Variant { get; set; }

        /// <summary>
        /// Operating System the image is built to run on.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Os")]
        public string Os { get; set; }

        /// <summary>
        /// Operating System version the image is built to run on (especially
        /// <br/>for Windows).
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("OsVersion")]
        public string OsVersion { get; set; }

        /// <summary>
        /// Total size of the image including all layers it is composed of.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Size")]
        public long? Size { get; set; }

        /// <summary>
        /// Total size of the image including all layers it is composed of.
        /// <br/>
        /// <br/>Deprecated: this field is omitted in API v1.44, but kept for backward compatibility. Use Size instead.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("VirtualSize")]
        public long? VirtualSize { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("GraphDriver")]
        public GraphDriverData GraphDriver { get; set; }

        /// <summary>
        /// Information about the image's RootFS, including the layer IDs.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("RootFS")]
        public RootFS RootFS { get; set; }

        /// <summary>
        /// Additional metadata of the image in the local cache. This information
        /// <br/>is local to the daemon, and not part of the image itself.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Metadata")]
        public Metadata Metadata { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ImageSummary
    {
        /// <summary>
        /// ID is the content-addressable ID of an image.
        /// <br/>
        /// <br/>This identifier is a content-addressable digest calculated from the
        /// <br/>image's configuration (which includes the digests of layers used by
        /// <br/>the image).
        /// <br/>
        /// <br/>Note that this digest differs from the `RepoDigests` below, which
        /// <br/>holds digests of image manifests that reference the image.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Id")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        /// <summary>
        /// ID of the parent image.
        /// <br/>
        /// <br/>Depending on how the image was created, this field may be empty and
        /// <br/>is only set for images that were built/created locally. This field
        /// <br/>is empty if the image was pulled from an image registry.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ParentId")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ParentId { get; set; }

        /// <summary>
        /// List of image names/tags in the local image cache that reference this
        /// <br/>image.
        /// <br/>
        /// <br/>Multiple image tags can refer to the same image, and this list may be
        /// <br/>empty if no tags reference the image, in which case the image is
        /// <br/>"untagged", in which case it can still be referenced by its ID.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("RepoTags")]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> RepoTags { get; } = new System.Collections.ObjectModel.Collection<string>();

        /// <summary>
        /// List of content-addressable digests of locally available image manifests
        /// <br/>that the image is referenced from. Multiple manifests can refer to the
        /// <br/>same image.
        /// <br/>
        /// <br/>These digests are usually only available if the image was either pulled
        /// <br/>from a registry, or if the image was pushed to a registry, which is when
        /// <br/>the manifest is generated and its digest calculated.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("RepoDigests")]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> RepoDigests { get; } = new System.Collections.ObjectModel.Collection<string>();

        /// <summary>
        /// Date and time at which the image was created as a Unix timestamp
        /// <br/>(number of seconds sinds EPOCH).
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Created")]
        public int Created { get; set; }

        /// <summary>
        /// Total size of the image including all layers it is composed of.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Size")]
        public long Size { get; set; }

        /// <summary>
        /// Total size of image layers that are shared between this image and other
        /// <br/>images.
        /// <br/>
        /// <br/>This size is not calculated by default. `-1` indicates that the value
        /// <br/>has not been set / calculated.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("SharedSize")]
        public long SharedSize { get; set; }

        /// <summary>
        /// Total size of the image including all layers it is composed of.
        /// <br/>
        /// <br/>Deprecated: this field is omitted in API v1.44, but kept for backward compatibility. Use Size instead.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("VirtualSize")]
        public long? VirtualSize { get; set; }

        /// <summary>
        /// User-defined key/value metadata.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Labels")]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.IDictionary<string, string> Labels { get; } = new System.Collections.Generic.Dictionary<string, string>();

        /// <summary>
        /// Number of containers using this image. Includes both stopped and running
        /// <br/>containers.
        /// <br/>
        /// <br/>This size is not calculated by default, and depends on which API endpoint
        /// <br/>is used. `-1` indicates that the value has not been set / calculated.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Containers")]
        public int Containers { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AuthConfig
    {

        [System.Text.Json.Serialization.JsonPropertyName("username")]
        public string Username { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("password")]
        public string Password { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("email")]
        public string Email { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("serveraddress")]
        public string Serveraddress { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ProcessConfig
    {

        [System.Text.Json.Serialization.JsonPropertyName("privileged")]
        public bool? Privileged { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("user")]
        public string User { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("tty")]
        public bool? Tty { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("entrypoint")]
        public string Entrypoint { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("arguments")]
        public System.Collections.Generic.ICollection<string> Arguments { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Volume
    {
        /// <summary>
        /// Name of the volume.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Name")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// Name of the volume driver used by the volume.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Driver")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Driver { get; set; }

        /// <summary>
        /// Mount path of the volume on the host.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Mountpoint")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Mountpoint { get; set; }

        /// <summary>
        /// Date/Time the volume was created.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("CreatedAt")]
        public string CreatedAt { get; set; }

        /// <summary>
        /// Low-level details about the volume, provided by the volume driver.
        /// <br/>Details are returned as a map with key/value pairs:
        /// <br/>`{"key":"value","key2":"value2"}`.
        /// <br/>
        /// <br/>The `Status` field is optional, and is omitted if the volume driver
        /// <br/>does not support this feature.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Status")]
        public System.Collections.Generic.IDictionary<string, object> Status { get; set; }

        /// <summary>
        /// User-defined key/value metadata.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Labels")]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.IDictionary<string, string> Labels { get; } = new System.Collections.Generic.Dictionary<string, string>();

        /// <summary>
        /// The level at which the volume exists. Either `global` for cluster-wide,
        /// <br/>or `local` for machine level.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Scope")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public VolumeScope Scope { get; set; } = DockerEngine.VolumeScope.Local;

        [System.Text.Json.Serialization.JsonPropertyName("ClusterVolume")]
        public ClusterVolume ClusterVolume { get; set; }

        /// <summary>
        /// The driver specific options used when creating the volume.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Options")]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.IDictionary<string, string> Options { get; } = new System.Collections.Generic.Dictionary<string, string>();

        /// <summary>
        /// Usage details about the volume. This information is used by the
        /// <br/>`GET /system/df` endpoint, and omitted in other endpoints.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("UsageData")]
        public UsageData UsageData { get; set; }

    }

    /// <summary>
    /// Volume configuration
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class VolumeCreateOptions
    {
        /// <summary>
        /// The new volume's name. If not specified, Docker generates a name.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Name")]
        public string Name { get; set; }

        /// <summary>
        /// Name of the volume driver to use.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Driver")]
        public string Driver { get; set; } = "local";

        /// <summary>
        /// A mapping of driver options and values. These options are
        /// <br/>passed directly to the driver and are driver specific.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("DriverOpts")]
        public System.Collections.Generic.IDictionary<string, string> DriverOpts { get; set; }

        /// <summary>
        /// User-defined key/value metadata.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Labels")]
        public System.Collections.Generic.IDictionary<string, string> Labels { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("ClusterVolumeSpec")]
        public ClusterVolumeSpec ClusterVolumeSpec { get; set; }

    }

    /// <summary>
    /// Volume list response
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class VolumeListResponse
    {
        /// <summary>
        /// List of volumes
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Volumes")]
        public System.Collections.Generic.ICollection<Volume> Volumes { get; set; }

        /// <summary>
        /// Warnings that occurred when fetching the list of volumes.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Warnings")]
        public System.Collections.Generic.ICollection<string> Warnings { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Network
    {
        /// <summary>
        /// Name of the network.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Name")]
        public string Name { get; set; }

        /// <summary>
        /// ID that uniquely identifies a network on a single machine.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Id")]
        public string Id { get; set; }

        /// <summary>
        /// Date and time at which the network was created in
        /// <br/>[RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Created")]
        public string Created { get; set; }

        /// <summary>
        /// The level at which the network exists (e.g. `swarm` for cluster-wide
        /// <br/>or `local` for machine level)
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Scope")]
        public string Scope { get; set; }

        /// <summary>
        /// The name of the driver used to create the network (e.g. `bridge`,
        /// <br/>`overlay`).
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Driver")]
        public string Driver { get; set; }

        /// <summary>
        /// Whether the network was created with IPv6 enabled.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("EnableIPv6")]
        public bool? EnableIPv6 { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("IPAM")]
        public IPAM IPAM { get; set; }

        /// <summary>
        /// Whether the network is created to only allow internal networking
        /// <br/>connectivity.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Internal")]
        public bool? Internal { get; set; } = false;

        /// <summary>
        /// Wheter a global / swarm scope network is manually attachable by regular
        /// <br/>containers from workers in swarm mode.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Attachable")]
        public bool? Attachable { get; set; } = false;

        /// <summary>
        /// Whether the network is providing the routing-mesh for the swarm cluster.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Ingress")]
        public bool? Ingress { get; set; } = false;

        [System.Text.Json.Serialization.JsonPropertyName("ConfigFrom")]
        public ConfigReference ConfigFrom { get; set; }

        /// <summary>
        /// Whether the network is a config-only network. Config-only networks are
        /// <br/>placeholder networks for network configurations to be used by other
        /// <br/>networks. Config-only networks cannot be used directly to run containers
        /// <br/>or services.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ConfigOnly")]
        public bool? ConfigOnly { get; set; } = false;

        /// <summary>
        /// Contains endpoints attached to the network.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Containers")]
        public System.Collections.Generic.IDictionary<string, NetworkContainer> Containers { get; set; }

        /// <summary>
        /// Network-specific options uses when creating the network.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Options")]
        public System.Collections.Generic.IDictionary<string, string> Options { get; set; }

        /// <summary>
        /// User-defined key/value metadata.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Labels")]
        public System.Collections.Generic.IDictionary<string, string> Labels { get; set; }

        /// <summary>
        /// List of peer nodes for an overlay network. This field is only present
        /// <br/>for overlay networks, and omitted for other network types.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Peers")]
        public System.Collections.Generic.ICollection<PeerInfo> Peers { get; set; }

    }

    /// <summary>
    /// The config-only network source to provide the configuration for
    /// <br/>this network.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ConfigReference
    {
        /// <summary>
        /// The name of the config-only network that provides the network's
        /// <br/>configuration. The specified network must be an existing config-only
        /// <br/>network. Only network names are allowed, not network IDs.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Network")]
        public string Network { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class IPAM
    {
        /// <summary>
        /// Name of the IPAM driver to use.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Driver")]
        public string Driver { get; set; } = "default";

        /// <summary>
        /// List of IPAM configuration options, specified as a map:
        /// <br/>
        /// <br/>```
        /// <br/>{"Subnet": &lt;CIDR&gt;, "IPRange": &lt;CIDR&gt;, "Gateway": &lt;IP address&gt;, "AuxAddress": &lt;device_name:IP address&gt;}
        /// <br/>```
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Config")]
        public System.Collections.Generic.ICollection<IPAMConfig> Config { get; set; }

        /// <summary>
        /// Driver-specific options, specified as a map.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Options")]
        public System.Collections.Generic.IDictionary<string, string> Options { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class IPAMConfig
    {

        [System.Text.Json.Serialization.JsonPropertyName("Subnet")]
        public string Subnet { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("IPRange")]
        public string IPRange { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Gateway")]
        public string Gateway { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("AuxiliaryAddresses")]
        public System.Collections.Generic.IDictionary<string, string> AuxiliaryAddresses { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NetworkContainer
    {

        [System.Text.Json.Serialization.JsonPropertyName("Name")]
        public string Name { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("EndpointID")]
        public string EndpointID { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("MacAddress")]
        public string MacAddress { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("IPv4Address")]
        public string IPv4Address { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("IPv6Address")]
        public string IPv6Address { get; set; }

    }

    /// <summary>
    /// PeerInfo represents one peer of an overlay network.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PeerInfo
    {
        /// <summary>
        /// ID of the peer-node in the Swarm cluster.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Name")]
        public string Name { get; set; }

        /// <summary>
        /// IP-address of the peer-node in the Swarm cluster.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("IP")]
        public string IP { get; set; }

    }

    /// <summary>
    /// OK response to NetworkCreate operation
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NetworkCreateResponse
    {
        /// <summary>
        /// The ID of the created network.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Id")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        /// <summary>
        /// Warnings encountered when creating the container
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Warning")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Warning { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class BuildInfo
    {

        [System.Text.Json.Serialization.JsonPropertyName("id")]
        public string Id { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("stream")]
        public string Stream { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("error")]
        public string Error { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("errorDetail")]
        public ErrorDetail ErrorDetail { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("status")]
        public string Status { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("progress")]
        public string Progress { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("progressDetail")]
        public ProgressDetail ProgressDetail { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("aux")]
        public ImageID Aux { get; set; }

    }

    /// <summary>
    /// BuildCache contains information about a build cache record.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class BuildCache
    {
        /// <summary>
        /// Unique ID of the build cache record.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ID")]
        public string ID { get; set; }

        /// <summary>
        /// ID of the parent build cache record.
        /// <br/>
        /// <br/>&gt; **Deprecated**: This field is deprecated, and omitted if empty.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Parent")]
        public string Parent { get; set; }

        /// <summary>
        /// List of parent build cache record IDs.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Parents")]
        public System.Collections.Generic.ICollection<string> Parents { get; set; }

        /// <summary>
        /// Cache record type.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Type")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public BuildCacheType? Type { get; set; }

        /// <summary>
        /// Description of the build-step that produced the build cache.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Description")]
        public string Description { get; set; }

        /// <summary>
        /// Indicates if the build cache is in use.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("InUse")]
        public bool? InUse { get; set; }

        /// <summary>
        /// Indicates if the build cache is shared.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Shared")]
        public bool? Shared { get; set; }

        /// <summary>
        /// Amount of disk space used by the build cache (in bytes).
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Size")]
        public int? Size { get; set; }

        /// <summary>
        /// Date and time at which the build cache was created in
        /// <br/>[RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("CreatedAt")]
        public string CreatedAt { get; set; }

        /// <summary>
        /// Date and time at which the build cache was last used in
        /// <br/>[RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("LastUsedAt")]
        public string LastUsedAt { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("UsageCount")]
        public int? UsageCount { get; set; }

    }

    /// <summary>
    /// Image ID or Digest
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ImageID
    {

        [System.Text.Json.Serialization.JsonPropertyName("ID")]
        public string ID { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CreateImageInfo
    {

        [System.Text.Json.Serialization.JsonPropertyName("id")]
        public string Id { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("error")]
        public string Error { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("errorDetail")]
        public ErrorDetail ErrorDetail { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("status")]
        public string Status { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("progress")]
        public string Progress { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("progressDetail")]
        public ProgressDetail ProgressDetail { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PushImageInfo
    {

        [System.Text.Json.Serialization.JsonPropertyName("error")]
        public string Error { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("status")]
        public string Status { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("progress")]
        public string Progress { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("progressDetail")]
        public ProgressDetail ProgressDetail { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ErrorDetail
    {

        [System.Text.Json.Serialization.JsonPropertyName("code")]
        public int? Code { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("message")]
        public string Message { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ProgressDetail
    {

        [System.Text.Json.Serialization.JsonPropertyName("current")]
        public int? Current { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("total")]
        public int? Total { get; set; }

    }

    /// <summary>
    /// Represents an error.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ErrorResponse
    {
        /// <summary>
        /// The error message.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("message")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Message { get; set; }

    }

    /// <summary>
    /// Response to an API call that returns just an Id
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class IdResponse
    {
        /// <summary>
        /// The id of the newly created object.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Id")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

    }

    /// <summary>
    /// Configuration for a network endpoint.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EndpointSettings
    {

        [System.Text.Json.Serialization.JsonPropertyName("IPAMConfig")]
        public EndpointIPAMConfig IPAMConfig { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Links")]
        public System.Collections.Generic.ICollection<string> Links { get; set; }

        /// <summary>
        /// MAC address for the endpoint on this network. The network driver might ignore this parameter.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("MacAddress")]
        public string MacAddress { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Aliases")]
        public System.Collections.Generic.ICollection<string> Aliases { get; set; }

        /// <summary>
        /// DriverOpts is a mapping of driver options and values. These options
        /// <br/>are passed directly to the driver and are driver specific.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("DriverOpts")]
        public System.Collections.Generic.IDictionary<string, string> DriverOpts { get; set; }

        /// <summary>
        /// Unique ID of the network.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("NetworkID")]
        public string NetworkID { get; set; }

        /// <summary>
        /// Unique ID for the service endpoint in a Sandbox.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("EndpointID")]
        public string EndpointID { get; set; }

        /// <summary>
        /// Gateway address for this network.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Gateway")]
        public string Gateway { get; set; }

        /// <summary>
        /// IPv4 address.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("IPAddress")]
        public string IPAddress { get; set; }

        /// <summary>
        /// Mask length of the IPv4 address.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("IPPrefixLen")]
        public int? IPPrefixLen { get; set; }

        /// <summary>
        /// IPv6 gateway address.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("IPv6Gateway")]
        public string IPv6Gateway { get; set; }

        /// <summary>
        /// Global IPv6 address.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("GlobalIPv6Address")]
        public string GlobalIPv6Address { get; set; }

        /// <summary>
        /// Mask length of the global IPv6 address.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("GlobalIPv6PrefixLen")]
        public long? GlobalIPv6PrefixLen { get; set; }

        /// <summary>
        /// List of all DNS names an endpoint has on a specific network. This
        /// <br/>list is based on the container name, network aliases, container short
        /// <br/>ID, and hostname.
        /// <br/>
        /// <br/>These DNS names are non-fully qualified but can contain several dots.
        /// <br/>You can get fully qualified DNS names by appending `.&lt;network-name&gt;`.
        /// <br/>For instance, if container name is `my.ctr` and the network is named
        /// <br/>`testnet`, `DNSNames` will contain `my.ctr` and the FQDN will be
        /// <br/>`my.ctr.testnet`.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("DNSNames")]
        public System.Collections.Generic.ICollection<string> DNSNames { get; set; }

    }

    /// <summary>
    /// EndpointIPAMConfig represents an endpoint's IPAM configuration.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EndpointIPAMConfig
    {

        [System.Text.Json.Serialization.JsonPropertyName("IPv4Address")]
        public string IPv4Address { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("IPv6Address")]
        public string IPv6Address { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("LinkLocalIPs")]
        public System.Collections.Generic.ICollection<string> LinkLocalIPs { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PluginMount
    {

        [System.Text.Json.Serialization.JsonPropertyName("Name")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Description")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Description { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Settable")]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Settable { get; } = new System.Collections.ObjectModel.Collection<string>();

        [System.Text.Json.Serialization.JsonPropertyName("Source")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Source { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Destination")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Destination { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Type")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Type { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Options")]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Options { get; } = new System.Collections.ObjectModel.Collection<string>();

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PluginDevice
    {

        [System.Text.Json.Serialization.JsonPropertyName("Name")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Description")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Description { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Settable")]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Settable { get; } = new System.Collections.ObjectModel.Collection<string>();

        [System.Text.Json.Serialization.JsonPropertyName("Path")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Path { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PluginEnv
    {

        [System.Text.Json.Serialization.JsonPropertyName("Name")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Description")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Description { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Settable")]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Settable { get; } = new System.Collections.ObjectModel.Collection<string>();

        [System.Text.Json.Serialization.JsonPropertyName("Value")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PluginInterfaceType
    {

        [System.Text.Json.Serialization.JsonPropertyName("Prefix")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Prefix { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Capability")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Capability { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Version")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Version { get; set; }

    }

    /// <summary>
    /// Describes a permission the user has to accept upon installing
    /// <br/>the plugin.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PluginPrivilege
    {

        [System.Text.Json.Serialization.JsonPropertyName("Name")]
        public string Name { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Description")]
        public string Description { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Value")]
        public System.Collections.Generic.ICollection<string> Value { get; set; }

    }

    /// <summary>
    /// A plugin for the Engine API
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Plugin
    {

        [System.Text.Json.Serialization.JsonPropertyName("Id")]
        public string Id { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Name")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// True if the plugin is running. False if the plugin is not running, only installed.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Enabled")]
        public bool Enabled { get; set; }

        /// <summary>
        /// Settings that can be modified by users.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Settings")]
        [System.ComponentModel.DataAnnotations.Required]
        public Settings Settings { get; set; } = new Settings();

        /// <summary>
        /// plugin remote reference used to push/pull the plugin
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("PluginReference")]
        public string PluginReference { get; set; }

        /// <summary>
        /// The config of a plugin.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Config")]
        [System.ComponentModel.DataAnnotations.Required]
        public Config2 Config { get; set; } = new Config2();

    }

    /// <summary>
    /// The version number of the object such as node, service, etc. This is needed
    /// <br/>to avoid conflicting writes. The client must send the version number along
    /// <br/>with the modified specification when updating these objects.
    /// <br/>
    /// <br/>This approach ensures safe concurrency and determinism in that the change
    /// <br/>on the object may not be applied if the version number has changed from the
    /// <br/>last read. In other words, if two update requests specify the same base
    /// <br/>version, only one of the requests can succeed. As a result, two separate
    /// <br/>update requests that happen at the same time will not unintentionally
    /// <br/>overwrite each other.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ObjectVersion
    {

        [System.Text.Json.Serialization.JsonPropertyName("Index")]
        public ulong? Index { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NodeSpec
    {
        /// <summary>
        /// Name for the node.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Name")]
        public string Name { get; set; }

        /// <summary>
        /// User-defined key/value metadata.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Labels")]
        public System.Collections.Generic.IDictionary<string, string> Labels { get; set; }

        /// <summary>
        /// Role of the node.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Role")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public NodeSpecRole? Role { get; set; }

        /// <summary>
        /// Availability of the node.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Availability")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public NodeSpecAvailability? Availability { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Node
    {

        [System.Text.Json.Serialization.JsonPropertyName("ID")]
        public string ID { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Version")]
        public ObjectVersion Version { get; set; }

        /// <summary>
        /// Date and time at which the node was added to the swarm in
        /// <br/>[RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("CreatedAt")]
        public string CreatedAt { get; set; }

        /// <summary>
        /// Date and time at which the node was last updated in
        /// <br/>[RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("UpdatedAt")]
        public string UpdatedAt { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Spec")]
        public NodeSpec Spec { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Description")]
        public NodeDescription Description { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Status")]
        public NodeStatus Status { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("ManagerStatus")]
        public ManagerStatus ManagerStatus { get; set; }

    }

    /// <summary>
    /// NodeDescription encapsulates the properties of the Node as reported by the
    /// <br/>agent.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NodeDescription
    {

        [System.Text.Json.Serialization.JsonPropertyName("Hostname")]
        public string Hostname { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Platform")]
        public Platform Platform { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Resources")]
        public ResourceObject Resources { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Engine")]
        public EngineDescription Engine { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("TLSInfo")]
        public TLSInfo TLSInfo { get; set; }

    }

    /// <summary>
    /// Platform represents the platform (Arch/OS).
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Platform
    {
        /// <summary>
        /// Architecture represents the hardware architecture (for example,
        /// <br/>`x86_64`).
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Architecture")]
        public string Architecture { get; set; }

        /// <summary>
        /// OS represents the Operating System (for example, `linux` or `windows`).
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("OS")]
        public string OS { get; set; }

    }

    /// <summary>
    /// EngineDescription provides information about an engine.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EngineDescription
    {

        [System.Text.Json.Serialization.JsonPropertyName("EngineVersion")]
        public string EngineVersion { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Labels")]
        public System.Collections.Generic.IDictionary<string, string> Labels { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Plugins")]
        public System.Collections.Generic.ICollection<Plugins> Plugins { get; set; }

    }

    /// <summary>
    /// Information about the issuer of leaf TLS certificates and the trusted root
    /// <br/>CA certificate.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TLSInfo
    {
        /// <summary>
        /// The root CA certificate(s) that are used to validate leaf TLS
        /// <br/>certificates.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("TrustRoot")]
        public string TrustRoot { get; set; }

        /// <summary>
        /// The base64-url-safe-encoded raw subject bytes of the issuer.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("CertIssuerSubject")]
        public string CertIssuerSubject { get; set; }

        /// <summary>
        /// The base64-url-safe-encoded raw public key bytes of the issuer.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("CertIssuerPublicKey")]
        public string CertIssuerPublicKey { get; set; }

    }

    /// <summary>
    /// NodeStatus represents the status of a node.
    /// <br/>
    /// <br/>It provides the current status of the node, as seen by the manager.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NodeStatus
    {

        [System.Text.Json.Serialization.JsonPropertyName("State")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public NodeState? State { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Message")]
        public string Message { get; set; }

        /// <summary>
        /// IP address of the node.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Addr")]
        public string Addr { get; set; }

    }

    /// <summary>
    /// NodeState represents the state of a node.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum NodeState
    {

        [System.Runtime.Serialization.EnumMember(Value = @"unknown")]
        Unknown = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"down")]
        Down = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"ready")]
        Ready = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"disconnected")]
        Disconnected = 3,

    }

    /// <summary>
    /// ManagerStatus represents the status of a manager.
    /// <br/>
    /// <br/>It provides the current status of a node's manager component, if the node
    /// <br/>is a manager.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ManagerStatus
    {

        [System.Text.Json.Serialization.JsonPropertyName("Leader")]
        public bool? Leader { get; set; } = false;

        [System.Text.Json.Serialization.JsonPropertyName("Reachability")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public Reachability? Reachability { get; set; }

        /// <summary>
        /// The IP address and port at which the manager is reachable.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Addr")]
        public string Addr { get; set; }

    }

    /// <summary>
    /// Reachability represents the reachability of a node.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Reachability
    {

        [System.Runtime.Serialization.EnumMember(Value = @"unknown")]
        Unknown = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"unreachable")]
        Unreachable = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"reachable")]
        Reachable = 2,

    }

    /// <summary>
    /// User modifiable swarm configuration.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SwarmSpec
    {
        /// <summary>
        /// Name of the swarm.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Name")]
        public string Name { get; set; }

        /// <summary>
        /// User-defined key/value metadata.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Labels")]
        public System.Collections.Generic.IDictionary<string, string> Labels { get; set; }

        /// <summary>
        /// Orchestration configuration.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Orchestration")]
        public Orchestration Orchestration { get; set; }

        /// <summary>
        /// Raft configuration.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Raft")]
        public Raft Raft { get; set; }

        /// <summary>
        /// Dispatcher configuration.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Dispatcher")]
        public Dispatcher Dispatcher { get; set; }

        /// <summary>
        /// CA configuration.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("CAConfig")]
        public CAConfig CAConfig { get; set; }

        /// <summary>
        /// Parameters related to encryption-at-rest.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("EncryptionConfig")]
        public EncryptionConfig EncryptionConfig { get; set; }

        /// <summary>
        /// Defaults for creating tasks in this cluster.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("TaskDefaults")]
        public TaskDefaults TaskDefaults { get; set; }

    }

    /// <summary>
    /// ClusterInfo represents information about the swarm as is returned by the
    /// <br/>"/info" endpoint. Join-tokens are not included.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ClusterInfo
    {
        /// <summary>
        /// The ID of the swarm.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ID")]
        public string ID { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Version")]
        public ObjectVersion Version { get; set; }

        /// <summary>
        /// Date and time at which the swarm was initialised in
        /// <br/>[RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("CreatedAt")]
        public string CreatedAt { get; set; }

        /// <summary>
        /// Date and time at which the swarm was last updated in
        /// <br/>[RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("UpdatedAt")]
        public string UpdatedAt { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Spec")]
        public SwarmSpec Spec { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("TLSInfo")]
        public TLSInfo TLSInfo { get; set; }

        /// <summary>
        /// Whether there is currently a root CA rotation in progress for the swarm
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("RootRotationInProgress")]
        public bool? RootRotationInProgress { get; set; }

        /// <summary>
        /// DataPathPort specifies the data path port number for data traffic.
        /// <br/>Acceptable port range is 1024 to 49151.
        /// <br/>If no port is set or is set to 0, the default port (4789) is used.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("DataPathPort")]
        public int? DataPathPort { get; set; } = 4789;

        /// <summary>
        /// Default Address Pool specifies default subnet pools for global scope
        /// <br/>networks.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("DefaultAddrPool")]
        public System.Collections.Generic.ICollection<string> DefaultAddrPool { get; set; }

        /// <summary>
        /// SubnetSize specifies the subnet size of the networks created from the
        /// <br/>default subnet pool.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("SubnetSize")]
        [System.ComponentModel.DataAnnotations.Range(double.MinValue, 29D)]
        public int? SubnetSize { get; set; } = 24;

    }

    /// <summary>
    /// JoinTokens contains the tokens workers and managers need to join the swarm.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class JoinTokens
    {
        /// <summary>
        /// The token workers can use to join the swarm.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Worker")]
        public string Worker { get; set; }

        /// <summary>
        /// The token managers can use to join the swarm.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Manager")]
        public string Manager { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Swarm : ClusterInfo
    {

        [System.Text.Json.Serialization.JsonPropertyName("JoinTokens")]
        public JoinTokens JoinTokens { get; set; }

    }

    /// <summary>
    /// User modifiable task configuration.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TaskSpec
    {
        /// <summary>
        /// Plugin spec for the service.  *(Experimental release only.)*
        /// <br/>
        /// <br/>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
        /// <br/>
        /// <br/>&gt; **Note**: ContainerSpec, NetworkAttachmentSpec, and PluginSpec are
        /// <br/>&gt; mutually exclusive. PluginSpec is only used when the Runtime field
        /// <br/>&gt; is set to `plugin`. NetworkAttachmentSpec is used when the Runtime
        /// <br/>&gt; field is set to `attachment`.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("PluginSpec")]
        public PluginSpec PluginSpec { get; set; }

        /// <summary>
        /// Container spec for the service.
        /// <br/>
        /// <br/>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
        /// <br/>
        /// <br/>&gt; **Note**: ContainerSpec, NetworkAttachmentSpec, and PluginSpec are
        /// <br/>&gt; mutually exclusive. PluginSpec is only used when the Runtime field
        /// <br/>&gt; is set to `plugin`. NetworkAttachmentSpec is used when the Runtime
        /// <br/>&gt; field is set to `attachment`.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ContainerSpec")]
        public ContainerSpec ContainerSpec { get; set; }

        /// <summary>
        /// Read-only spec type for non-swarm containers attached to swarm overlay
        /// <br/>networks.
        /// <br/>
        /// <br/>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
        /// <br/>
        /// <br/>&gt; **Note**: ContainerSpec, NetworkAttachmentSpec, and PluginSpec are
        /// <br/>&gt; mutually exclusive. PluginSpec is only used when the Runtime field
        /// <br/>&gt; is set to `plugin`. NetworkAttachmentSpec is used when the Runtime
        /// <br/>&gt; field is set to `attachment`.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("NetworkAttachmentSpec")]
        public NetworkAttachmentSpec NetworkAttachmentSpec { get; set; }

        /// <summary>
        /// Resource requirements which apply to each individual container created
        /// <br/>as part of the service.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Resources")]
        public Resources2 Resources { get; set; }

        /// <summary>
        /// Specification for the restart policy which applies to containers
        /// <br/>created as part of this service.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("RestartPolicy")]
        public RestartPolicy2 RestartPolicy { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Placement")]
        public Placement Placement { get; set; }

        /// <summary>
        /// A counter that triggers an update even if no relevant parameters have
        /// <br/>been changed.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ForceUpdate")]
        public int? ForceUpdate { get; set; }

        /// <summary>
        /// Runtime is the type of runtime specified for the task executor.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Runtime")]
        public string Runtime { get; set; }

        /// <summary>
        /// Specifies which networks the service should attach to.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Networks")]
        public System.Collections.Generic.ICollection<NetworkAttachmentConfig> Networks { get; set; }

        /// <summary>
        /// Specifies the log driver to use for tasks created from this spec. If
        /// <br/>not present, the default one for the swarm will be used, finally
        /// <br/>falling back to the engine default if not specified.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("LogDriver")]
        public LogDriver LogDriver { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum TaskState
    {

        [System.Runtime.Serialization.EnumMember(Value = @"new")]
        New = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"allocated")]
        Allocated = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"pending")]
        Pending = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"assigned")]
        Assigned = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"accepted")]
        Accepted = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"preparing")]
        Preparing = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"ready")]
        Ready = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"starting")]
        Starting = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"running")]
        Running = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"complete")]
        Complete = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"shutdown")]
        Shutdown = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"failed")]
        Failed = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"rejected")]
        Rejected = 12,

        [System.Runtime.Serialization.EnumMember(Value = @"remove")]
        Remove = 13,

        [System.Runtime.Serialization.EnumMember(Value = @"orphaned")]
        Orphaned = 14,

    }

    /// <summary>
    /// represents the status of a container.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ContainerStatus
    {

        [System.Text.Json.Serialization.JsonPropertyName("ContainerID")]
        public string ContainerID { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("PID")]
        public int? PID { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("ExitCode")]
        public int? ExitCode { get; set; }

    }

    /// <summary>
    /// represents the port status of a task's host ports whose service has published host ports
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PortStatus
    {

        [System.Text.Json.Serialization.JsonPropertyName("Ports")]
        public System.Collections.Generic.ICollection<EndpointPortConfig> Ports { get; set; }

    }

    /// <summary>
    /// represents the status of a task.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TaskStatus
    {

        [System.Text.Json.Serialization.JsonPropertyName("Timestamp")]
        public string Timestamp { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("State")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public TaskState? State { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Message")]
        public string Message { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Err")]
        public string Err { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("ContainerStatus")]
        public ContainerStatus ContainerStatus { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("PortStatus")]
        public PortStatus PortStatus { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Task
    {
        /// <summary>
        /// The ID of the task.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ID")]
        public string ID { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Version")]
        public ObjectVersion Version { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("CreatedAt")]
        public string CreatedAt { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("UpdatedAt")]
        public string UpdatedAt { get; set; }

        /// <summary>
        /// Name of the task.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Name")]
        public string Name { get; set; }

        /// <summary>
        /// User-defined key/value metadata.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Labels")]
        public System.Collections.Generic.IDictionary<string, string> Labels { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Spec")]
        public TaskSpec Spec { get; set; }

        /// <summary>
        /// The ID of the service this task is part of.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ServiceID")]
        public string ServiceID { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Slot")]
        public int? Slot { get; set; }

        /// <summary>
        /// The ID of the node that this task is on.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("NodeID")]
        public string NodeID { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("AssignedGenericResources")]
        public GenericResources AssignedGenericResources { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Status")]
        public TaskStatus Status { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("DesiredState")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public TaskState? DesiredState { get; set; }

        /// <summary>
        /// If the Service this Task belongs to is a job-mode service, contains
        /// <br/>the JobIteration of the Service this Task was created for. Absent if
        /// <br/>the Task was created for a Replicated or Global Service.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("JobIteration")]
        public ObjectVersion JobIteration { get; set; }

    }

    /// <summary>
    /// User modifiable configuration for a service.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ServiceSpec
    {
        /// <summary>
        /// Name of the service.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Name")]
        public string Name { get; set; }

        /// <summary>
        /// User-defined key/value metadata.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Labels")]
        public System.Collections.Generic.IDictionary<string, string> Labels { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("TaskTemplate")]
        public TaskSpec TaskTemplate { get; set; }

        /// <summary>
        /// Scheduling mode for the service.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Mode")]
        public Mode Mode { get; set; }

        /// <summary>
        /// Specification for the update strategy of the service.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("UpdateConfig")]
        public UpdateConfig UpdateConfig { get; set; }

        /// <summary>
        /// Specification for the rollback strategy of the service.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("RollbackConfig")]
        public RollbackConfig RollbackConfig { get; set; }

        /// <summary>
        /// Specifies which networks the service should attach to.
        /// <br/>
        /// <br/>Deprecated: This field is deprecated since v1.44. The Networks field in TaskSpec should be used instead.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Networks")]
        public System.Collections.Generic.ICollection<NetworkAttachmentConfig> Networks { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("EndpointSpec")]
        public EndpointSpec EndpointSpec { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EndpointPortConfig
    {

        [System.Text.Json.Serialization.JsonPropertyName("Name")]
        public string Name { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Protocol")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public EndpointPortConfigProtocol? Protocol { get; set; }

        /// <summary>
        /// The port inside the container.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("TargetPort")]
        public int? TargetPort { get; set; }

        /// <summary>
        /// The port on the swarm hosts.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("PublishedPort")]
        public int? PublishedPort { get; set; }

        /// <summary>
        /// The mode in which port is published.
        /// <br/>
        /// <br/>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
        /// <br/>
        /// <br/>- "ingress" makes the target port accessible on every node,
        /// <br/>  regardless of whether there is a task for the service running on
        /// <br/>  that node or not.
        /// <br/>- "host" bypasses the routing mesh and publish the port directly on
        /// <br/>  the swarm node where that service is running.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("PublishMode")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public EndpointPortConfigPublishMode? PublishMode { get; set; } = DockerEngine.EndpointPortConfigPublishMode.Ingress;

    }

    /// <summary>
    /// Properties that can be configured to access and load balance a service.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EndpointSpec
    {
        /// <summary>
        /// The mode of resolution to use for internal load balancing between tasks.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Mode")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public EndpointSpecMode? Mode { get; set; } = DockerEngine.EndpointSpecMode.Vip;

        /// <summary>
        /// List of exposed ports that this service is accessible on from the
        /// <br/>outside. Ports can only be provided if `vip` resolution mode is used.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Ports")]
        public System.Collections.Generic.ICollection<EndpointPortConfig> Ports { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Service
    {

        [System.Text.Json.Serialization.JsonPropertyName("ID")]
        public string ID { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Version")]
        public ObjectVersion Version { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("CreatedAt")]
        public string CreatedAt { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("UpdatedAt")]
        public string UpdatedAt { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Spec")]
        public ServiceSpec Spec { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Endpoint")]
        public Endpoint Endpoint { get; set; }

        /// <summary>
        /// The status of a service update.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("UpdateStatus")]
        public UpdateStatus UpdateStatus { get; set; }

        /// <summary>
        /// The status of the service's tasks. Provided only when requested as
        /// <br/>part of a ServiceList operation.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ServiceStatus")]
        public ServiceStatus ServiceStatus { get; set; }

        /// <summary>
        /// The status of the service when it is in one of ReplicatedJob or
        /// <br/>GlobalJob modes. Absent on Replicated and Global mode services. The
        /// <br/>JobIteration is an ObjectVersion, but unlike the Service's version,
        /// <br/>does not need to be sent with an update request.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("JobStatus")]
        public JobStatus JobStatus { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ImageDeleteResponseItem
    {
        /// <summary>
        /// The image ID of an image that was untagged
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Untagged")]
        public string Untagged { get; set; }

        /// <summary>
        /// The image ID of an image that was deleted
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Deleted")]
        public string Deleted { get; set; }

    }

    /// <summary>
    /// contains the information returned to a client on the
    /// <br/>creation of a new service.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ServiceCreateResponse
    {
        /// <summary>
        /// The ID of the created service.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ID")]
        public string ID { get; set; }

        /// <summary>
        /// Optional warning message.
        /// <br/>
        /// <br/>FIXME(thaJeztah): this should have "omitempty" in the generated type.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Warnings")]
        public System.Collections.Generic.ICollection<string> Warnings { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ServiceUpdateResponse
    {
        /// <summary>
        /// Optional warning messages
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Warnings")]
        public System.Collections.Generic.ICollection<string> Warnings { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ContainerSummary
    {
        /// <summary>
        /// The ID of this container
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Id")]
        public string Id { get; set; }

        /// <summary>
        /// The names that this container has been given
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Names")]
        public System.Collections.Generic.ICollection<string> Names { get; set; }

        /// <summary>
        /// The name of the image used when creating this container
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Image")]
        public string Image { get; set; }

        /// <summary>
        /// The ID of the image that this container was created from
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ImageID")]
        public string ImageID { get; set; }

        /// <summary>
        /// Command to run when starting the container
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Command")]
        public string Command { get; set; }

        /// <summary>
        /// When the container was created
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Created")]
        public long? Created { get; set; }

        /// <summary>
        /// The ports exposed by this container
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Ports")]
        public System.Collections.Generic.ICollection<Port> Ports { get; set; }

        /// <summary>
        /// The size of files that have been created or changed by this container
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("SizeRw")]
        public long? SizeRw { get; set; }

        /// <summary>
        /// The total size of all the files in this container
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("SizeRootFs")]
        public long? SizeRootFs { get; set; }

        /// <summary>
        /// User-defined key/value metadata.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Labels")]
        public System.Collections.Generic.IDictionary<string, string> Labels { get; set; }

        /// <summary>
        /// The state of this container (e.g. `Exited`)
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("State")]
        public string State { get; set; }

        /// <summary>
        /// Additional human-readable status of this container (e.g. `Exit 0`)
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Status")]
        public string Status { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("HostConfig")]
        public HostConfig2 HostConfig { get; set; }

        /// <summary>
        /// A summary of the container's network settings
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("NetworkSettings")]
        public NetworkSettings2 NetworkSettings { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Mounts")]
        public System.Collections.Generic.ICollection<MountPoint> Mounts { get; set; }

    }

    /// <summary>
    /// Driver represents a driver (network, logging, secrets).
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Driver
    {
        /// <summary>
        /// Name of the driver.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Name")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// Key/value map of driver-specific options.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Options")]
        public System.Collections.Generic.IDictionary<string, string> Options { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SecretSpec
    {
        /// <summary>
        /// User-defined name of the secret.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Name")]
        public string Name { get; set; }

        /// <summary>
        /// User-defined key/value metadata.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Labels")]
        public System.Collections.Generic.IDictionary<string, string> Labels { get; set; }

        /// <summary>
        /// Base64-url-safe-encoded ([RFC 4648](https://tools.ietf.org/html/rfc4648#section-5))
        /// <br/>data to store as secret.
        /// <br/>
        /// <br/>This field is only used to _create_ a secret, and is not returned by
        /// <br/>other endpoints.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Data")]
        public string Data { get; set; }

        /// <summary>
        /// Name of the secrets driver used to fetch the secret's value from an
        /// <br/>external secret store.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Driver")]
        public Driver Driver { get; set; }

        /// <summary>
        /// Templating driver, if applicable
        /// <br/>
        /// <br/>Templating controls whether and how to evaluate the config payload as
        /// <br/>a template. If no driver is set, no templating is used.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Templating")]
        public Driver Templating { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Secret
    {

        [System.Text.Json.Serialization.JsonPropertyName("ID")]
        public string ID { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Version")]
        public ObjectVersion Version { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("CreatedAt")]
        public string CreatedAt { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("UpdatedAt")]
        public string UpdatedAt { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Spec")]
        public SecretSpec Spec { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ConfigSpec
    {
        /// <summary>
        /// User-defined name of the config.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Name")]
        public string Name { get; set; }

        /// <summary>
        /// User-defined key/value metadata.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Labels")]
        public System.Collections.Generic.IDictionary<string, string> Labels { get; set; }

        /// <summary>
        /// Base64-url-safe-encoded ([RFC 4648](https://tools.ietf.org/html/rfc4648#section-5))
        /// <br/>config data.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Data")]
        public string Data { get; set; }

        /// <summary>
        /// Templating driver, if applicable
        /// <br/>
        /// <br/>Templating controls whether and how to evaluate the config payload as
        /// <br/>a template. If no driver is set, no templating is used.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Templating")]
        public Driver Templating { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Config
    {

        [System.Text.Json.Serialization.JsonPropertyName("ID")]
        public string ID { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Version")]
        public ObjectVersion Version { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("CreatedAt")]
        public string CreatedAt { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("UpdatedAt")]
        public string UpdatedAt { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Spec")]
        public ConfigSpec Spec { get; set; }

    }

    /// <summary>
    /// ContainerState stores container's running state. It's part of ContainerJSONBase
    /// <br/>and will be returned by the "inspect" command.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ContainerState
    {
        /// <summary>
        /// String representation of the container state. Can be one of "created",
        /// <br/>"running", "paused", "restarting", "removing", "exited", or "dead".
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Status")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public ContainerStateStatus? Status { get; set; }

        /// <summary>
        /// Whether this container is running.
        /// <br/>
        /// <br/>Note that a running container can be _paused_. The `Running` and `Paused`
        /// <br/>booleans are not mutually exclusive:
        /// <br/>
        /// <br/>When pausing a container (on Linux), the freezer cgroup is used to suspend
        /// <br/>all processes in the container. Freezing the process requires the process to
        /// <br/>be running. As a result, paused containers are both `Running` _and_ `Paused`.
        /// <br/>
        /// <br/>Use the `Status` field instead to determine if a container's state is "running".
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Running")]
        public bool? Running { get; set; }

        /// <summary>
        /// Whether this container is paused.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Paused")]
        public bool? Paused { get; set; }

        /// <summary>
        /// Whether this container is restarting.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Restarting")]
        public bool? Restarting { get; set; }

        /// <summary>
        /// Whether a process within this container has been killed because it ran
        /// <br/>out of memory since the container was last started.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("OOMKilled")]
        public bool? OOMKilled { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Dead")]
        public bool? Dead { get; set; }

        /// <summary>
        /// The process ID of this container
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Pid")]
        public int? Pid { get; set; }

        /// <summary>
        /// The last exit code of this container
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ExitCode")]
        public int? ExitCode { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Error")]
        public string Error { get; set; }

        /// <summary>
        /// The time when this container was last started.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("StartedAt")]
        public string StartedAt { get; set; }

        /// <summary>
        /// The time when this container last exited.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("FinishedAt")]
        public string FinishedAt { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Health")]
        public Health Health { get; set; }

    }

    /// <summary>
    /// OK response to ContainerCreate operation
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ContainerCreateResponse
    {
        /// <summary>
        /// The ID of the created container
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Id")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        /// <summary>
        /// Warnings encountered when creating the container
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Warnings")]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Warnings { get; } = new System.Collections.ObjectModel.Collection<string>();

    }

    /// <summary>
    /// OK response to ContainerWait operation
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ContainerWaitResponse
    {
        /// <summary>
        /// Exit code of the container
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("StatusCode")]
        public long StatusCode { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Error")]
        public ContainerWaitExitError Error { get; set; }

    }

    /// <summary>
    /// container waiting error, if any
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ContainerWaitExitError
    {
        /// <summary>
        /// Details of an error
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Message")]
        public string Message { get; set; }

    }

    /// <summary>
    /// Response of Engine API: GET "/version"
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SystemVersion
    {

        [System.Text.Json.Serialization.JsonPropertyName("Platform")]
        public Platform2 Platform { get; set; }

        /// <summary>
        /// Information about system components
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Components")]
        public System.Collections.Generic.ICollection<Components> Components { get; set; }

        /// <summary>
        /// The version of the daemon
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Version")]
        public string Version { get; set; }

        /// <summary>
        /// The default (and highest) API version that is supported by the daemon
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ApiVersion")]
        public string ApiVersion { get; set; }

        /// <summary>
        /// The minimum API version that is supported by the daemon
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("MinAPIVersion")]
        public string MinAPIVersion { get; set; }

        /// <summary>
        /// The Git commit of the source code that was used to build the daemon
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("GitCommit")]
        public string GitCommit { get; set; }

        /// <summary>
        /// The version Go used to compile the daemon, and the version of the Go
        /// <br/>runtime in use.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("GoVersion")]
        public string GoVersion { get; set; }

        /// <summary>
        /// The operating system that the daemon is running on ("linux" or "windows")
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Os")]
        public string Os { get; set; }

        /// <summary>
        /// The architecture that the daemon is running on
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Arch")]
        public string Arch { get; set; }

        /// <summary>
        /// The kernel version (`uname -r`) that the daemon is running on.
        /// <br/>
        /// <br/>This field is omitted when empty.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("KernelVersion")]
        public string KernelVersion { get; set; }

        /// <summary>
        /// Indicates if the daemon is started with experimental features enabled.
        /// <br/>
        /// <br/>This field is omitted when empty / false.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Experimental")]
        public bool? Experimental { get; set; }

        /// <summary>
        /// The date and time that the daemon was compiled.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("BuildTime")]
        public string BuildTime { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SystemInfo
    {
        /// <summary>
        /// Unique identifier of the daemon.
        /// <br/>
        /// <br/>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
        /// <br/>
        /// <br/>&gt; **Note**: The format of the ID itself is not part of the API, and
        /// <br/>&gt; should not be considered stable.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ID")]
        public string ID { get; set; }

        /// <summary>
        /// Total number of containers on the host.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Containers")]
        public int? Containers { get; set; }

        /// <summary>
        /// Number of containers with status `"running"`.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ContainersRunning")]
        public int? ContainersRunning { get; set; }

        /// <summary>
        /// Number of containers with status `"paused"`.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ContainersPaused")]
        public int? ContainersPaused { get; set; }

        /// <summary>
        /// Number of containers with status `"stopped"`.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ContainersStopped")]
        public int? ContainersStopped { get; set; }

        /// <summary>
        /// Total number of images on the host.
        /// <br/>
        /// <br/>Both _tagged_ and _untagged_ (dangling) images are counted.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Images")]
        public int? Images { get; set; }

        /// <summary>
        /// Name of the storage driver in use.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Driver")]
        public string Driver { get; set; }

        /// <summary>
        /// Information specific to the storage driver, provided as
        /// <br/>"label" / "value" pairs.
        /// <br/>
        /// <br/>This information is provided by the storage driver, and formatted
        /// <br/>in a way consistent with the output of `docker info` on the command
        /// <br/>line.
        /// <br/>
        /// <br/>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
        /// <br/>
        /// <br/>&gt; **Note**: The information returned in this field, including the
        /// <br/>&gt; formatting of values and labels, should not be considered stable,
        /// <br/>&gt; and may change without notice.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("DriverStatus")]
        public System.Collections.Generic.ICollection<System.Collections.Generic.ICollection<string>> DriverStatus { get; set; }

        /// <summary>
        /// Root directory of persistent Docker state.
        /// <br/>
        /// <br/>Defaults to `/var/lib/docker` on Linux, and `C:\ProgramData\docker`
        /// <br/>on Windows.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("DockerRootDir")]
        public string DockerRootDir { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Plugins")]
        public PluginsInfo Plugins { get; set; }

        /// <summary>
        /// Indicates if the host has memory limit support enabled.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("MemoryLimit")]
        public bool? MemoryLimit { get; set; }

        /// <summary>
        /// Indicates if the host has memory swap limit support enabled.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("SwapLimit")]
        public bool? SwapLimit { get; set; }

        /// <summary>
        /// Indicates if the host has kernel memory TCP limit support enabled. This
        /// <br/>field is omitted if not supported.
        /// <br/>
        /// <br/>Kernel memory TCP limits are not supported when using cgroups v2, which
        /// <br/>does not support the corresponding `memory.kmem.tcp.limit_in_bytes` cgroup.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("KernelMemoryTCP")]
        public bool? KernelMemoryTCP { get; set; }

        /// <summary>
        /// Indicates if CPU CFS(Completely Fair Scheduler) period is supported by
        /// <br/>the host.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("CpuCfsPeriod")]
        public bool? CpuCfsPeriod { get; set; }

        /// <summary>
        /// Indicates if CPU CFS(Completely Fair Scheduler) quota is supported by
        /// <br/>the host.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("CpuCfsQuota")]
        public bool? CpuCfsQuota { get; set; }

        /// <summary>
        /// Indicates if CPU Shares limiting is supported by the host.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("CPUShares")]
        public bool? CPUShares { get; set; }

        /// <summary>
        /// Indicates if CPUsets (cpuset.cpus, cpuset.mems) are supported by the host.
        /// <br/>
        /// <br/>See [cpuset(7)](https://www.kernel.org/doc/Documentation/cgroup-v1/cpusets.txt)
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("CPUSet")]
        public bool? CPUSet { get; set; }

        /// <summary>
        /// Indicates if the host kernel has PID limit support enabled.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("PidsLimit")]
        public bool? PidsLimit { get; set; }

        /// <summary>
        /// Indicates if OOM killer disable is supported on the host.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("OomKillDisable")]
        public bool? OomKillDisable { get; set; }

        /// <summary>
        /// Indicates IPv4 forwarding is enabled.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("IPv4Forwarding")]
        public bool? IPv4Forwarding { get; set; }

        /// <summary>
        /// Indicates if `bridge-nf-call-iptables` is available on the host.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("BridgeNfIptables")]
        public bool? BridgeNfIptables { get; set; }

        /// <summary>
        /// Indicates if `bridge-nf-call-ip6tables` is available on the host.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("BridgeNfIp6tables")]
        public bool? BridgeNfIp6tables { get; set; }

        /// <summary>
        /// Indicates if the daemon is running in debug-mode / with debug-level
        /// <br/>logging enabled.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Debug")]
        public bool? Debug { get; set; }

        /// <summary>
        /// The total number of file Descriptors in use by the daemon process.
        /// <br/>
        /// <br/>This information is only returned if debug-mode is enabled.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("NFd")]
        public int? NFd { get; set; }

        /// <summary>
        /// The  number of goroutines that currently exist.
        /// <br/>
        /// <br/>This information is only returned if debug-mode is enabled.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("NGoroutines")]
        public int? NGoroutines { get; set; }

        /// <summary>
        /// Current system-time in [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt)
        /// <br/>format with nano-seconds.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("SystemTime")]
        public string SystemTime { get; set; }

        /// <summary>
        /// The logging driver to use as a default for new containers.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("LoggingDriver")]
        public string LoggingDriver { get; set; }

        /// <summary>
        /// The driver to use for managing cgroups.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("CgroupDriver")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public SystemInfoCgroupDriver? CgroupDriver { get; set; } = DockerEngine.SystemInfoCgroupDriver.Cgroupfs;

        /// <summary>
        /// The version of the cgroup.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("CgroupVersion")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public SystemInfoCgroupVersion? CgroupVersion { get; set; } = DockerEngine.SystemInfoCgroupVersion._1;

        /// <summary>
        /// Number of event listeners subscribed.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("NEventsListener")]
        public int? NEventsListener { get; set; }

        /// <summary>
        /// Kernel version of the host.
        /// <br/>
        /// <br/>On Linux, this information obtained from `uname`. On Windows this
        /// <br/>information is queried from the &lt;kbd&gt;HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\&lt;/kbd&gt;
        /// <br/>registry value, for example _"10.0 14393 (14393.1198.amd64fre.rs1_release_sec.170427-1353)"_.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("KernelVersion")]
        public string KernelVersion { get; set; }

        /// <summary>
        /// Name of the host's operating system, for example: "Ubuntu 24.04 LTS"
        /// <br/>or "Windows Server 2016 Datacenter"
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("OperatingSystem")]
        public string OperatingSystem { get; set; }

        /// <summary>
        /// Version of the host's operating system
        /// <br/>
        /// <br/>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
        /// <br/>
        /// <br/>&gt; **Note**: The information returned in this field, including its
        /// <br/>&gt; very existence, and the formatting of values, should not be considered
        /// <br/>&gt; stable, and may change without notice.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("OSVersion")]
        public string OSVersion { get; set; }

        /// <summary>
        /// Generic type of the operating system of the host, as returned by the
        /// <br/>Go runtime (`GOOS`).
        /// <br/>
        /// <br/>Currently returned values are "linux" and "windows". A full list of
        /// <br/>possible values can be found in the [Go documentation](https://go.dev/doc/install/source#environment).
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("OSType")]
        public string OSType { get; set; }

        /// <summary>
        /// Hardware architecture of the host, as returned by the Go runtime
        /// <br/>(`GOARCH`).
        /// <br/>
        /// <br/>A full list of possible values can be found in the [Go documentation](https://go.dev/doc/install/source#environment).
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Architecture")]
        public string Architecture { get; set; }

        /// <summary>
        /// The number of logical CPUs usable by the daemon.
        /// <br/>
        /// <br/>The number of available CPUs is checked by querying the operating
        /// <br/>system when the daemon starts. Changes to operating system CPU
        /// <br/>allocation after the daemon is started are not reflected.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("NCPU")]
        public int? NCPU { get; set; }

        /// <summary>
        /// Total amount of physical memory available on the host, in bytes.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("MemTotal")]
        public long? MemTotal { get; set; }

        /// <summary>
        /// Address / URL of the index server that is used for image search,
        /// <br/>and as a default for user authentication for Docker Hub and Docker Cloud.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("IndexServerAddress")]
        public string IndexServerAddress { get; set; } = "https://index.docker.io/v1/";

        [System.Text.Json.Serialization.JsonPropertyName("RegistryConfig")]
        public RegistryServiceConfig RegistryConfig { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("GenericResources")]
        public GenericResources GenericResources { get; set; }

        /// <summary>
        /// HTTP-proxy configured for the daemon. This value is obtained from the
        /// <br/>[`HTTP_PROXY`](https://www.gnu.org/software/wget/manual/html_node/Proxies.html) environment variable.
        /// <br/>Credentials ([user info component](https://tools.ietf.org/html/rfc3986#section-3.2.1)) in the proxy URL
        /// <br/>are masked in the API response.
        /// <br/>
        /// <br/>Containers do not automatically inherit this configuration.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("HttpProxy")]
        public string HttpProxy { get; set; }

        /// <summary>
        /// HTTPS-proxy configured for the daemon. This value is obtained from the
        /// <br/>[`HTTPS_PROXY`](https://www.gnu.org/software/wget/manual/html_node/Proxies.html) environment variable.
        /// <br/>Credentials ([user info component](https://tools.ietf.org/html/rfc3986#section-3.2.1)) in the proxy URL
        /// <br/>are masked in the API response.
        /// <br/>
        /// <br/>Containers do not automatically inherit this configuration.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("HttpsProxy")]
        public string HttpsProxy { get; set; }

        /// <summary>
        /// Comma-separated list of domain extensions for which no proxy should be
        /// <br/>used. This value is obtained from the [`NO_PROXY`](https://www.gnu.org/software/wget/manual/html_node/Proxies.html)
        /// <br/>environment variable.
        /// <br/>
        /// <br/>Containers do not automatically inherit this configuration.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("NoProxy")]
        public string NoProxy { get; set; }

        /// <summary>
        /// Hostname of the host.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Name")]
        public string Name { get; set; }

        /// <summary>
        /// User-defined labels (key/value metadata) as set on the daemon.
        /// <br/>
        /// <br/>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
        /// <br/>
        /// <br/>&gt; **Note**: When part of a Swarm, nodes can both have _daemon_ labels,
        /// <br/>&gt; set through the daemon configuration, and _node_ labels, set from a
        /// <br/>&gt; manager node in the Swarm. Node labels are not included in this
        /// <br/>&gt; field. Node labels can be retrieved using the `/nodes/(id)` endpoint
        /// <br/>&gt; on a manager node in the Swarm.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Labels")]
        public System.Collections.Generic.ICollection<string> Labels { get; set; }

        /// <summary>
        /// Indicates if experimental features are enabled on the daemon.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ExperimentalBuild")]
        public bool? ExperimentalBuild { get; set; }

        /// <summary>
        /// Version string of the daemon.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ServerVersion")]
        public string ServerVersion { get; set; }

        /// <summary>
        /// List of [OCI compliant](https://github.com/opencontainers/runtime-spec)
        /// <br/>runtimes configured on the daemon. Keys hold the "name" used to
        /// <br/>reference the runtime.
        /// <br/>
        /// <br/>The Docker daemon relies on an OCI compliant runtime (invoked via the
        /// <br/>`containerd` daemon) as its interface to the Linux kernel namespaces,
        /// <br/>cgroups, and SELinux.
        /// <br/>
        /// <br/>The default runtime is `runc`, and automatically configured. Additional
        /// <br/>runtimes can be configured by the user and will be listed here.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Runtimes")]
        public System.Collections.Generic.IDictionary<string, Runtime> Runtimes { get; set; }

        /// <summary>
        /// Name of the default OCI runtime that is used when starting containers.
        /// <br/>
        /// <br/>The default can be overridden per-container at create time.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("DefaultRuntime")]
        public string DefaultRuntime { get; set; } = "runc";

        [System.Text.Json.Serialization.JsonPropertyName("Swarm")]
        public SwarmInfo Swarm { get; set; }

        /// <summary>
        /// Indicates if live restore is enabled.
        /// <br/>
        /// <br/>If enabled, containers are kept running when the daemon is shutdown
        /// <br/>or upon daemon start if running containers are detected.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("LiveRestoreEnabled")]
        public bool? LiveRestoreEnabled { get; set; } = false;

        /// <summary>
        /// Represents the isolation technology to use as a default for containers.
        /// <br/>The supported values are platform-specific.
        /// <br/>
        /// <br/>If no isolation value is specified on daemon start, on Windows client,
        /// <br/>the default is `hyperv`, and on Windows server, the default is `process`.
        /// <br/>
        /// <br/>This option is currently not used on other platforms.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Isolation")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public SystemInfoIsolation? Isolation { get; set; } = DockerEngine.SystemInfoIsolation.Default;

        /// <summary>
        /// Name and, optional, path of the `docker-init` binary.
        /// <br/>
        /// <br/>If the path is omitted, the daemon searches the host's `$PATH` for the
        /// <br/>binary and uses the first result.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("InitBinary")]
        public string InitBinary { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("ContainerdCommit")]
        public Commit ContainerdCommit { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("RuncCommit")]
        public Commit RuncCommit { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("InitCommit")]
        public Commit InitCommit { get; set; }

        /// <summary>
        /// List of security features that are enabled on the daemon, such as
        /// <br/>apparmor, seccomp, SELinux, user-namespaces (userns), rootless and
        /// <br/>no-new-privileges.
        /// <br/>
        /// <br/>Additional configuration options for each security feature may
        /// <br/>be present, and are included as a comma-separated list of key/value
        /// <br/>pairs.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("SecurityOptions")]
        public System.Collections.Generic.ICollection<string> SecurityOptions { get; set; }

        /// <summary>
        /// Reports a summary of the product license on the daemon.
        /// <br/>
        /// <br/>If a commercial license has been applied to the daemon, information
        /// <br/>such as number of nodes, and expiration are included.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ProductLicense")]
        public string ProductLicense { get; set; }

        /// <summary>
        /// List of custom default address pools for local networks, which can be
        /// <br/>specified in the daemon.json file or dockerd option.
        /// <br/>
        /// <br/>Example: a Base "10.10.0.0/16" with Size 24 will define the set of 256
        /// <br/>10.10.[0-255].0/24 address pools.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("DefaultAddressPools")]
        public System.Collections.Generic.ICollection<DefaultAddressPools> DefaultAddressPools { get; set; }

        /// <summary>
        /// List of warnings / informational messages about missing features, or
        /// <br/>issues related to the daemon configuration.
        /// <br/>
        /// <br/>These messages can be printed by the client as information to the user.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Warnings")]
        public System.Collections.Generic.ICollection<string> Warnings { get; set; }

        /// <summary>
        /// List of directories where (Container Device Interface) CDI
        /// <br/>specifications are located.
        /// <br/>
        /// <br/>These specifications define vendor-specific modifications to an OCI
        /// <br/>runtime specification for a container being created.
        /// <br/>
        /// <br/>An empty list indicates that CDI device injection is disabled.
        /// <br/>
        /// <br/>Note that since using CDI device injection requires the daemon to have
        /// <br/>experimental enabled. For non-experimental daemons an empty list will
        /// <br/>always be returned.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("CDISpecDirs")]
        public System.Collections.Generic.ICollection<string> CDISpecDirs { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Containerd")]
        public ContainerdInfo Containerd { get; set; }

    }

    /// <summary>
    /// Information for connecting to the containerd instance that is used by the daemon.
    /// <br/>This is included for debugging purposes only.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ContainerdInfo
    {
        /// <summary>
        /// The address of the containerd socket.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Address")]
        public string Address { get; set; }

        /// <summary>
        /// The namespaces that the daemon uses for running containers and
        /// <br/>plugins in containerd. These namespaces can be configured in the
        /// <br/>daemon configuration, and are considered to be used exclusively
        /// <br/>by the daemon, Tampering with the containerd instance may cause
        /// <br/>unexpected behavior.
        /// <br/>
        /// <br/>As these namespaces are considered to be exclusively accessed
        /// <br/>by the daemon, it is not recommended to change these values,
        /// <br/>or to change them to a value that is used by other systems,
        /// <br/>such as cri-containerd.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Namespaces")]
        public Namespaces Namespaces { get; set; }

    }

    /// <summary>
    /// Available plugins per type.
    /// <br/>
    /// <br/>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
    /// <br/>
    /// <br/>&gt; **Note**: Only unmanaged (V1) plugins are included in this list.
    /// <br/>&gt; V1 plugins are "lazily" loaded, and are not returned in this list
    /// <br/>&gt; if there is no resource using the plugin.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PluginsInfo
    {
        /// <summary>
        /// Names of available volume-drivers, and network-driver plugins.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Volume")]
        public System.Collections.Generic.ICollection<string> Volume { get; set; }

        /// <summary>
        /// Names of available network-drivers, and network-driver plugins.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Network")]
        public System.Collections.Generic.ICollection<string> Network { get; set; }

        /// <summary>
        /// Names of available authorization plugins.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Authorization")]
        public System.Collections.Generic.ICollection<string> Authorization { get; set; }

        /// <summary>
        /// Names of available logging-drivers, and logging-driver plugins.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Log")]
        public System.Collections.Generic.ICollection<string> Log { get; set; }

    }

    /// <summary>
    /// RegistryServiceConfig stores daemon registry services configuration.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class RegistryServiceConfig
    {
        /// <summary>
        /// List of IP ranges to which nondistributable artifacts can be pushed,
        /// <br/>using the CIDR syntax [RFC 4632](https://tools.ietf.org/html/4632).
        /// <br/>
        /// <br/>Some images (for example, Windows base images) contain artifacts
        /// <br/>whose distribution is restricted by license. When these images are
        /// <br/>pushed to a registry, restricted artifacts are not included.
        /// <br/>
        /// <br/>This configuration override this behavior, and enables the daemon to
        /// <br/>push nondistributable artifacts to all registries whose resolved IP
        /// <br/>address is within the subnet described by the CIDR syntax.
        /// <br/>
        /// <br/>This option is useful when pushing images containing
        /// <br/>nondistributable artifacts to a registry on an air-gapped network so
        /// <br/>hosts on that network can pull the images without connecting to
        /// <br/>another server.
        /// <br/>
        /// <br/>&gt; **Warning**: Nondistributable artifacts typically have restrictions
        /// <br/>&gt; on how and where they can be distributed and shared. Only use this
        /// <br/>&gt; feature to push artifacts to private registries and ensure that you
        /// <br/>&gt; are in compliance with any terms that cover redistributing
        /// <br/>&gt; nondistributable artifacts.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("AllowNondistributableArtifactsCIDRs")]
        public System.Collections.Generic.ICollection<string> AllowNondistributableArtifactsCIDRs { get; set; }

        /// <summary>
        /// List of registry hostnames to which nondistributable artifacts can be
        /// <br/>pushed, using the format `&lt;hostname&gt;[:&lt;port&gt;]` or `&lt;IP address&gt;[:&lt;port&gt;]`.
        /// <br/>
        /// <br/>Some images (for example, Windows base images) contain artifacts
        /// <br/>whose distribution is restricted by license. When these images are
        /// <br/>pushed to a registry, restricted artifacts are not included.
        /// <br/>
        /// <br/>This configuration override this behavior for the specified
        /// <br/>registries.
        /// <br/>
        /// <br/>This option is useful when pushing images containing
        /// <br/>nondistributable artifacts to a registry on an air-gapped network so
        /// <br/>hosts on that network can pull the images without connecting to
        /// <br/>another server.
        /// <br/>
        /// <br/>&gt; **Warning**: Nondistributable artifacts typically have restrictions
        /// <br/>&gt; on how and where they can be distributed and shared. Only use this
        /// <br/>&gt; feature to push artifacts to private registries and ensure that you
        /// <br/>&gt; are in compliance with any terms that cover redistributing
        /// <br/>&gt; nondistributable artifacts.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("AllowNondistributableArtifactsHostnames")]
        public System.Collections.Generic.ICollection<string> AllowNondistributableArtifactsHostnames { get; set; }

        /// <summary>
        /// List of IP ranges of insecure registries, using the CIDR syntax
        /// <br/>([RFC 4632](https://tools.ietf.org/html/4632)). Insecure registries
        /// <br/>accept un-encrypted (HTTP) and/or untrusted (HTTPS with certificates
        /// <br/>from unknown CAs) communication.
        /// <br/>
        /// <br/>By default, local registries (`127.0.0.0/8`) are configured as
        /// <br/>insecure. All other registries are secure. Communicating with an
        /// <br/>insecure registry is not possible if the daemon assumes that registry
        /// <br/>is secure.
        /// <br/>
        /// <br/>This configuration override this behavior, insecure communication with
        /// <br/>registries whose resolved IP address is within the subnet described by
        /// <br/>the CIDR syntax.
        /// <br/>
        /// <br/>Registries can also be marked insecure by hostname. Those registries
        /// <br/>are listed under `IndexConfigs` and have their `Secure` field set to
        /// <br/>`false`.
        /// <br/>
        /// <br/>&gt; **Warning**: Using this option can be useful when running a local
        /// <br/>&gt; registry, but introduces security vulnerabilities. This option
        /// <br/>&gt; should therefore ONLY be used for testing purposes. For increased
        /// <br/>&gt; security, users should add their CA to their system's list of trusted
        /// <br/>&gt; CAs instead of enabling this option.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("InsecureRegistryCIDRs")]
        public System.Collections.Generic.ICollection<string> InsecureRegistryCIDRs { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("IndexConfigs")]
        public System.Collections.Generic.IDictionary<string, IndexInfo> IndexConfigs { get; set; }

        /// <summary>
        /// List of registry URLs that act as a mirror for the official
        /// <br/>(`docker.io`) registry.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Mirrors")]
        public System.Collections.Generic.ICollection<string> Mirrors { get; set; }

    }

    /// <summary>
    /// IndexInfo contains information about a registry.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class IndexInfo
    {
        /// <summary>
        /// Name of the registry, such as "docker.io".
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Name")]
        public string Name { get; set; }

        /// <summary>
        /// List of mirrors, expressed as URIs.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Mirrors")]
        public System.Collections.Generic.ICollection<string> Mirrors { get; set; }

        /// <summary>
        /// Indicates if the registry is part of the list of insecure
        /// <br/>registries.
        /// <br/>
        /// <br/>If `false`, the registry is insecure. Insecure registries accept
        /// <br/>un-encrypted (HTTP) and/or untrusted (HTTPS with certificates from
        /// <br/>unknown CAs) communication.
        /// <br/>
        /// <br/>&gt; **Warning**: Insecure registries can be useful when running a local
        /// <br/>&gt; registry. However, because its use creates security vulnerabilities
        /// <br/>&gt; it should ONLY be enabled for testing purposes. For increased
        /// <br/>&gt; security, users should add their CA to their system's list of
        /// <br/>&gt; trusted CAs instead of enabling this option.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Secure")]
        public bool? Secure { get; set; }

        /// <summary>
        /// Indicates whether this is an official registry (i.e., Docker Hub / docker.io)
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Official")]
        public bool? Official { get; set; }

    }

    /// <summary>
    /// Runtime describes an [OCI compliant](https://github.com/opencontainers/runtime-spec)
    /// <br/>runtime.
    /// <br/>
    /// <br/>The runtime is invoked by the daemon via the `containerd` daemon. OCI
    /// <br/>runtimes act as an interface to the Linux kernel namespaces, cgroups,
    /// <br/>and SELinux.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Runtime
    {
        /// <summary>
        /// Name and, optional, path, of the OCI executable binary.
        /// <br/>
        /// <br/>If the path is omitted, the daemon searches the host's `$PATH` for the
        /// <br/>binary and uses the first result.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("path")]
        public string Path { get; set; }

        /// <summary>
        /// List of command-line arguments to pass to the runtime when invoked.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("runtimeArgs")]
        public System.Collections.Generic.ICollection<string> RuntimeArgs { get; set; }

        /// <summary>
        /// Information specific to the runtime.
        /// <br/>
        /// <br/>While this API specification does not define data provided by runtimes,
        /// <br/>the following well-known properties may be provided by runtimes:
        /// <br/>
        /// <br/>`org.opencontainers.runtime-spec.features`: features structure as defined
        /// <br/>in the [OCI Runtime Specification](https://github.com/opencontainers/runtime-spec/blob/main/features.md),
        /// <br/>in a JSON string representation.
        /// <br/>
        /// <br/>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
        /// <br/>
        /// <br/>&gt; **Note**: The information returned in this field, including the
        /// <br/>&gt; formatting of values and labels, should not be considered stable,
        /// <br/>&gt; and may change without notice.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("status")]
        public System.Collections.Generic.IDictionary<string, string> Status { get; set; }

    }

    /// <summary>
    /// Commit holds the Git-commit (SHA1) that a binary was built from, as
    /// <br/>reported in the version-string of external tools, such as `containerd`,
    /// <br/>or `runC`.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Commit
    {
        /// <summary>
        /// Actual commit ID of external tool.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ID")]
        public string ID { get; set; }

        /// <summary>
        /// Commit ID of external tool expected by dockerd as set at build time.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Expected")]
        public string Expected { get; set; }

    }

    /// <summary>
    /// Represents generic information about swarm.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SwarmInfo
    {
        /// <summary>
        /// Unique identifier of for this node in the swarm.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("NodeID")]
        public string NodeID { get; set; } = "";

        /// <summary>
        /// IP address at which this node can be reached by other nodes in the
        /// <br/>swarm.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("NodeAddr")]
        public string NodeAddr { get; set; } = "";

        [System.Text.Json.Serialization.JsonPropertyName("LocalNodeState")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public LocalNodeState? LocalNodeState { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("ControlAvailable")]
        public bool? ControlAvailable { get; set; } = false;

        [System.Text.Json.Serialization.JsonPropertyName("Error")]
        public string Error { get; set; } = "";

        /// <summary>
        /// List of ID's and addresses of other managers in the swarm.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("RemoteManagers")]
        public System.Collections.Generic.ICollection<PeerNode> RemoteManagers { get; set; }

        /// <summary>
        /// Total number of nodes in the swarm.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Nodes")]
        public int? Nodes { get; set; }

        /// <summary>
        /// Total number of managers in the swarm.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Managers")]
        public int? Managers { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Cluster")]
        public ClusterInfo Cluster { get; set; }

    }

    /// <summary>
    /// Current local status of this node.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum LocalNodeState
    {

        [System.Runtime.Serialization.EnumMember(Value = @"")]
        Empty = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"inactive")]
        Inactive = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"pending")]
        Pending = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"active")]
        Active = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"error")]
        Error = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"locked")]
        Locked = 5,

    }

    /// <summary>
    /// Represents a peer-node in the swarm
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PeerNode
    {
        /// <summary>
        /// Unique identifier of for this node in the swarm.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("NodeID")]
        public string NodeID { get; set; }

        /// <summary>
        /// IP address and ports at which this node can be reached.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Addr")]
        public string Addr { get; set; }

    }

    /// <summary>
    /// Specifies how a service should be attached to a particular network.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NetworkAttachmentConfig
    {
        /// <summary>
        /// The target network for attachment. Must be a network name or ID.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Target")]
        public string Target { get; set; }

        /// <summary>
        /// Discoverable alternate names for the service on this network.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Aliases")]
        public System.Collections.Generic.ICollection<string> Aliases { get; set; }

        /// <summary>
        /// Driver attachment options for the network target.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("DriverOpts")]
        public System.Collections.Generic.IDictionary<string, string> DriverOpts { get; set; }

    }

    /// <summary>
    /// Actor describes something that generates events, like a container, network,
    /// <br/>or a volume.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EventActor
    {
        /// <summary>
        /// The ID of the object emitting the event
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ID")]
        public string ID { get; set; }

        /// <summary>
        /// Various key/value attributes of the object, depending on its type.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Attributes")]
        public System.Collections.Generic.IDictionary<string, string> Attributes { get; set; }

    }

    /// <summary>
    /// EventMessage represents the information an event contains.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EventMessage
    {
        /// <summary>
        /// The type of object emitting the event
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Type")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public EventMessageType? Type { get; set; }

        /// <summary>
        /// The type of event
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Action")]
        public string Action { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Actor")]
        public EventActor Actor { get; set; }

        /// <summary>
        /// Scope of the event. Engine events are `local` scope. Cluster (Swarm)
        /// <br/>events are `swarm` scope.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("scope")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public EventMessageScope? Scope { get; set; }

        /// <summary>
        /// Timestamp of event
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("time")]
        public long? Time { get; set; }

        /// <summary>
        /// Timestamp of event, with nanosecond accuracy
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("timeNano")]
        public long? TimeNano { get; set; }

    }

    /// <summary>
    /// A descriptor struct containing digest, media type, and size, as defined in
    /// <br/>the [OCI Content Descriptors Specification](https://github.com/opencontainers/image-spec/blob/v1.0.1/descriptor.md).
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class OCIDescriptor
    {
        /// <summary>
        /// The media type of the object this schema refers to.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("mediaType")]
        public string MediaType { get; set; }

        /// <summary>
        /// The digest of the targeted content.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("digest")]
        public string Digest { get; set; }

        /// <summary>
        /// The size in bytes of the blob.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("size")]
        public long? Size { get; set; }

    }

    /// <summary>
    /// Describes the platform which the image in the manifest runs on, as defined
    /// <br/>in the [OCI Image Index Specification](https://github.com/opencontainers/image-spec/blob/v1.0.1/image-index.md).
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class OCIPlatform
    {
        /// <summary>
        /// The CPU architecture, for example `amd64` or `ppc64`.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("architecture")]
        public string Architecture { get; set; }

        /// <summary>
        /// The operating system, for example `linux` or `windows`.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("os")]
        public string Os { get; set; }

        /// <summary>
        /// Optional field specifying the operating system version, for example on
        /// <br/>Windows `10.0.19041.1165`.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("os.version")]
        public string OsVersion { get; set; }

        /// <summary>
        /// Optional field specifying an array of strings, each listing a required
        /// <br/>OS feature (for example on Windows `win32k`).
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("os.features")]
        public System.Collections.Generic.ICollection<string> OsFeatures { get; set; }

        /// <summary>
        /// Optional field specifying a variant of the CPU, for example `v7` to
        /// <br/>specify ARMv7 when architecture is `arm`.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("variant")]
        public string Variant { get; set; }

    }

    /// <summary>
    /// Describes the result obtained from contacting the registry to retrieve
    /// <br/>image metadata.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class DistributionInspect
    {

        [System.Text.Json.Serialization.JsonPropertyName("Descriptor")]
        [System.ComponentModel.DataAnnotations.Required]
        public OCIDescriptor Descriptor { get; set; } = new OCIDescriptor();

        /// <summary>
        /// An array containing all platforms supported by the image.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Platforms")]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<OCIPlatform> Platforms { get; } = new System.Collections.ObjectModel.Collection<OCIPlatform>();

    }

    /// <summary>
    /// Options and information specific to, and only present on, Swarm CSI
    /// <br/>cluster volumes.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ClusterVolume
    {
        /// <summary>
        /// The Swarm ID of this volume. Because cluster volumes are Swarm
        /// <br/>objects, they have an ID, unlike non-cluster volumes. This ID can
        /// <br/>be used to refer to the Volume instead of the name.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ID")]
        public string ID { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Version")]
        public ObjectVersion Version { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("CreatedAt")]
        public string CreatedAt { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("UpdatedAt")]
        public string UpdatedAt { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Spec")]
        public ClusterVolumeSpec Spec { get; set; }

        /// <summary>
        /// Information about the global status of the volume.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Info")]
        public Info Info { get; set; }

        /// <summary>
        /// The status of the volume as it pertains to its publishing and use on
        /// <br/>specific nodes
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("PublishStatus")]
        public System.Collections.Generic.ICollection<PublishStatus> PublishStatus { get; set; }

    }

    /// <summary>
    /// Cluster-specific options used to create the volume.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ClusterVolumeSpec
    {
        /// <summary>
        /// Group defines the volume group of this volume. Volumes belonging to
        /// <br/>the same group can be referred to by group name when creating
        /// <br/>Services.  Referring to a volume by group instructs Swarm to treat
        /// <br/>volumes in that group interchangeably for the purpose of scheduling.
        /// <br/>Volumes with an empty string for a group technically all belong to
        /// <br/>the same, emptystring group.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Group")]
        public string Group { get; set; }

        /// <summary>
        /// Defines how the volume is used by tasks.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("AccessMode")]
        public AccessMode AccessMode { get; set; }

    }

    /// <summary>
    /// A map of topological domains to topological segments. For in depth
    /// <br/>details, see documentation for the Topology object in the CSI
    /// <br/>specification.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Topology : System.Collections.Generic.Dictionary<string, string>
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Body : ContainerConfig
    {

        [System.Text.Json.Serialization.JsonPropertyName("HostConfig")]
        public HostConfig HostConfig { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("NetworkingConfig")]
        public NetworkingConfig NetworkingConfig { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Update : Resources
    {

        [System.Text.Json.Serialization.JsonPropertyName("RestartPolicy")]
        public RestartPolicy RestartPolicy { get; set; }

    }

    /// <summary>
    /// Wait until a container state reaches the given condition.
    /// <br/>
    /// <br/>Defaults to `not-running` if omitted or empty.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Condition
    {

        [System.Runtime.Serialization.EnumMember(Value = @"not-running")]
        NotRunning = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"next-exit")]
        NextExit = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"removed")]
        Removed = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ContentType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"application/x-tar")]
        Application_xTar = 0,

    }

    /// <summary>
    /// Version of the builder backend to use.
    /// <br/>
    /// <br/>- `1` is the first generation classic (deprecated) builder in the Docker daemon (default)
    /// <br/>- `2` is [BuildKit](https://github.com/moby/buildkit)
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Version
    {

        [System.Runtime.Serialization.EnumMember(Value = @"1")]
        _1 = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"2")]
        _2 = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Anonymous
    {

        [System.Runtime.Serialization.EnumMember(Value = @"container")]
        Container = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"image")]
        Image = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"volume")]
        Volume = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"build-cache")]
        BuildCache = 3,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ExecConfig
    {
        /// <summary>
        /// Attach to `stdin` of the exec command.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("AttachStdin")]
        public bool? AttachStdin { get; set; }

        /// <summary>
        /// Attach to `stdout` of the exec command.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("AttachStdout")]
        public bool? AttachStdout { get; set; }

        /// <summary>
        /// Attach to `stderr` of the exec command.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("AttachStderr")]
        public bool? AttachStderr { get; set; }

        /// <summary>
        /// Initial console size, as an `[height, width]` array.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ConsoleSize")]
        [System.ComponentModel.DataAnnotations.MinLength(2)]
        [System.ComponentModel.DataAnnotations.MaxLength(2)]
        public System.Collections.Generic.ICollection<int> ConsoleSize { get; set; }

        /// <summary>
        /// Override the key sequence for detaching a container. Format is
        /// <br/>a single character `[a-Z]` or `ctrl-&lt;value&gt;` where `&lt;value&gt;`
        /// <br/>is one of: `a-z`, `@`, `^`, `[`, `,` or `_`.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("DetachKeys")]
        public string DetachKeys { get; set; }

        /// <summary>
        /// Allocate a pseudo-TTY.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Tty")]
        public bool? Tty { get; set; }

        /// <summary>
        /// A list of environment variables in the form `["VAR=value", ...]`.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Env")]
        public System.Collections.Generic.ICollection<string> Env { get; set; }

        /// <summary>
        /// Command to run, as a string or array of strings.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Cmd")]
        public System.Collections.Generic.ICollection<string> Cmd { get; set; }

        /// <summary>
        /// Runs the exec process with extended privileges.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Privileged")]
        public bool? Privileged { get; set; } = false;

        /// <summary>
        /// The user, and optionally, group to run the exec process inside
        /// <br/>the container. Format is one of: `user`, `user:group`, `uid`,
        /// <br/>or `uid:gid`.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("User")]
        public string User { get; set; }

        /// <summary>
        /// The working directory for the exec process inside the container.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("WorkingDir")]
        public string WorkingDir { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ExecStartConfig
    {
        /// <summary>
        /// Detach from the command.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Detach")]
        public bool? Detach { get; set; }

        /// <summary>
        /// Allocate a pseudo-TTY.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Tty")]
        public bool? Tty { get; set; }

        /// <summary>
        /// Initial console size, as an `[height, width]` array.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ConsoleSize")]
        [System.ComponentModel.DataAnnotations.MinLength(2)]
        [System.ComponentModel.DataAnnotations.MaxLength(2)]
        public System.Collections.Generic.ICollection<int> ConsoleSize { get; set; }

    }

    /// <summary>
    /// Volume configuration
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Body2
    {

        [System.Text.Json.Serialization.JsonPropertyName("Spec")]
        public ClusterVolumeSpec Spec { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NetworkCreateRequest
    {
        /// <summary>
        /// The network's name.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Name")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// Name of the network driver plugin to use.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Driver")]
        public string Driver { get; set; } = "bridge";

        /// <summary>
        /// The level at which the network exists (e.g. `swarm` for cluster-wide
        /// <br/>or `local` for machine level).
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Scope")]
        public string Scope { get; set; }

        /// <summary>
        /// Restrict external access to the network.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Internal")]
        public bool? Internal { get; set; }

        /// <summary>
        /// Globally scoped network is manually attachable by regular
        /// <br/>containers from workers in swarm mode.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Attachable")]
        public bool? Attachable { get; set; }

        /// <summary>
        /// Ingress network is the network which provides the routing-mesh
        /// <br/>in swarm mode.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Ingress")]
        public bool? Ingress { get; set; }

        /// <summary>
        /// Creates a config-only network. Config-only networks are placeholder
        /// <br/>networks for network configurations to be used by other networks.
        /// <br/>Config-only networks cannot be used directly to run containers
        /// <br/>or services.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ConfigOnly")]
        public bool? ConfigOnly { get; set; } = false;

        /// <summary>
        /// Specifies the source which will provide the configuration for
        /// <br/>this network. The specified network must be an existing
        /// <br/>config-only network; see ConfigOnly.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ConfigFrom")]
        public ConfigReference ConfigFrom { get; set; }

        /// <summary>
        /// Optional custom IP scheme for the network.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("IPAM")]
        public IPAM IPAM { get; set; }

        /// <summary>
        /// Enable IPv6 on the network.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("EnableIPv6")]
        public bool? EnableIPv6 { get; set; }

        /// <summary>
        /// Network specific options to be used by the drivers.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Options")]
        public System.Collections.Generic.IDictionary<string, string> Options { get; set; }

        /// <summary>
        /// User-defined key/value metadata.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Labels")]
        public System.Collections.Generic.IDictionary<string, string> Labels { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NetworkConnectRequest
    {
        /// <summary>
        /// The ID or name of the container to connect to the network.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Container")]
        public string Container { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("EndpointConfig")]
        public EndpointSettings EndpointConfig { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NetworkDisconnectRequest
    {
        /// <summary>
        /// The ID or name of the container to disconnect from the network.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Container")]
        public string Container { get; set; }

        /// <summary>
        /// Force the container to disconnect from the network.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Force")]
        public bool? Force { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SwarmInitRequest
    {
        /// <summary>
        /// Listen address used for inter-manager communication, as well
        /// <br/>as determining the networking interface used for the VXLAN
        /// <br/>Tunnel Endpoint (VTEP). This can either be an address/port
        /// <br/>combination in the form `192.168.1.1:4567`, or an interface
        /// <br/>followed by a port number, like `eth0:4567`. If the port number
        /// <br/>is omitted, the default swarm listening port is used.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ListenAddr")]
        public string ListenAddr { get; set; }

        /// <summary>
        /// Externally reachable address advertised to other nodes. This
        /// <br/>can either be an address/port combination in the form
        /// <br/>`192.168.1.1:4567`, or an interface followed by a port number,
        /// <br/>like `eth0:4567`. If the port number is omitted, the port
        /// <br/>number from the listen address is used. If `AdvertiseAddr` is
        /// <br/>not specified, it will be automatically detected when possible.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("AdvertiseAddr")]
        public string AdvertiseAddr { get; set; }

        /// <summary>
        /// Address or interface to use for data path traffic (format:
        /// <br/>`&lt;ip|interface&gt;`), for example,  `192.168.1.1`, or an interface,
        /// <br/>like `eth0`. If `DataPathAddr` is unspecified, the same address
        /// <br/>as `AdvertiseAddr` is used.
        /// <br/>
        /// <br/>The `DataPathAddr` specifies the address that global scope
        /// <br/>network drivers will publish towards other  nodes in order to
        /// <br/>reach the containers running on this node. Using this parameter
        /// <br/>it is possible to separate the container data traffic from the
        /// <br/>management traffic of the cluster.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("DataPathAddr")]
        public string DataPathAddr { get; set; }

        /// <summary>
        /// DataPathPort specifies the data path port number for data traffic.
        /// <br/>Acceptable port range is 1024 to 49151.
        /// <br/>if no port is set or is set to 0, default port 4789 will be used.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("DataPathPort")]
        public int? DataPathPort { get; set; }

        /// <summary>
        /// Default Address Pool specifies default subnet pools for global
        /// <br/>scope networks.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("DefaultAddrPool")]
        public System.Collections.Generic.ICollection<string> DefaultAddrPool { get; set; }

        /// <summary>
        /// Force creation of a new swarm.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ForceNewCluster")]
        public bool? ForceNewCluster { get; set; }

        /// <summary>
        /// SubnetSize specifies the subnet size of the networks created
        /// <br/>from the default subnet pool.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("SubnetSize")]
        public int? SubnetSize { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Spec")]
        public SwarmSpec Spec { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SwarmJoinRequest
    {
        /// <summary>
        /// Listen address used for inter-manager communication if the node
        /// <br/>gets promoted to manager, as well as determining the networking
        /// <br/>interface used for the VXLAN Tunnel Endpoint (VTEP).
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ListenAddr")]
        public string ListenAddr { get; set; }

        /// <summary>
        /// Externally reachable address advertised to other nodes. This
        /// <br/>can either be an address/port combination in the form
        /// <br/>`192.168.1.1:4567`, or an interface followed by a port number,
        /// <br/>like `eth0:4567`. If the port number is omitted, the port
        /// <br/>number from the listen address is used. If `AdvertiseAddr` is
        /// <br/>not specified, it will be automatically detected when possible.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("AdvertiseAddr")]
        public string AdvertiseAddr { get; set; }

        /// <summary>
        /// Address or interface to use for data path traffic (format:
        /// <br/>`&lt;ip|interface&gt;`), for example,  `192.168.1.1`, or an interface,
        /// <br/>like `eth0`. If `DataPathAddr` is unspecified, the same address
        /// <br/>as `AdvertiseAddr` is used.
        /// <br/>
        /// <br/>The `DataPathAddr` specifies the address that global scope
        /// <br/>network drivers will publish towards other nodes in order to
        /// <br/>reach the containers running on this node. Using this parameter
        /// <br/>it is possible to separate the container data traffic from the
        /// <br/>management traffic of the cluster.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("DataPathAddr")]
        public string DataPathAddr { get; set; }

        /// <summary>
        /// Addresses of manager nodes already participating in the swarm.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("RemoteAddrs")]
        public System.Collections.Generic.ICollection<string> RemoteAddrs { get; set; }

        /// <summary>
        /// Secret token for joining this swarm.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("JoinToken")]
        public string JoinToken { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SwarmUnlockRequest
    {
        /// <summary>
        /// The swarm's unlock key.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("UnlockKey")]
        public string UnlockKey { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Body3 : ServiceSpec
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Body4 : ServiceSpec
    {

    }

    /// <summary>
    /// If the `X-Registry-Auth` header is not specified, this parameter
    /// <br/>indicates where to find registry authorization credentials.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum RegistryAuthFrom
    {

        [System.Runtime.Serialization.EnumMember(Value = @"spec")]
        Spec = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"previous-spec")]
        PreviousSpec = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Body5 : SecretSpec
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Body6 : ConfigSpec
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ContainerInspectResponse
    {
        /// <summary>
        /// The ID of the container
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Id")]
        public string Id { get; set; }

        /// <summary>
        /// The time the container was created
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Created")]
        public string Created { get; set; }

        /// <summary>
        /// The path to the command being run
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Path")]
        public string Path { get; set; }

        /// <summary>
        /// The arguments to the command being run
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Args")]
        public System.Collections.Generic.ICollection<string> Args { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("State")]
        public ContainerState State { get; set; }

        /// <summary>
        /// The container's image ID
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Image")]
        public string Image { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("ResolvConfPath")]
        public string ResolvConfPath { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("HostnamePath")]
        public string HostnamePath { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("HostsPath")]
        public string HostsPath { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("LogPath")]
        public string LogPath { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Name")]
        public string Name { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("RestartCount")]
        public int? RestartCount { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Driver")]
        public string Driver { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Platform")]
        public string Platform { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("MountLabel")]
        public string MountLabel { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("ProcessLabel")]
        public string ProcessLabel { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("AppArmorProfile")]
        public string AppArmorProfile { get; set; }

        /// <summary>
        /// IDs of exec instances that are running in the container.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ExecIDs")]
        public System.Collections.Generic.ICollection<string> ExecIDs { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("HostConfig")]
        public HostConfig HostConfig { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("GraphDriver")]
        public GraphDriverData GraphDriver { get; set; }

        /// <summary>
        /// The size of files that have been created or changed by this
        /// <br/>container.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("SizeRw")]
        public long? SizeRw { get; set; }

        /// <summary>
        /// The total size of all the files in this container.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("SizeRootFs")]
        public long? SizeRootFs { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Mounts")]
        public System.Collections.Generic.ICollection<MountPoint> Mounts { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Config")]
        public ContainerConfig Config { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("NetworkSettings")]
        public NetworkSettings NetworkSettings { get; set; }

    }

    /// <summary>
    /// OK response to ContainerTop operation
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ContainerTopResponse
    {
        /// <summary>
        /// The ps column titles
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Titles")]
        public System.Collections.Generic.ICollection<string> Titles { get; set; }

        /// <summary>
        /// Each process running in the container, where each is process
        /// <br/>is an array of values corresponding to the titles.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Processes")]
        public System.Collections.Generic.ICollection<System.Collections.Generic.ICollection<string>> Processes { get; set; }

    }

    /// <summary>
    /// OK response to ContainerUpdate operation
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ContainerUpdateResponse
    {

        [System.Text.Json.Serialization.JsonPropertyName("Warnings")]
        public System.Collections.Generic.ICollection<string> Warnings { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ContainerPruneResponse
    {
        /// <summary>
        /// Container IDs that were deleted
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ContainersDeleted")]
        public System.Collections.Generic.ICollection<string> ContainersDeleted { get; set; }

        /// <summary>
        /// Disk space reclaimed in bytes
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("SpaceReclaimed")]
        public long? SpaceReclaimed { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class BuildPruneResponse
    {

        [System.Text.Json.Serialization.JsonPropertyName("CachesDeleted")]
        public System.Collections.Generic.ICollection<string> CachesDeleted { get; set; }

        /// <summary>
        /// Disk space reclaimed in bytes
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("SpaceReclaimed")]
        public long? SpaceReclaimed { get; set; }

    }

    /// <summary>
    /// individual image layer information in response to ImageHistory operation
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class HistoryResponseItem
    {

        [System.Text.Json.Serialization.JsonPropertyName("Id")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Created")]
        public long Created { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("CreatedBy")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string CreatedBy { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Tags")]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Tags { get; } = new System.Collections.ObjectModel.Collection<string>();

        [System.Text.Json.Serialization.JsonPropertyName("Size")]
        public long Size { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Comment")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Comment { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ImageSearchResponseItem
    {

        [System.Text.Json.Serialization.JsonPropertyName("description")]
        public string Description { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("is_official")]
        public bool? Is_official { get; set; }

        /// <summary>
        /// Whether this repository has automated builds enabled.
        /// <br/>
        /// <br/>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
        /// <br/>
        /// <br/>&gt; **Deprecated**: This field is deprecated and will always be "false".
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("is_automated")]
        public bool? Is_automated { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("name")]
        public string Name { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("star_count")]
        public int? Star_count { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ImagePruneResponse
    {
        /// <summary>
        /// Images that were deleted
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ImagesDeleted")]
        public System.Collections.Generic.ICollection<ImageDeleteResponseItem> ImagesDeleted { get; set; }

        /// <summary>
        /// Disk space reclaimed in bytes
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("SpaceReclaimed")]
        public long? SpaceReclaimed { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Response
    {
        /// <summary>
        /// The status of the authentication
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Status")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Status { get; set; }

        /// <summary>
        /// An opaque token used to authenticate a user after a successful login
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("IdentityToken")]
        public string IdentityToken { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SystemDataUsageResponse
    {

        [System.Text.Json.Serialization.JsonPropertyName("LayersSize")]
        public long? LayersSize { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Images")]
        public System.Collections.Generic.ICollection<ImageSummary> Images { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Containers")]
        public System.Collections.Generic.ICollection<ContainerSummary> Containers { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Volumes")]
        public System.Collections.Generic.ICollection<Volume> Volumes { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("BuildCache")]
        public System.Collections.Generic.ICollection<BuildCache> BuildCache { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ExecInspectResponse
    {

        [System.Text.Json.Serialization.JsonPropertyName("CanRemove")]
        public bool? CanRemove { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("DetachKeys")]
        public string DetachKeys { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("ID")]
        public string ID { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Running")]
        public bool? Running { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("ExitCode")]
        public int? ExitCode { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("ProcessConfig")]
        public ProcessConfig ProcessConfig { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("OpenStdin")]
        public bool? OpenStdin { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("OpenStderr")]
        public bool? OpenStderr { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("OpenStdout")]
        public bool? OpenStdout { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("ContainerID")]
        public string ContainerID { get; set; }

        /// <summary>
        /// The system process ID for the exec process.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Pid")]
        public int? Pid { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class VolumePruneResponse
    {
        /// <summary>
        /// Volumes that were deleted
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("VolumesDeleted")]
        public System.Collections.Generic.ICollection<string> VolumesDeleted { get; set; }

        /// <summary>
        /// Disk space reclaimed in bytes
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("SpaceReclaimed")]
        public long? SpaceReclaimed { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NetworkPruneResponse
    {
        /// <summary>
        /// Networks that were deleted
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("NetworksDeleted")]
        public System.Collections.Generic.ICollection<string> NetworksDeleted { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class UnlockKeyResponse
    {
        /// <summary>
        /// The swarm's unlock key.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("UnlockKey")]
        public string UnlockKey { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PortType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"tcp")]
        Tcp = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"udp")]
        Udp = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"sctp")]
        Sctp = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum MountPointType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"bind")]
        Bind = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"volume")]
        Volume = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"tmpfs")]
        Tmpfs = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"npipe")]
        Npipe = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"cluster")]
        Cluster = 4,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum MountType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"bind")]
        Bind = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"volume")]
        Volume = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"tmpfs")]
        Tmpfs = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"npipe")]
        Npipe = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"cluster")]
        Cluster = 4,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class BindOptions
    {
        /// <summary>
        /// A propagation mode with the value `[r]private`, `[r]shared`, or `[r]slave`.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Propagation")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public BindOptionsPropagation? Propagation { get; set; }

        /// <summary>
        /// Disable recursive bind mount.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("NonRecursive")]
        public bool? NonRecursive { get; set; } = false;

        /// <summary>
        /// Create mount point on host if missing
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("CreateMountpoint")]
        public bool? CreateMountpoint { get; set; } = false;

        /// <summary>
        /// Make the mount non-recursively read-only, but still leave the mount recursive
        /// <br/>(unless NonRecursive is set to `true` in conjunction).
        /// <br/>
        /// <br/>Addded in v1.44, before that version all read-only mounts were
        /// <br/>non-recursive by default. To match the previous behaviour this
        /// <br/>will default to `true` for clients on versions prior to v1.44.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ReadOnlyNonRecursive")]
        public bool? ReadOnlyNonRecursive { get; set; } = false;

        /// <summary>
        /// Raise an error if the mount cannot be made recursively read-only.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ReadOnlyForceRecursive")]
        public bool? ReadOnlyForceRecursive { get; set; } = false;

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class VolumeOptions
    {
        /// <summary>
        /// Populate volume with data from the target.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("NoCopy")]
        public bool? NoCopy { get; set; } = false;

        /// <summary>
        /// User-defined key/value metadata.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Labels")]
        public System.Collections.Generic.IDictionary<string, string> Labels { get; set; }

        /// <summary>
        /// Map of driver specific options
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("DriverConfig")]
        public DriverConfig DriverConfig { get; set; }

        /// <summary>
        /// Source path inside the volume. Must be relative without any back traversals.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Subpath")]
        public string Subpath { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TmpfsOptions
    {
        /// <summary>
        /// The size for the tmpfs mount in bytes.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("SizeBytes")]
        public long? SizeBytes { get; set; }

        /// <summary>
        /// The permission mode for the tmpfs mount in an integer.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Mode")]
        public int? Mode { get; set; }

        /// <summary>
        /// The options to be passed to the tmpfs mount. An array of arrays.
        /// <br/>Flag options should be provided as 1-length arrays. Other types
        /// <br/>should be provided as as 2-length arrays, where the first item is
        /// <br/>the key and the second the value.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Options")]
        public System.Collections.Generic.ICollection<System.Collections.Generic.ICollection<string>> Options { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum RestartPolicyName
    {

        [System.Runtime.Serialization.EnumMember(Value = @"")]
        Empty = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"no")]
        No = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"always")]
        Always = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"unless-stopped")]
        UnlessStopped = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"on-failure")]
        OnFailure = 4,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class BlkioWeightDevice
    {

        [System.Text.Json.Serialization.JsonPropertyName("Path")]
        public string Path { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Weight")]
        [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
        public int? Weight { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Ulimits
    {
        /// <summary>
        /// Name of ulimit
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Name")]
        public string Name { get; set; }

        /// <summary>
        /// Soft limit
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Soft")]
        public int? Soft { get; set; }

        /// <summary>
        /// Hard limit
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Hard")]
        public int? Hard { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Anonymous2
    {

        [System.Text.Json.Serialization.JsonPropertyName("NamedResourceSpec")]
        public NamedResourceSpec NamedResourceSpec { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("DiscreteResourceSpec")]
        public DiscreteResourceSpec DiscreteResourceSpec { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum HealthStatus
    {

        [System.Runtime.Serialization.EnumMember(Value = @"none")]
        None = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"starting")]
        Starting = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"healthy")]
        Healthy = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"unhealthy")]
        Unhealthy = 3,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class LogConfig
    {

        [System.Text.Json.Serialization.JsonPropertyName("Type")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public LogConfigType? Type { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Config")]
        public System.Collections.Generic.IDictionary<string, string> Config { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum HostConfigCgroupnsMode
    {

        [System.Runtime.Serialization.EnumMember(Value = @"private")]
        Private = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"host")]
        Host = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum HostConfigIsolation
    {

        [System.Runtime.Serialization.EnumMember(Value = @"default")]
        Default = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"process")]
        Process = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"hyperv")]
        Hyperv = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Anonymous3
    {

        [System.Runtime.Serialization.EnumMember(Value = @"{}")]
        __ = 0,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Anonymous4
    {

        [System.Runtime.Serialization.EnumMember(Value = @"{}")]
        __ = 0,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Anonymous5
    {

        [System.Runtime.Serialization.EnumMember(Value = @"{}")]
        __ = 0,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Anonymous6
    {

        [System.Runtime.Serialization.EnumMember(Value = @"{}")]
        __ = 0,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class RootFS
    {

        [System.Text.Json.Serialization.JsonPropertyName("Type")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Type { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Layers")]
        public System.Collections.Generic.ICollection<string> Layers { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Metadata
    {
        /// <summary>
        /// Date and time at which the image was last tagged in
        /// <br/>[RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds.
        /// <br/>
        /// <br/>This information is only available if the image was tagged locally,
        /// <br/>and omitted otherwise.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("LastTagTime")]
        public string LastTagTime { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum VolumeScope
    {

        [System.Runtime.Serialization.EnumMember(Value = @"local")]
        Local = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"global")]
        Global = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class UsageData
    {
        /// <summary>
        /// Amount of disk space used by the volume (in bytes). This information
        /// <br/>is only available for volumes created with the `"local"` volume
        /// <br/>driver. For volumes created with other volume drivers, this field
        /// <br/>is set to `-1` ("not available")
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Size")]
        public long Size { get; set; } = -1L;

        /// <summary>
        /// The number of containers referencing this volume. This field
        /// <br/>is set to `-1` if the reference-count is not available.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("RefCount")]
        public long RefCount { get; set; } = -1L;

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum BuildCacheType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"internal")]
        Internal = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"frontend")]
        Frontend = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"source.local")]
        Source_local = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"source.git.checkout")]
        Source_git_checkout = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"exec.cachemount")]
        Exec_cachemount = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"regular")]
        Regular = 5,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Settings
    {

        [System.Text.Json.Serialization.JsonPropertyName("Mounts")]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PluginMount> Mounts { get; } = new System.Collections.ObjectModel.Collection<PluginMount>();

        [System.Text.Json.Serialization.JsonPropertyName("Env")]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Env { get; } = new System.Collections.ObjectModel.Collection<string>();

        [System.Text.Json.Serialization.JsonPropertyName("Args")]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Args { get; } = new System.Collections.ObjectModel.Collection<string>();

        [System.Text.Json.Serialization.JsonPropertyName("Devices")]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PluginDevice> Devices { get; } = new System.Collections.ObjectModel.Collection<PluginDevice>();

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Config2
    {
        /// <summary>
        /// Docker Version used to create the plugin
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("DockerVersion")]
        public string DockerVersion { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Description")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Description { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Documentation")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Documentation { get; set; }

        /// <summary>
        /// The interface between Docker and the plugin
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Interface")]
        [System.ComponentModel.DataAnnotations.Required]
        public Interface Interface { get; set; } = new Interface();

        [System.Text.Json.Serialization.JsonPropertyName("Entrypoint")]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Entrypoint { get; } = new System.Collections.ObjectModel.Collection<string>();

        [System.Text.Json.Serialization.JsonPropertyName("WorkDir")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string WorkDir { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("User")]
        public User User { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Network")]
        [System.ComponentModel.DataAnnotations.Required]
        public Network2 Network { get; set; } = new Network2();

        [System.Text.Json.Serialization.JsonPropertyName("Linux")]
        [System.ComponentModel.DataAnnotations.Required]
        public Linux Linux { get; set; } = new Linux();

        [System.Text.Json.Serialization.JsonPropertyName("PropagatedMount")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string PropagatedMount { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("IpcHost")]
        public bool IpcHost { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("PidHost")]
        public bool PidHost { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Mounts")]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PluginMount> Mounts { get; } = new System.Collections.ObjectModel.Collection<PluginMount>();

        [System.Text.Json.Serialization.JsonPropertyName("Env")]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PluginEnv> Env { get; } = new System.Collections.ObjectModel.Collection<PluginEnv>();

        [System.Text.Json.Serialization.JsonPropertyName("Args")]
        [System.ComponentModel.DataAnnotations.Required]
        public Args Args { get; set; } = new Args();

        [System.Text.Json.Serialization.JsonPropertyName("rootfs")]
        public Rootfs Rootfs { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum NodeSpecRole
    {

        [System.Runtime.Serialization.EnumMember(Value = @"worker")]
        Worker = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"manager")]
        Manager = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum NodeSpecAvailability
    {

        [System.Runtime.Serialization.EnumMember(Value = @"active")]
        Active = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"pause")]
        Pause = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"drain")]
        Drain = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Plugins
    {

        [System.Text.Json.Serialization.JsonPropertyName("Type")]
        public string Type { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Name")]
        public string Name { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Orchestration
    {
        /// <summary>
        /// The number of historic tasks to keep per instance or node. If
        /// <br/>negative, never remove completed or failed tasks.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("TaskHistoryRetentionLimit")]
        public long? TaskHistoryRetentionLimit { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Raft
    {
        /// <summary>
        /// The number of log entries between snapshots.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("SnapshotInterval")]
        public ulong? SnapshotInterval { get; set; }

        /// <summary>
        /// The number of snapshots to keep beyond the current snapshot.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("KeepOldSnapshots")]
        public ulong? KeepOldSnapshots { get; set; }

        /// <summary>
        /// The number of log entries to keep around to sync up slow followers
        /// <br/>after a snapshot is created.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("LogEntriesForSlowFollowers")]
        public ulong? LogEntriesForSlowFollowers { get; set; }

        /// <summary>
        /// The number of ticks that a follower will wait for a message from
        /// <br/>the leader before becoming a candidate and starting an election.
        /// <br/>`ElectionTick` must be greater than `HeartbeatTick`.
        /// <br/>
        /// <br/>A tick currently defaults to one second, so these translate
        /// <br/>directly to seconds currently, but this is NOT guaranteed.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ElectionTick")]
        public int? ElectionTick { get; set; }

        /// <summary>
        /// The number of ticks between heartbeats. Every HeartbeatTick ticks,
        /// <br/>the leader will send a heartbeat to the followers.
        /// <br/>
        /// <br/>A tick currently defaults to one second, so these translate
        /// <br/>directly to seconds currently, but this is NOT guaranteed.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("HeartbeatTick")]
        public int? HeartbeatTick { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Dispatcher
    {
        /// <summary>
        /// The delay for an agent to send a heartbeat to the dispatcher.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("HeartbeatPeriod")]
        public long? HeartbeatPeriod { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CAConfig
    {
        /// <summary>
        /// The duration node certificates are issued for.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("NodeCertExpiry")]
        public long? NodeCertExpiry { get; set; }

        /// <summary>
        /// Configuration for forwarding signing requests to an external
        /// <br/>certificate authority.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ExternalCAs")]
        public System.Collections.Generic.ICollection<ExternalCAs> ExternalCAs { get; set; }

        /// <summary>
        /// The desired signing CA certificate for all swarm node TLS leaf
        /// <br/>certificates, in PEM format.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("SigningCACert")]
        public string SigningCACert { get; set; }

        /// <summary>
        /// The desired signing CA key for all swarm node TLS leaf certificates,
        /// <br/>in PEM format.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("SigningCAKey")]
        public string SigningCAKey { get; set; }

        /// <summary>
        /// An integer whose purpose is to force swarm to generate a new
        /// <br/>signing CA certificate and key, if none have been specified in
        /// <br/>`SigningCACert` and `SigningCAKey`
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ForceRotate")]
        public ulong? ForceRotate { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EncryptionConfig
    {
        /// <summary>
        /// If set, generate a key and use it to lock data stored on the
        /// <br/>managers.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("AutoLockManagers")]
        public bool? AutoLockManagers { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TaskDefaults
    {
        /// <summary>
        /// The log driver to use for tasks created in the orchestrator if
        /// <br/>unspecified by a service.
        /// <br/>
        /// <br/>Updating this value only affects new tasks. Existing tasks continue
        /// <br/>to use their previously configured log driver until recreated.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("LogDriver")]
        public LogDriver2 LogDriver { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PluginSpec
    {
        /// <summary>
        /// The name or 'alias' to use for the plugin.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Name")]
        public string Name { get; set; }

        /// <summary>
        /// The plugin image reference to use.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Remote")]
        public string Remote { get; set; }

        /// <summary>
        /// Disable the plugin once scheduled.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Disabled")]
        public bool? Disabled { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("PluginPrivilege")]
        public System.Collections.Generic.ICollection<PluginPrivilege> PluginPrivilege { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ContainerSpec
    {
        /// <summary>
        /// The image name to use for the container
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Image")]
        public string Image { get; set; }

        /// <summary>
        /// User-defined key/value data.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Labels")]
        public System.Collections.Generic.IDictionary<string, string> Labels { get; set; }

        /// <summary>
        /// The command to be run in the image.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Command")]
        public System.Collections.Generic.ICollection<string> Command { get; set; }

        /// <summary>
        /// Arguments to the command.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Args")]
        public System.Collections.Generic.ICollection<string> Args { get; set; }

        /// <summary>
        /// The hostname to use for the container, as a valid
        /// <br/>[RFC 1123](https://tools.ietf.org/html/rfc1123) hostname.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Hostname")]
        public string Hostname { get; set; }

        /// <summary>
        /// A list of environment variables in the form `VAR=value`.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Env")]
        public System.Collections.Generic.ICollection<string> Env { get; set; }

        /// <summary>
        /// The working directory for commands to run in.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Dir")]
        public string Dir { get; set; }

        /// <summary>
        /// The user inside the container.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("User")]
        public string User { get; set; }

        /// <summary>
        /// A list of additional groups that the container process will run as.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Groups")]
        public System.Collections.Generic.ICollection<string> Groups { get; set; }

        /// <summary>
        /// Security options for the container
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Privileges")]
        public Privileges Privileges { get; set; }

        /// <summary>
        /// Whether a pseudo-TTY should be allocated.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("TTY")]
        public bool? TTY { get; set; }

        /// <summary>
        /// Open `stdin`
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("OpenStdin")]
        public bool? OpenStdin { get; set; }

        /// <summary>
        /// Mount the container's root filesystem as read only.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ReadOnly")]
        public bool? ReadOnly { get; set; }

        /// <summary>
        /// Specification for mounts to be added to containers created as part
        /// <br/>of the service.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Mounts")]
        public System.Collections.Generic.ICollection<Mount> Mounts { get; set; }

        /// <summary>
        /// Signal to stop the container.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("StopSignal")]
        public string StopSignal { get; set; }

        /// <summary>
        /// Amount of time to wait for the container to terminate before
        /// <br/>forcefully killing it.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("StopGracePeriod")]
        public long? StopGracePeriod { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("HealthCheck")]
        public HealthConfig HealthCheck { get; set; }

        /// <summary>
        /// A list of hostname/IP mappings to add to the container's `hosts`
        /// <br/>file. The format of extra hosts is specified in the
        /// <br/>[hosts(5)](http://man7.org/linux/man-pages/man5/hosts.5.html)
        /// <br/>man page:
        /// <br/>
        /// <br/>    IP_address canonical_hostname [aliases...]
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Hosts")]
        public System.Collections.Generic.ICollection<string> Hosts { get; set; }

        /// <summary>
        /// Specification for DNS related configurations in resolver configuration
        /// <br/>file (`resolv.conf`).
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("DNSConfig")]
        public DNSConfig DNSConfig { get; set; }

        /// <summary>
        /// Secrets contains references to zero or more secrets that will be
        /// <br/>exposed to the service.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Secrets")]
        public System.Collections.Generic.ICollection<Secrets> Secrets { get; set; }

        /// <summary>
        /// An integer value containing the score given to the container in
        /// <br/>order to tune OOM killer preferences.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("OomScoreAdj")]
        public long? OomScoreAdj { get; set; }

        /// <summary>
        /// Configs contains references to zero or more configs that will be
        /// <br/>exposed to the service.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Configs")]
        public System.Collections.Generic.ICollection<Configs> Configs { get; set; }

        /// <summary>
        /// Isolation technology of the containers running the service.
        /// <br/>(Windows only)
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Isolation")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public ContainerSpecIsolation? Isolation { get; set; }

        /// <summary>
        /// Run an init inside the container that forwards signals and reaps
        /// <br/>processes. This field is omitted if empty, and the default (as
        /// <br/>configured on the daemon) is used.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Init")]
        public bool? Init { get; set; }

        /// <summary>
        /// Set kernel namedspaced parameters (sysctls) in the container.
        /// <br/>The Sysctls option on services accepts the same sysctls as the
        /// <br/>are supported on containers. Note that while the same sysctls are
        /// <br/>supported, no guarantees or checks are made about their
        /// <br/>suitability for a clustered environment, and it's up to the user
        /// <br/>to determine whether a given sysctl will work properly in a
        /// <br/>Service.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Sysctls")]
        public System.Collections.Generic.IDictionary<string, string> Sysctls { get; set; }

        /// <summary>
        /// A list of kernel capabilities to add to the default set
        /// <br/>for the container.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("CapabilityAdd")]
        public System.Collections.Generic.ICollection<string> CapabilityAdd { get; set; }

        /// <summary>
        /// A list of kernel capabilities to drop from the default set
        /// <br/>for the container.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("CapabilityDrop")]
        public System.Collections.Generic.ICollection<string> CapabilityDrop { get; set; }

        /// <summary>
        /// A list of resource limits to set in the container. For example: `{"Name": "nofile", "Soft": 1024, "Hard": 2048}`"
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Ulimits")]
        public System.Collections.Generic.ICollection<Ulimits2> Ulimits { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NetworkAttachmentSpec
    {
        /// <summary>
        /// ID of the container represented by this task
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ContainerID")]
        public string ContainerID { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Resources2
    {
        /// <summary>
        /// Define resources limits.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Limits")]
        public Limit Limits { get; set; }

        /// <summary>
        /// Define resources reservation.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Reservations")]
        public ResourceObject Reservations { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class RestartPolicy2
    {
        /// <summary>
        /// Condition for restart.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Condition")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public RestartPolicy2Condition? Condition { get; set; }

        /// <summary>
        /// Delay between restart attempts.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Delay")]
        public long? Delay { get; set; }

        /// <summary>
        /// Maximum attempts to restart a given container before giving up
        /// <br/>(default value is 0, which is ignored).
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("MaxAttempts")]
        public long? MaxAttempts { get; set; } = 0L;

        /// <summary>
        /// Windows is the time window used to evaluate the restart policy
        /// <br/>(default value is 0, which is unbounded).
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Window")]
        public long? Window { get; set; } = 0L;

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Placement
    {
        /// <summary>
        /// An array of constraint expressions to limit the set of nodes where
        /// <br/>a task can be scheduled. Constraint expressions can either use a
        /// <br/>_match_ (`==`) or _exclude_ (`!=`) rule. Multiple constraints find
        /// <br/>nodes that satisfy every expression (AND match). Constraints can
        /// <br/>match node or Docker Engine labels as follows:
        /// <br/>
        /// <br/>node attribute       | matches                        | example
        /// <br/>---------------------|--------------------------------|-----------------------------------------------
        /// <br/>`node.id`            | Node ID                        | `node.id==2ivku8v2gvtg4`
        /// <br/>`node.hostname`      | Node hostname                  | `node.hostname!=node-2`
        /// <br/>`node.role`          | Node role (`manager`/`worker`) | `node.role==manager`
        /// <br/>`node.platform.os`   | Node operating system          | `node.platform.os==windows`
        /// <br/>`node.platform.arch` | Node architecture              | `node.platform.arch==x86_64`
        /// <br/>`node.labels`        | User-defined node labels       | `node.labels.security==high`
        /// <br/>`engine.labels`      | Docker Engine's labels         | `engine.labels.operatingsystem==ubuntu-24.04`
        /// <br/>
        /// <br/>`engine.labels` apply to Docker Engine labels like operating system,
        /// <br/>drivers, etc. Swarm administrators add `node.labels` for operational
        /// <br/>purposes by using the [`node update endpoint`](#operation/NodeUpdate).
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Constraints")]
        public System.Collections.Generic.ICollection<string> Constraints { get; set; }

        /// <summary>
        /// Preferences provide a way to make the scheduler aware of factors
        /// <br/>such as topology. They are provided in order from highest to
        /// <br/>lowest precedence.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Preferences")]
        public System.Collections.Generic.ICollection<Preferences> Preferences { get; set; }

        /// <summary>
        /// Maximum number of replicas for per node (default value is 0, which
        /// <br/>is unlimited)
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("MaxReplicas")]
        public long? MaxReplicas { get; set; } = 0L;

        /// <summary>
        /// Platforms stores all the platforms that the service's image can
        /// <br/>run on. This field is used in the platform filter for scheduling.
        /// <br/>If empty, then the platform filter is off, meaning there are no
        /// <br/>scheduling restrictions.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Platforms")]
        public System.Collections.Generic.ICollection<Platform> Platforms { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class LogDriver
    {

        [System.Text.Json.Serialization.JsonPropertyName("Name")]
        public string Name { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Options")]
        public System.Collections.Generic.IDictionary<string, string> Options { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Mode
    {

        [System.Text.Json.Serialization.JsonPropertyName("Replicated")]
        public Replicated Replicated { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Global")]
        public object Global { get; set; }

        /// <summary>
        /// The mode used for services with a finite number of tasks that run
        /// <br/>to a completed state.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ReplicatedJob")]
        public ReplicatedJob ReplicatedJob { get; set; }

        /// <summary>
        /// The mode used for services which run a task to the completed state
        /// <br/>on each valid node.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("GlobalJob")]
        public object GlobalJob { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class UpdateConfig
    {
        /// <summary>
        /// Maximum number of tasks to be updated in one iteration (0 means
        /// <br/>unlimited parallelism).
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Parallelism")]
        public long? Parallelism { get; set; }

        /// <summary>
        /// Amount of time between updates, in nanoseconds.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Delay")]
        public long? Delay { get; set; }

        /// <summary>
        /// Action to take if an updated task fails to run, or stops running
        /// <br/>during the update.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("FailureAction")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public UpdateConfigFailureAction? FailureAction { get; set; }

        /// <summary>
        /// Amount of time to monitor each updated task for failures, in
        /// <br/>nanoseconds.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Monitor")]
        public long? Monitor { get; set; }

        /// <summary>
        /// The fraction of tasks that may fail during an update before the
        /// <br/>failure action is invoked, specified as a floating point number
        /// <br/>between 0 and 1.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("MaxFailureRatio")]
        public double? MaxFailureRatio { get; set; } = 0D;

        /// <summary>
        /// The order of operations when rolling out an updated task. Either
        /// <br/>the old task is shut down before the new task is started, or the
        /// <br/>new task is started before the old task is shut down.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Order")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public UpdateConfigOrder? Order { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class RollbackConfig
    {
        /// <summary>
        /// Maximum number of tasks to be rolled back in one iteration (0 means
        /// <br/>unlimited parallelism).
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Parallelism")]
        public long? Parallelism { get; set; }

        /// <summary>
        /// Amount of time between rollback iterations, in nanoseconds.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Delay")]
        public long? Delay { get; set; }

        /// <summary>
        /// Action to take if an rolled back task fails to run, or stops
        /// <br/>running during the rollback.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("FailureAction")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public RollbackConfigFailureAction? FailureAction { get; set; }

        /// <summary>
        /// Amount of time to monitor each rolled back task for failures, in
        /// <br/>nanoseconds.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Monitor")]
        public long? Monitor { get; set; }

        /// <summary>
        /// The fraction of tasks that may fail during a rollback before the
        /// <br/>failure action is invoked, specified as a floating point number
        /// <br/>between 0 and 1.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("MaxFailureRatio")]
        public double? MaxFailureRatio { get; set; } = 0D;

        /// <summary>
        /// The order of operations when rolling back a task. Either the old
        /// <br/>task is shut down before the new task is started, or the new task
        /// <br/>is started before the old task is shut down.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Order")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public RollbackConfigOrder? Order { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum EndpointPortConfigProtocol
    {

        [System.Runtime.Serialization.EnumMember(Value = @"tcp")]
        Tcp = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"udp")]
        Udp = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"sctp")]
        Sctp = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum EndpointPortConfigPublishMode
    {

        [System.Runtime.Serialization.EnumMember(Value = @"ingress")]
        Ingress = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"host")]
        Host = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum EndpointSpecMode
    {

        [System.Runtime.Serialization.EnumMember(Value = @"vip")]
        Vip = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"dnsrr")]
        Dnsrr = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Endpoint
    {

        [System.Text.Json.Serialization.JsonPropertyName("Spec")]
        public EndpointSpec Spec { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Ports")]
        public System.Collections.Generic.ICollection<EndpointPortConfig> Ports { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("VirtualIPs")]
        public System.Collections.Generic.ICollection<VirtualIPs> VirtualIPs { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class UpdateStatus
    {

        [System.Text.Json.Serialization.JsonPropertyName("State")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public UpdateStatusState? State { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("StartedAt")]
        public string StartedAt { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("CompletedAt")]
        public string CompletedAt { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Message")]
        public string Message { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ServiceStatus
    {
        /// <summary>
        /// The number of tasks for the service currently in the Running state.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("RunningTasks")]
        public ulong? RunningTasks { get; set; }

        /// <summary>
        /// The number of tasks for the service desired to be running.
        /// <br/>For replicated services, this is the replica count from the
        /// <br/>service spec. For global services, this is computed by taking
        /// <br/>count of all tasks for the service with a Desired State other
        /// <br/>than Shutdown.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("DesiredTasks")]
        public ulong? DesiredTasks { get; set; }

        /// <summary>
        /// The number of tasks for a job that are in the Completed state.
        /// <br/>This field must be cross-referenced with the service type, as the
        /// <br/>value of 0 may mean the service is not in a job mode, or it may
        /// <br/>mean the job-mode service has no tasks yet Completed.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("CompletedTasks")]
        public ulong? CompletedTasks { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class JobStatus
    {
        /// <summary>
        /// JobIteration is a value increased each time a Job is executed,
        /// <br/>successfully or otherwise. "Executed", in this case, means the
        /// <br/>job as a whole has been started, not that an individual Task has
        /// <br/>been launched. A job is "Executed" when its ServiceSpec is
        /// <br/>updated. JobIteration can be used to disambiguate Tasks belonging
        /// <br/>to different executions of a job.  Though JobIteration will
        /// <br/>increase with each subsequent execution, it may not necessarily
        /// <br/>increase by 1, and so JobIteration should not be used to
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("JobIteration")]
        public ObjectVersion JobIteration { get; set; }

        /// <summary>
        /// The last time, as observed by the server, that this job was
        /// <br/>started.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("LastExecution")]
        public string LastExecution { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class HostConfig2
    {

        [System.Text.Json.Serialization.JsonPropertyName("NetworkMode")]
        public string NetworkMode { get; set; }

        /// <summary>
        /// Arbitrary key-value metadata attached to container
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Annotations")]
        public System.Collections.Generic.IDictionary<string, string> Annotations { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NetworkSettings2
    {

        [System.Text.Json.Serialization.JsonPropertyName("Networks")]
        public System.Collections.Generic.IDictionary<string, EndpointSettings> Networks { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ContainerStateStatus
    {

        [System.Runtime.Serialization.EnumMember(Value = @"created")]
        Created = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"running")]
        Running = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"paused")]
        Paused = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"restarting")]
        Restarting = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"removing")]
        Removing = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"exited")]
        Exited = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"dead")]
        Dead = 6,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Platform2
    {

        [System.Text.Json.Serialization.JsonPropertyName("Name")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Components
    {
        /// <summary>
        /// Name of the component
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Name")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// Version of the component
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Version")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Version { get; set; }

        /// <summary>
        /// Key/value pairs of strings with additional information about the
        /// <br/>component. These values are intended for informational purposes
        /// <br/>only, and their content is not defined, and not part of the API
        /// <br/>specification.
        /// <br/>
        /// <br/>These messages can be printed by the client as information to the user.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Details")]
        public object Details { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum SystemInfoCgroupDriver
    {

        [System.Runtime.Serialization.EnumMember(Value = @"cgroupfs")]
        Cgroupfs = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"systemd")]
        Systemd = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"none")]
        None = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum SystemInfoCgroupVersion
    {

        [System.Runtime.Serialization.EnumMember(Value = @"1")]
        _1 = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"2")]
        _2 = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum SystemInfoIsolation
    {

        [System.Runtime.Serialization.EnumMember(Value = @"default")]
        Default = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"hyperv")]
        Hyperv = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"process")]
        Process = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class DefaultAddressPools
    {
        /// <summary>
        /// The network address in CIDR format
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Base")]
        public string Base { get; set; }

        /// <summary>
        /// The network pool size
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Size")]
        public int? Size { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Namespaces
    {
        /// <summary>
        /// The default containerd namespace used for containers managed
        /// <br/>by the daemon.
        /// <br/>
        /// <br/>The default namespace for containers is "moby", but will be
        /// <br/>suffixed with the `&lt;uid&gt;.&lt;gid&gt;` of the remapped `root` if
        /// <br/>user-namespaces are enabled and the containerd image-store
        /// <br/>is used.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Containers")]
        public string Containers { get; set; } = "moby";

        /// <summary>
        /// The default containerd namespace used for plugins managed by
        /// <br/>the daemon.
        /// <br/>
        /// <br/>The default namespace for plugins is "plugins.moby", but will be
        /// <br/>suffixed with the `&lt;uid&gt;.&lt;gid&gt;` of the remapped `root` if
        /// <br/>user-namespaces are enabled and the containerd image-store
        /// <br/>is used.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Plugins")]
        public string Plugins { get; set; } = "plugins.moby";

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum EventMessageType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"builder")]
        Builder = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"config")]
        Config = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"container")]
        Container = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"daemon")]
        Daemon = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"image")]
        Image = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"network")]
        Network = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"node")]
        Node = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"plugin")]
        Plugin = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"secret")]
        Secret = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"service")]
        Service = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"volume")]
        Volume = 10,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum EventMessageScope
    {

        [System.Runtime.Serialization.EnumMember(Value = @"local")]
        Local = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"swarm")]
        Swarm = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Info
    {
        /// <summary>
        /// The capacity of the volume in bytes. A value of 0 indicates that
        /// <br/>the capacity is unknown.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("CapacityBytes")]
        public long? CapacityBytes { get; set; }

        /// <summary>
        /// A map of strings to strings returned from the storage plugin when
        /// <br/>the volume is created.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("VolumeContext")]
        public System.Collections.Generic.IDictionary<string, string> VolumeContext { get; set; }

        /// <summary>
        /// The ID of the volume as returned by the CSI storage plugin. This
        /// <br/>is distinct from the volume's ID as provided by Docker. This ID
        /// <br/>is never used by the user when communicating with Docker to refer
        /// <br/>to this volume. If the ID is blank, then the Volume has not been
        /// <br/>successfully created in the plugin yet.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("VolumeID")]
        public string VolumeID { get; set; }

        /// <summary>
        /// The topology this volume is actually accessible from.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("AccessibleTopology")]
        public System.Collections.Generic.ICollection<Topology> AccessibleTopology { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PublishStatus
    {
        /// <summary>
        /// The ID of the Swarm node the volume is published on.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("NodeID")]
        public string NodeID { get; set; }

        /// <summary>
        /// The published state of the volume.
        /// <br/>* `pending-publish` The volume should be published to this node, but the call to the controller plugin to do so has not yet been successfully completed.
        /// <br/>* `published` The volume is published successfully to the node.
        /// <br/>* `pending-node-unpublish` The volume should be unpublished from the node, and the manager is awaiting confirmation from the worker that it has done so.
        /// <br/>* `pending-controller-unpublish` The volume is successfully unpublished from the node, but has not yet been successfully unpublished on the controller.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("State")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public PublishStatusState? State { get; set; }

        /// <summary>
        /// A map of strings to strings returned by the CSI controller
        /// <br/>plugin when a volume is published.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("PublishContext")]
        public System.Collections.Generic.IDictionary<string, string> PublishContext { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AccessMode
    {
        /// <summary>
        /// The set of nodes this volume can be used on at one time.
        /// <br/>- `single` The volume may only be scheduled to one node at a time.
        /// <br/>- `multi` the volume may be scheduled to any supported number of nodes at a time.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Scope")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public AccessModeScope? Scope { get; set; } = DockerEngine.AccessModeScope.Single;

        /// <summary>
        /// The number and way that different tasks can use this volume
        /// <br/>at one time.
        /// <br/>- `none` The volume may only be used by one task at a time.
        /// <br/>- `readonly` The volume may be used by any number of tasks, but they all must mount the volume as readonly
        /// <br/>- `onewriter` The volume may be used by any number of tasks, but only one may mount it as read/write.
        /// <br/>- `all` The volume may have any number of readers and writers.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Sharing")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public AccessModeSharing? Sharing { get; set; } = DockerEngine.AccessModeSharing.None;

        /// <summary>
        /// Options for using this volume as a Mount-type volume.
        /// <br/>
        /// <br/>    Either MountVolume or BlockVolume, but not both, must be
        /// <br/>    present.
        /// <br/>  properties:
        /// <br/>    FsType:
        /// <br/>      type: "string"
        /// <br/>      description: |
        /// <br/>        Specifies the filesystem type for the mount volume.
        /// <br/>        Optional.
        /// <br/>    MountFlags:
        /// <br/>      type: "array"
        /// <br/>      description: |
        /// <br/>        Flags to pass when mounting the volume. Optional.
        /// <br/>      items:
        /// <br/>        type: "string"
        /// <br/>BlockVolume:
        /// <br/>  type: "object"
        /// <br/>  description: |
        /// <br/>    Options for using this volume as a Block-type volume.
        /// <br/>    Intentionally empty.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("MountVolume")]
        public object MountVolume { get; set; }

        /// <summary>
        /// Swarm Secrets that are passed to the CSI storage plugin when
        /// <br/>operating on this volume.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Secrets")]
        public System.Collections.Generic.ICollection<Secrets2> Secrets { get; set; }

        /// <summary>
        /// Requirements for the accessible topology of the volume. These
        /// <br/>fields are optional. For an in-depth description of what these
        /// <br/>fields mean, see the CSI specification.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("AccessibilityRequirements")]
        public AccessibilityRequirements AccessibilityRequirements { get; set; }

        /// <summary>
        /// The desired capacity that the volume should be created with. If
        /// <br/>empty, the plugin will decide the capacity.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("CapacityRange")]
        public CapacityRange CapacityRange { get; set; }

        /// <summary>
        /// The availability of the volume for use in tasks.
        /// <br/>- `active` The volume is fully available for scheduling on the cluster
        /// <br/>- `pause` No new workloads should use the volume, but existing workloads are not stopped.
        /// <br/>- `drain` All workloads using this volume should be stopped and rescheduled, and no new ones should be started.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Availability")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public AccessModeAvailability? Availability { get; set; } = DockerEngine.AccessModeAvailability.Active;

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum BindOptionsPropagation
    {

        [System.Runtime.Serialization.EnumMember(Value = @"private")]
        Private = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"rprivate")]
        Rprivate = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"shared")]
        Shared = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"rshared")]
        Rshared = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"slave")]
        Slave = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"rslave")]
        Rslave = 5,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class DriverConfig
    {
        /// <summary>
        /// Name of the driver to use to create the volume.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Name")]
        public string Name { get; set; }

        /// <summary>
        /// key/value map of driver specific options.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Options")]
        public System.Collections.Generic.IDictionary<string, string> Options { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NamedResourceSpec
    {

        [System.Text.Json.Serialization.JsonPropertyName("Kind")]
        public string Kind { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Value")]
        public string Value { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class DiscreteResourceSpec
    {

        [System.Text.Json.Serialization.JsonPropertyName("Kind")]
        public string Kind { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Value")]
        public long? Value { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum LogConfigType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"json-file")]
        JsonFile = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"syslog")]
        Syslog = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"journald")]
        Journald = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"gelf")]
        Gelf = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"fluentd")]
        Fluentd = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"awslogs")]
        Awslogs = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"splunk")]
        Splunk = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"etwlogs")]
        Etwlogs = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"none")]
        None = 8,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Interface
    {

        [System.Text.Json.Serialization.JsonPropertyName("Types")]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PluginInterfaceType> Types { get; } = new System.Collections.ObjectModel.Collection<PluginInterfaceType>();

        [System.Text.Json.Serialization.JsonPropertyName("Socket")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Socket { get; set; }

        /// <summary>
        /// Protocol to use for clients connecting to the plugin.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ProtocolScheme")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public InterfaceProtocolScheme? ProtocolScheme { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class User
    {

        [System.Text.Json.Serialization.JsonPropertyName("UID")]
        public int? UID { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("GID")]
        public int? GID { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Network2
    {

        [System.Text.Json.Serialization.JsonPropertyName("Type")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Type { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Linux
    {

        [System.Text.Json.Serialization.JsonPropertyName("Capabilities")]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Capabilities { get; } = new System.Collections.ObjectModel.Collection<string>();

        [System.Text.Json.Serialization.JsonPropertyName("AllowAllDevices")]
        public bool AllowAllDevices { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Devices")]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PluginDevice> Devices { get; } = new System.Collections.ObjectModel.Collection<PluginDevice>();

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Args
    {

        [System.Text.Json.Serialization.JsonPropertyName("Name")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Description")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Description { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Settable")]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Settable { get; } = new System.Collections.ObjectModel.Collection<string>();

        [System.Text.Json.Serialization.JsonPropertyName("Value")]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Value { get; } = new System.Collections.ObjectModel.Collection<string>();

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Rootfs
    {

        [System.Text.Json.Serialization.JsonPropertyName("type")]
        public string Type { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("diff_ids")]
        public System.Collections.Generic.ICollection<string> Diff_ids { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ExternalCAs
    {
        /// <summary>
        /// Protocol for communication with the external CA (currently
        /// <br/>only `cfssl` is supported).
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Protocol")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public ExternalCAsProtocol? Protocol { get; set; } = DockerEngine.ExternalCAsProtocol.Cfssl;

        /// <summary>
        /// URL where certificate signing requests should be sent.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("URL")]
        public string URL { get; set; }

        /// <summary>
        /// An object with key/value pairs that are interpreted as
        /// <br/>protocol-specific options for the external CA driver.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Options")]
        public System.Collections.Generic.IDictionary<string, string> Options { get; set; }

        /// <summary>
        /// The root CA certificate (in PEM format) this external CA uses
        /// <br/>to issue TLS certificates (assumed to be to the current swarm
        /// <br/>root CA certificate if not provided).
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("CACert")]
        public string CACert { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class LogDriver2
    {
        /// <summary>
        /// The log driver to use as a default for new tasks.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Name")]
        public string Name { get; set; }

        /// <summary>
        /// Driver-specific options for the selectd log driver, specified
        /// <br/>as key/value pairs.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Options")]
        public System.Collections.Generic.IDictionary<string, string> Options { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Privileges
    {
        /// <summary>
        /// CredentialSpec for managed service account (Windows only)
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("CredentialSpec")]
        public CredentialSpec CredentialSpec { get; set; }

        /// <summary>
        /// SELinux labels of the container
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("SELinuxContext")]
        public SELinuxContext SELinuxContext { get; set; }

        /// <summary>
        /// Options for configuring seccomp on the container
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Seccomp")]
        public Seccomp Seccomp { get; set; }

        /// <summary>
        /// Options for configuring AppArmor on the container
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("AppArmor")]
        public AppArmor AppArmor { get; set; }

        /// <summary>
        /// Configuration of the no_new_privs bit in the container
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("NoNewPrivileges")]
        public bool? NoNewPrivileges { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class DNSConfig
    {
        /// <summary>
        /// The IP addresses of the name servers.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Nameservers")]
        public System.Collections.Generic.ICollection<string> Nameservers { get; set; }

        /// <summary>
        /// A search list for host-name lookup.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Search")]
        public System.Collections.Generic.ICollection<string> Search { get; set; }

        /// <summary>
        /// A list of internal resolver variables to be modified (e.g.,
        /// <br/>`debug`, `ndots:3`, etc.).
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Options")]
        public System.Collections.Generic.ICollection<string> Options { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Secrets
    {
        /// <summary>
        /// File represents a specific target that is backed by a file.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("File")]
        public File File { get; set; }

        /// <summary>
        /// SecretID represents the ID of the specific secret that we're
        /// <br/>referencing.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("SecretID")]
        public string SecretID { get; set; }

        /// <summary>
        /// SecretName is the name of the secret that this references,
        /// <br/>but this is just provided for lookup/display purposes. The
        /// <br/>secret in the reference will be identified by its ID.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("SecretName")]
        public string SecretName { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Configs
    {
        /// <summary>
        /// File represents a specific target that is backed by a file.
        /// <br/>
        /// <br/>&lt;p&gt;&lt;br /&gt;&lt;p&gt;
        /// <br/>
        /// <br/>&gt; **Note**: `Configs.File` and `Configs.Runtime` are mutually exclusive
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("File")]
        public File2 File { get; set; }

        /// <summary>
        /// Runtime represents a target that is not mounted into the
        /// <br/>container but is used by the task
        /// <br/>
        /// <br/>&lt;p&gt;&lt;br /&gt;&lt;p&gt;
        /// <br/>
        /// <br/>&gt; **Note**: `Configs.File` and `Configs.Runtime` are mutually
        /// <br/>&gt; exclusive
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Runtime")]
        public object Runtime { get; set; }

        /// <summary>
        /// ConfigID represents the ID of the specific config that we're
        /// <br/>referencing.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ConfigID")]
        public string ConfigID { get; set; }

        /// <summary>
        /// ConfigName is the name of the config that this references,
        /// <br/>but this is just provided for lookup/display purposes. The
        /// <br/>config in the reference will be identified by its ID.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ConfigName")]
        public string ConfigName { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ContainerSpecIsolation
    {

        [System.Runtime.Serialization.EnumMember(Value = @"default")]
        Default = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"process")]
        Process = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"hyperv")]
        Hyperv = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Ulimits2
    {
        /// <summary>
        /// Name of ulimit
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Name")]
        public string Name { get; set; }

        /// <summary>
        /// Soft limit
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Soft")]
        public int? Soft { get; set; }

        /// <summary>
        /// Hard limit
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Hard")]
        public int? Hard { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum RestartPolicy2Condition
    {

        [System.Runtime.Serialization.EnumMember(Value = @"none")]
        None = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"on-failure")]
        OnFailure = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"any")]
        Any = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Preferences
    {

        [System.Text.Json.Serialization.JsonPropertyName("Spread")]
        public Spread Spread { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Replicated
    {

        [System.Text.Json.Serialization.JsonPropertyName("Replicas")]
        public long? Replicas { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ReplicatedJob
    {
        /// <summary>
        /// The maximum number of replicas to run simultaneously.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("MaxConcurrent")]
        public long? MaxConcurrent { get; set; } = 1L;

        /// <summary>
        /// The total number of replicas desired to reach the Completed
        /// <br/>state. If unset, will default to the value of `MaxConcurrent`
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("TotalCompletions")]
        public long? TotalCompletions { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum UpdateConfigFailureAction
    {

        [System.Runtime.Serialization.EnumMember(Value = @"continue")]
        Continue = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"pause")]
        Pause = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"rollback")]
        Rollback = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum UpdateConfigOrder
    {

        [System.Runtime.Serialization.EnumMember(Value = @"stop-first")]
        StopFirst = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"start-first")]
        StartFirst = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum RollbackConfigFailureAction
    {

        [System.Runtime.Serialization.EnumMember(Value = @"continue")]
        Continue = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"pause")]
        Pause = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum RollbackConfigOrder
    {

        [System.Runtime.Serialization.EnumMember(Value = @"stop-first")]
        StopFirst = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"start-first")]
        StartFirst = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class VirtualIPs
    {

        [System.Text.Json.Serialization.JsonPropertyName("NetworkID")]
        public string NetworkID { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("Addr")]
        public string Addr { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum UpdateStatusState
    {

        [System.Runtime.Serialization.EnumMember(Value = @"updating")]
        Updating = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"paused")]
        Paused = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"completed")]
        Completed = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PublishStatusState
    {

        [System.Runtime.Serialization.EnumMember(Value = @"pending-publish")]
        PendingPublish = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"published")]
        Published = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"pending-node-unpublish")]
        PendingNodeUnpublish = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"pending-controller-unpublish")]
        PendingControllerUnpublish = 3,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum AccessModeScope
    {

        [System.Runtime.Serialization.EnumMember(Value = @"single")]
        Single = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"multi")]
        Multi = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum AccessModeSharing
    {

        [System.Runtime.Serialization.EnumMember(Value = @"none")]
        None = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"readonly")]
        Readonly = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"onewriter")]
        Onewriter = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"all")]
        All = 3,

    }

    /// <summary>
    /// One cluster volume secret entry. Defines a key-value pair that
    /// <br/>is passed to the plugin.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Secrets2
    {
        /// <summary>
        /// Key is the name of the key of the key-value pair passed to
        /// <br/>the plugin.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Key")]
        public string Key { get; set; }

        /// <summary>
        /// Secret is the swarm Secret object from which to read data.
        /// <br/>This can be a Secret name or ID. The Secret data is
        /// <br/>retrieved by swarm and used as the value of the key-value
        /// <br/>pair passed to the plugin.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Secret")]
        public string Secret { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AccessibilityRequirements
    {
        /// <summary>
        /// A list of required topologies, at least one of which the
        /// <br/>volume must be accessible from.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Requisite")]
        public System.Collections.Generic.ICollection<Topology> Requisite { get; set; }

        /// <summary>
        /// A list of topologies that the volume should attempt to be
        /// <br/>provisioned in.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Preferred")]
        public System.Collections.Generic.ICollection<Topology> Preferred { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CapacityRange
    {
        /// <summary>
        /// The volume must be at least this big. The value of 0
        /// <br/>indicates an unspecified minimum
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("RequiredBytes")]
        public long? RequiredBytes { get; set; }

        /// <summary>
        /// The volume must not be bigger than this. The value of 0
        /// <br/>indicates an unspecified maximum.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("LimitBytes")]
        public long? LimitBytes { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum AccessModeAvailability
    {

        [System.Runtime.Serialization.EnumMember(Value = @"active")]
        Active = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"pause")]
        Pause = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"drain")]
        Drain = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum InterfaceProtocolScheme
    {

        [System.Runtime.Serialization.EnumMember(Value = @"")]
        Empty = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"moby.plugins.http/v1")]
        Moby_plugins_http_v1 = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ExternalCAsProtocol
    {

        [System.Runtime.Serialization.EnumMember(Value = @"cfssl")]
        Cfssl = 0,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CredentialSpec
    {
        /// <summary>
        /// Load credential spec from a Swarm Config with the given ID.
        /// <br/>The specified config must also be present in the Configs
        /// <br/>field with the Runtime property set.
        /// <br/>
        /// <br/>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
        /// <br/>
        /// <br/>
        /// <br/>&gt; **Note**: `CredentialSpec.File`, `CredentialSpec.Registry`,
        /// <br/>&gt; and `CredentialSpec.Config` are mutually exclusive.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Config")]
        public string Config { get; set; }

        /// <summary>
        /// Load credential spec from this file. The file is read by
        /// <br/>the daemon, and must be present in the `CredentialSpecs`
        /// <br/>subdirectory in the docker data directory, which defaults
        /// <br/>to `C:\ProgramData\Docker\` on Windows.
        /// <br/>
        /// <br/>For example, specifying `spec.json` loads
        /// <br/>`C:\ProgramData\Docker\CredentialSpecs\spec.json`.
        /// <br/>
        /// <br/>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
        /// <br/>
        /// <br/>&gt; **Note**: `CredentialSpec.File`, `CredentialSpec.Registry`,
        /// <br/>&gt; and `CredentialSpec.Config` are mutually exclusive.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("File")]
        public string File { get; set; }

        /// <summary>
        /// Load credential spec from this value in the Windows
        /// <br/>registry. The specified registry value must be located in:
        /// <br/>
        /// <br/>`HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Virtualization\Containers\CredentialSpecs`
        /// <br/>
        /// <br/>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
        /// <br/>
        /// <br/>
        /// <br/>&gt; **Note**: `CredentialSpec.File`, `CredentialSpec.Registry`,
        /// <br/>&gt; and `CredentialSpec.Config` are mutually exclusive.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Registry")]
        public string Registry { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SELinuxContext
    {
        /// <summary>
        /// Disable SELinux
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Disable")]
        public bool? Disable { get; set; }

        /// <summary>
        /// SELinux user label
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("User")]
        public string User { get; set; }

        /// <summary>
        /// SELinux role label
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Role")]
        public string Role { get; set; }

        /// <summary>
        /// SELinux type label
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Type")]
        public string Type { get; set; }

        /// <summary>
        /// SELinux level label
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Level")]
        public string Level { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Seccomp
    {

        [System.Text.Json.Serialization.JsonPropertyName("Mode")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public SeccompMode? Mode { get; set; }

        /// <summary>
        /// The custom seccomp profile as a json object
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Profile")]
        public string Profile { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AppArmor
    {

        [System.Text.Json.Serialization.JsonPropertyName("Mode")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public AppArmorMode? Mode { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class File
    {
        /// <summary>
        /// Name represents the final filename in the filesystem.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Name")]
        public string Name { get; set; }

        /// <summary>
        /// UID represents the file UID.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("UID")]
        public string UID { get; set; }

        /// <summary>
        /// GID represents the file GID.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("GID")]
        public string GID { get; set; }

        /// <summary>
        /// Mode represents the FileMode of the file.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Mode")]
        public int? Mode { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class File2
    {
        /// <summary>
        /// Name represents the final filename in the filesystem.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Name")]
        public string Name { get; set; }

        /// <summary>
        /// UID represents the file UID.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("UID")]
        public string UID { get; set; }

        /// <summary>
        /// GID represents the file GID.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("GID")]
        public string GID { get; set; }

        /// <summary>
        /// Mode represents the FileMode of the file.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("Mode")]
        public int? Mode { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Spread
    {
        /// <summary>
        /// label descriptor, such as `engine.labels.az`.
        /// <br/>
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("SpreadDescriptor")]
        public string SpreadDescriptor { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum SeccompMode
    {

        [System.Runtime.Serialization.EnumMember(Value = @"default")]
        Default = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"unconfined")]
        Unconfined = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"custom")]
        Custom = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum AppArmorMode
    {

        [System.Runtime.Serialization.EnumMember(Value = @"default")]
        Default = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"disabled")]
        Disabled = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FileParameter
    {
        public FileParameter(System.IO.Stream data)
            : this (data, null, null)
        {
        }

        public FileParameter(System.IO.Stream data, string fileName)
            : this (data, fileName, null)
        {
        }

        public FileParameter(System.IO.Stream data, string fileName, string contentType)
        {
            Data = data;
            FileName = fileName;
            ContentType = contentType;
        }

        public System.IO.Stream Data { get; private set; }

        public string FileName { get; private set; }

        public string ContentType { get; private set; }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FileResponse : System.IDisposable
    {
        private System.IDisposable _client;
        private System.IDisposable _response;

        public int StatusCode { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public System.IO.Stream Stream { get; private set; }

        public bool IsPartial
        {
            get { return StatusCode == 206; }
        }

        public FileResponse(int statusCode, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.IO.Stream stream, System.IDisposable client, System.IDisposable response)
        {
            StatusCode = statusCode;
            Headers = headers;
            Stream = stream;
            _client = client;
            _response = response;
        }

        public void Dispose()
        {
            Stream.Dispose();
            if (_response != null)
                _response.Dispose();
            if (_client != null)
                _client.Dispose();
        }
    }


    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ApiException : System.Exception
    {
        public int StatusCode { get; private set; }

        public string Response { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Exception innerException)
            : base(message + "\n\nStatus: " + statusCode + "\nResponse: \n" + ((response == null) ? "(null)" : response.Substring(0, response.Length >= 512 ? 512 : response.Length)), innerException)
        {
            StatusCode = statusCode;
            Response = response;
            Headers = headers;
        }

        public override string ToString()
        {
            return string.Format("HTTP Response: \n\n{0}\n\n{1}", Response, base.ToString());
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ApiException<TResult> : ApiException
    {
        public TResult Result { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, TResult result, System.Exception innerException)
            : base(message, statusCode, response, headers, innerException)
        {
            Result = result;
        }
    }

}

#pragma warning restore  108
#pragma warning restore  114
#pragma warning restore  472
#pragma warning restore  612
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8603
#pragma warning restore 8604
#pragma warning restore 8625